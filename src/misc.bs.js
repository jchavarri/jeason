// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Buffer = require("bs-platform/lib/js/buffer.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Filename = require("bs-platform/lib/js/filename.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Fatal_error = Caml_exceptions.create("Misc-Jeason.Fatal_error");

function fatal_error(msg) {
  Pervasives.prerr_string(">> Fatal error: ");
  console.error(msg);
  throw Fatal_error;
}

function try_finally(work, cleanup) {
  var result;
  try {
    result = Curry._1(work, /* () */0);
  }
  catch (e){
    Curry._1(cleanup, /* () */0);
    throw e;
  }
  Curry._1(cleanup, /* () */0);
  return result;
}

function map_end(f, l1, l2) {
  if (l1) {
    return /* :: */[
            Curry._1(f, l1[0]),
            map_end(f, l1[1], l2)
          ];
  } else {
    return l2;
  }
}

function map_left_right(f, param) {
  if (param) {
    var res = Curry._1(f, param[0]);
    return /* :: */[
            res,
            map_left_right(f, param[1])
          ];
  } else {
    return /* [] */0;
  }
}

function for_all2(pred, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2 && Curry._2(pred, l1[0], l2[0])) {
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else if (l2) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
}

function replicate_list(elem, n) {
  if (n <= 0) {
    return /* [] */0;
  } else {
    return /* :: */[
            elem,
            replicate_list(elem, n - 1 | 0)
          ];
  }
}

function list_remove(x, param) {
  if (param) {
    var tl = param[1];
    var hd = param[0];
    if (Caml_obj.caml_equal(hd, x)) {
      return tl;
    } else {
      return /* :: */[
              hd,
              list_remove(x, tl)
            ];
    }
  } else {
    return /* [] */0;
  }
}

function split_last(param) {
  if (param) {
    var tl = param[1];
    var x = param[0];
    if (tl) {
      var match = split_last(tl);
      return /* tuple */[
              /* :: */[
                x,
                match[0]
              ],
              match[1]
            ];
    } else {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "misc.ml",
            54,
            10
          ]
        ];
  }
}

function samelist(pred, _l1, _l2) {
  while(true) {
    var l2 = _l2;
    var l1 = _l1;
    if (l1) {
      if (l2 && Curry._2(pred, l1[0], l2[0])) {
        _l2 = l2[1];
        _l1 = l1[1];
        continue ;
        
      } else {
        return /* false */0;
      }
    } else if (l2) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
}

function may(f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return /* () */0;
  }
}

function may_map(f, param) {
  if (param) {
    return /* Some */[Curry._1(f, param[0])];
  } else {
    return /* None */0;
  }
}

function find_in_path(path, name) {
  if (Curry._1(Filename.is_implicit, name)) {
    var _param = path;
    while(true) {
      var param = _param;
      if (param) {
        var fullname = Filename.concat(param[0], name);
        if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
          return fullname;
        } else {
          _param = param[1];
          continue ;
          
        }
      } else {
        throw Caml_builtin_exceptions.not_found;
      }
    };
  } else if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
    return name;
  } else {
    throw Caml_builtin_exceptions.not_found;
  }
}

function find_in_path_rel(path, name) {
  var simplify = function (_s) {
    while(true) {
      var s = _s;
      var base = Curry._1(Filename.basename, s);
      var dir = Curry._1(Filename.dirname, s);
      if (dir === s) {
        return dir;
      } else if (base === Filename.current_dir_name) {
        _s = dir;
        continue ;
        
      } else {
        return Filename.concat(simplify(dir), base);
      }
    };
  };
  var _param = path;
  while(true) {
    var param = _param;
    if (param) {
      var fullname = simplify(Filename.concat(param[0], name));
      if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
        return fullname;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function find_in_path_uncap(path, name) {
  var uname = $$String.uncapitalize(name);
  var _param = path;
  while(true) {
    var param = _param;
    if (param) {
      var dir = param[0];
      var fullname = Filename.concat(dir, name);
      var ufullname = Filename.concat(dir, uname);
      if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
        return ufullname;
      } else if (Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n")) {
        return fullname;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      throw Caml_builtin_exceptions.not_found;
    }
  };
}

function remove_file() {
  try {
    return Caml_missing_polyfill.not_implemented("caml_sys_remove not implemented by bucklescript yet\n");
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.sys_error) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function expand_directory(alt, s) {
  if (s.length > 0 && Caml_string.get(s, 0) === /* "+" */43) {
    return Filename.concat(alt, $$String.sub(s, 1, s.length - 1 | 0));
  } else {
    return s;
  }
}

function create_hashtable(size, init) {
  var tbl = Hashtbl.create(/* None */0, size);
  List.iter((function (param) {
          return Hashtbl.add(tbl, param[0], param[1]);
        }), init);
  return tbl;
}

function copy_file(ic, oc) {
  var buff = Caml_string.caml_create_string(4096);
  var _param = /* () */0;
  while(true) {
    var n = Pervasives.input(ic, buff, 0, 4096);
    if (n === 0) {
      return /* () */0;
    } else {
      Pervasives.output(oc, buff, 0, n);
      _param = /* () */0;
      continue ;
      
    }
  };
}

function copy_file_chunk(ic, oc, len) {
  var buff = Caml_string.caml_create_string(4096);
  var _n = len;
  while(true) {
    var n = _n;
    if (n <= 0) {
      return /* () */0;
    } else {
      var r = Pervasives.input(ic, buff, 0, n < 4096 ? n : 4096);
      if (r === 0) {
        throw Caml_builtin_exceptions.end_of_file;
      } else {
        Pervasives.output(oc, buff, 0, r);
        _n = n - r | 0;
        continue ;
        
      }
    }
  };
}

function string_of_file(ic) {
  var b = Buffer.create(65536);
  var buff = Caml_string.caml_create_string(4096);
  var _param = /* () */0;
  while(true) {
    var n = Pervasives.input(ic, buff, 0, 4096);
    if (n === 0) {
      return Buffer.contents(b);
    } else {
      Buffer.add_subbytes(b, buff, 0, n);
      _param = /* () */0;
      continue ;
      
    }
  };
}

function log2(n) {
  if (n <= 1) {
    return 0;
  } else {
    return 1 + log2((n >> 1)) | 0;
  }
}

function align(n, a) {
  if (n >= 0) {
    return (n + a | 0) - 1 & (-a | 0);
  } else {
    return n & (-a | 0);
  }
}

function no_overflow_add(a, b) {
  return +((a ^ b | a ^ Pervasives.lnot(a + b | 0)) < 0);
}

function no_overflow_sub(a, b) {
  return +((a ^ Pervasives.lnot(b) | b ^ (a - b | 0)) < 0);
}

function no_overflow_lsl(a) {
  if ((Pervasives.min_int >> 1) <= a) {
    return +(a <= (Pervasives.max_int >> 1));
  } else {
    return /* false */0;
  }
}

function chop_extension_if_any(fname) {
  try {
    return Filename.chop_extension(fname);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return fname;
    } else {
      throw exn;
    }
  }
}

function chop_extensions(file) {
  var dirname = Curry._1(Filename.dirname, file);
  var basename = Curry._1(Filename.basename, file);
  try {
    var pos = $$String.index(basename, /* "." */46);
    var basename$1 = $$String.sub(basename, 0, pos);
    if (Curry._1(Filename.is_implicit, file) && dirname === Filename.current_dir_name) {
      return basename$1;
    } else {
      return Filename.concat(dirname, basename$1);
    }
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return file;
    } else {
      throw exn;
    }
  }
}

function search_substring(pat, str, start) {
  var _i = start;
  var _j = 0;
  while(true) {
    var j = _j;
    var i = _i;
    if (j >= pat.length) {
      return i;
    } else if ((i + j | 0) >= str.length) {
      throw Caml_builtin_exceptions.not_found;
    } else if (Caml_string.get(str, i + j | 0) === Caml_string.get(pat, j)) {
      _j = j + 1 | 0;
      continue ;
      
    } else {
      _j = 0;
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function replace_substring(before, after, str) {
  var search = function (_acc, _curr) {
    while(true) {
      var curr = _curr;
      var acc = _acc;
      var exit = 0;
      var next;
      try {
        next = search_substring(before, str, curr);
        exit = 1;
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          var suffix = $$String.sub(str, curr, str.length - curr | 0);
          return List.rev(/* :: */[
                      suffix,
                      acc
                    ]);
        } else {
          throw exn;
        }
      }
      if (exit === 1) {
        var prefix = $$String.sub(str, curr, next - curr | 0);
        _curr = next + before.length | 0;
        _acc = /* :: */[
          prefix,
          acc
        ];
        continue ;
        
      }
      
    };
  };
  return $$String.concat(after, search(/* [] */0, 0));
}

function rev_split_words(s) {
  var split1 = function (res, _i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return res;
      } else {
        var match = Caml_string.get(s, i);
        var switcher = match - 9 | 0;
        if (switcher > 4 || switcher < 0) {
          if (switcher !== 23) {
            return split2(res, i, i + 1 | 0);
          } else {
            _i = i + 1 | 0;
            continue ;
            
          }
        } else if (switcher === 3 || switcher === 2) {
          return split2(res, i, i + 1 | 0);
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      }
    };
  };
  var split2 = function (res, i, _j) {
    while(true) {
      var j = _j;
      if (j >= s.length) {
        return /* :: */[
                $$String.sub(s, i, j - i | 0),
                res
              ];
      } else {
        var match = Caml_string.get(s, j);
        var exit = 0;
        var switcher = match - 9 | 0;
        if (switcher > 4 || switcher < 0) {
          if (switcher !== 23) {
            _j = j + 1 | 0;
            continue ;
            
          } else {
            exit = 1;
          }
        } else if (switcher === 3 || switcher === 2) {
          _j = j + 1 | 0;
          continue ;
          
        } else {
          exit = 1;
        }
        if (exit === 1) {
          return split1(/* :: */[
                      $$String.sub(s, i, j - i | 0),
                      res
                    ], j + 1 | 0);
        }
        
      }
    };
  };
  return split1(/* [] */0, 0);
}

function get_ref(r) {
  var v = r[0];
  r[0] = /* [] */0;
  return v;
}

function fst3(param) {
  return param[0];
}

function snd3(param) {
  return param[1];
}

function thd3(param) {
  return param[2];
}

function fst4(param) {
  return param[0];
}

function snd4(param) {
  return param[1];
}

function thd4(param) {
  return param[2];
}

function for4(param) {
  return param[3];
}

function create(str_size) {
  var tbl_size = Caml_int32.div(str_size, Sys.max_string_length) + 1 | 0;
  var tbl = Caml_array.caml_make_vect(tbl_size, Bytes.empty);
  for(var i = 0 ,i_finish = tbl_size - 2 | 0; i <= i_finish; ++i){
    Caml_array.caml_array_set(tbl, i, Caml_string.caml_create_string(Sys.max_string_length));
  }
  Caml_array.caml_array_set(tbl, tbl_size - 1 | 0, Caml_string.caml_create_string(Caml_int32.mod_(str_size, Sys.max_string_length)));
  return tbl;
}

function length(tbl) {
  var tbl_size = tbl.length;
  return Caml_int32.imul(Sys.max_string_length, tbl_size - 1 | 0) + Caml_array.caml_array_get(tbl, tbl_size - 1 | 0).length | 0;
}

function get(tbl, ind) {
  return Caml_bytes.get(Caml_array.caml_array_get(tbl, Caml_int32.div(ind, Sys.max_string_length)), Caml_int32.mod_(ind, Sys.max_string_length));
}

function set(tbl, ind, c) {
  Caml_array.caml_array_get(tbl, Caml_int32.div(ind, Sys.max_string_length))[Caml_int32.mod_(ind, Sys.max_string_length)] = c;
  return /* () */0;
}

function blit(src, srcoff, dst, dstoff, len) {
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    set(dst, dstoff + i | 0, get(src, srcoff + i | 0));
  }
  return /* () */0;
}

function output(oc, tbl, pos, len) {
  for(var i = pos ,i_finish = (pos + len | 0) - 1 | 0; i <= i_finish; ++i){
    Pervasives.output_char(oc, get(tbl, i));
  }
  return /* () */0;
}

function unsafe_blit_to_bytes(src, srcoff, dst, dstoff, len) {
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    dst[dstoff + i | 0] = get(src, srcoff + i | 0);
  }
  return /* () */0;
}

function input_bytes(ic, len) {
  var tbl = create(len);
  $$Array.iter((function (str) {
          return Pervasives.really_input(ic, str, 0, str.length);
        }), tbl);
  return tbl;
}

var LongString = /* module */[
  /* create */create,
  /* length */length,
  /* get */get,
  /* set */set,
  /* blit */blit,
  /* output */output,
  /* unsafe_blit_to_bytes */unsafe_blit_to_bytes,
  /* input_bytes */input_bytes
];

function edit_distance(a, b, cutoff) {
  var la = a.length;
  var lb = b.length;
  var cutoff$1 = Caml_primitive.caml_int_min(la > lb ? la : lb, cutoff);
  if (Pervasives.abs(la - lb | 0) > cutoff$1) {
    return /* None */0;
  } else {
    var m = $$Array.make_matrix(la + 1 | 0, lb + 1 | 0, cutoff$1 + 1 | 0);
    Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), 0, 0);
    for(var i = 1; i <= la; ++i){
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, i), 0, i);
    }
    for(var j = 1; j <= lb; ++j){
      Caml_array.caml_array_set(Caml_array.caml_array_get(m, 0), j, j);
    }
    for(var i$1 = 1; i$1 <= la; ++i$1){
      for(var j$1 = Caml_primitive.caml_int_max(1, (i$1 - cutoff$1 | 0) - 1 | 0) ,j_finish = Caml_primitive.caml_int_min(lb, (i$1 + cutoff$1 | 0) + 1 | 0); j$1 <= j_finish; ++j$1){
        var cost = Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? 0 : 1;
        var best = Caml_primitive.caml_int_min(1 + Caml_primitive.caml_int_min(Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1), Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1), j$1 - 1 | 0)) | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 1 | 0), j$1 - 1 | 0) + cost | 0);
        var best$1 = i$1 > 1 && j$1 > 1 && Caml_string.get(a, i$1 - 1 | 0) === Caml_string.get(b, j$1 - 2 | 0) && Caml_string.get(a, i$1 - 2 | 0) === Caml_string.get(b, j$1 - 1 | 0) ? Caml_primitive.caml_int_min(best, Caml_array.caml_array_get(Caml_array.caml_array_get(m, i$1 - 2 | 0), j$1 - 2 | 0) + cost | 0) : best;
        Caml_array.caml_array_set(Caml_array.caml_array_get(m, i$1), j$1, best$1);
      }
    }
    var result = Caml_array.caml_array_get(Caml_array.caml_array_get(m, la), lb);
    if (result > cutoff$1) {
      return /* None */0;
    } else {
      return /* Some */[result];
    }
  }
}

function split(s, c) {
  var len = s.length;
  var _pos = 0;
  var _to_rev = /* [] */0;
  while(true) {
    var to_rev = _to_rev;
    var pos = _pos;
    if (pos === len) {
      return List.rev(/* :: */[
                  "",
                  to_rev
                ]);
    } else {
      var match;
      try {
        match = /* Some */[$$String.index_from(s, pos, c)];
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          match = /* None */0;
        } else {
          throw exn;
        }
      }
      if (match) {
        var pos2 = match[0];
        if (pos2 === pos) {
          _to_rev = /* :: */[
            "",
            to_rev
          ];
          _pos = pos + 1 | 0;
          continue ;
          
        } else {
          _to_rev = /* :: */[
            $$String.sub(s, pos, pos2 - pos | 0),
            to_rev
          ];
          _pos = pos2 + 1 | 0;
          continue ;
          
        }
      } else {
        return List.rev(/* :: */[
                    $$String.sub(s, pos, len - pos | 0),
                    to_rev
                  ]);
      }
    }
  };
}

function cut_at(s, c) {
  var pos = $$String.index(s, c);
  return /* tuple */[
          $$String.sub(s, 0, pos),
          $$String.sub(s, pos + 1 | 0, (s.length - pos | 0) - 1 | 0)
        ];
}

exports.fatal_error = fatal_error;
exports.Fatal_error = Fatal_error;
exports.try_finally = try_finally;
exports.map_end = map_end;
exports.map_left_right = map_left_right;
exports.for_all2 = for_all2;
exports.replicate_list = replicate_list;
exports.list_remove = list_remove;
exports.split_last = split_last;
exports.samelist = samelist;
exports.may = may;
exports.may_map = may_map;
exports.find_in_path = find_in_path;
exports.find_in_path_rel = find_in_path_rel;
exports.find_in_path_uncap = find_in_path_uncap;
exports.remove_file = remove_file;
exports.expand_directory = expand_directory;
exports.create_hashtable = create_hashtable;
exports.copy_file = copy_file;
exports.copy_file_chunk = copy_file_chunk;
exports.string_of_file = string_of_file;
exports.log2 = log2;
exports.align = align;
exports.no_overflow_add = no_overflow_add;
exports.no_overflow_sub = no_overflow_sub;
exports.no_overflow_lsl = no_overflow_lsl;
exports.chop_extension_if_any = chop_extension_if_any;
exports.chop_extensions = chop_extensions;
exports.search_substring = search_substring;
exports.replace_substring = replace_substring;
exports.rev_split_words = rev_split_words;
exports.get_ref = get_ref;
exports.fst3 = fst3;
exports.snd3 = snd3;
exports.thd3 = thd3;
exports.fst4 = fst4;
exports.snd4 = snd4;
exports.thd4 = thd4;
exports.for4 = for4;
exports.LongString = LongString;
exports.edit_distance = edit_distance;
exports.split = split;
exports.cut_at = cut_at;
/* Filename Not a pure module */
