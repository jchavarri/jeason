// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Filename = require("bs-platform/lib/js/filename.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

function from_lb_p(source, start, _end) {
  return /* record */[
          /* source */source,
          /* start : record */[
            /* line */start[/* pos_lnum */1],
            /* column */start[/* pos_cnum */3] - start[/* pos_bol */2] | 0,
            /* offset */start[/* pos_cnum */3]
          ],
          /* _end : record */[
            /* line */_end[/* pos_lnum */1],
            /* column */Caml_primitive.caml_int_max(0, _end[/* pos_cnum */3] - _end[/* pos_bol */2] | 0),
            /* offset */_end[/* pos_cnum */3]
          ]
        ];
}

function from_lb(source, lb) {
  var start = Lexing.lexeme_start_p(lb);
  var _end = Lexing.lexeme_end_p(lb);
  return from_lb_p(source, start, _end);
}

function from_curr_lb(source, lb) {
  var curr = lb[/* lex_curr_p */11];
  return from_lb_p(source, curr, curr);
}

function btwn(loc1, loc2) {
  return /* record */[
          /* source */loc1[/* source */0],
          /* start */loc1[/* start */1],
          /* _end */loc2[/* _end */2]
        ];
}

function btwn_exclusive(loc1, loc2) {
  return /* record */[
          /* source */loc1[/* source */0],
          /* start */loc1[/* _end */2],
          /* _end */loc2[/* start */1]
        ];
}

function char_before(loc) {
  var match = loc[/* start */1];
  var offset = match[/* offset */2];
  var column = match[/* column */1];
  var match$1 = column > 0 ? /* tuple */[
      column - 1 | 0,
      offset - 1 | 0
    ] : /* tuple */[
      column,
      offset
    ];
  var start_000 = /* line */match[/* line */0];
  var start_001 = /* column */match$1[0];
  var start_002 = /* offset */match$1[1];
  var start = /* record */[
    start_000,
    start_001,
    start_002
  ];
  var _end = loc[/* start */1];
  return /* record */[
          /* source */loc[/* source */0],
          /* start */start,
          /* _end */_end
        ];
}

function contains(loc1, loc2) {
  if (Caml_obj.caml_equal(loc1[/* source */0], loc2[/* source */0]) && loc1[/* start */1][/* offset */2] <= loc2[/* start */1][/* offset */2]) {
    return loc1[/* _end */2][/* offset */2] >= loc2[/* _end */2][/* offset */2];
  } else {
    return false;
  }
}

function string_of_filename(param) {
  if (typeof param === "number") {
    return "(global)";
  } else {
    return param[0];
  }
}

function order_of_filename(param) {
  if (typeof param === "number") {
    return 1;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return 2;
      case 1 : 
      case 2 : 
          return 3;
      case 3 : 
          return 4;
      
    }
  }
}

function source_cmp(a, b) {
  if (a) {
    if (b) {
      var fn2 = b[0];
      var fn1 = a[0];
      var k = order_of_filename(fn1) - order_of_filename(fn2) | 0;
      if (k !== 0) {
        return k;
      } else {
        return $$String.compare(string_of_filename(fn1), string_of_filename(fn2));
      }
    } else {
      return -1;
    }
  } else if (b) {
    return 1;
  } else {
    return 0;
  }
}

function pos_cmp(a, b) {
  return Caml_obj.caml_compare(/* tuple */[
              a[/* line */0],
              a[/* column */1]
            ], /* tuple */[
              b[/* line */0],
              b[/* column */1]
            ]);
}

function compare(loc1, loc2) {
  var k = source_cmp(loc1[/* source */0], loc2[/* source */0]);
  if (k === 0) {
    var k$1 = pos_cmp(loc1[/* start */1], loc2[/* start */1]);
    if (k$1 === 0) {
      return pos_cmp(loc1[/* _end */2], loc2[/* _end */2]);
    } else {
      return k$1;
    }
  } else {
    return k;
  }
}

function to_string($staropt$star, loc) {
  var include_source = $staropt$star ? $staropt$star[0] : false;
  var source;
  if (include_source) {
    var match = loc[/* source */0];
    source = Curry._1(Printf.sprintf(/* Format */[
              /* Caml_string */Block.__(3, [
                  /* No_padding */0,
                  /* String_literal */Block.__(11, [
                      ": ",
                      /* End_of_format */0
                    ])
                ]),
              "%S: "
            ]), match ? string_of_filename(match[0]) : "<NONE>");
  } else {
    source = "";
  }
  var pos = Curry._4(Printf.sprintf(/* Format */[
            /* Char_literal */Block.__(12, [
                /* "(" */40,
                /* Int */Block.__(4, [
                    /* Int_d */0,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* String_literal */Block.__(11, [
                        ", ",
                        /* Int */Block.__(4, [
                            /* Int_d */0,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* String_literal */Block.__(11, [
                                ") to (",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */Block.__(11, [
                                        ", ",
                                        /* Int */Block.__(4, [
                                            /* Int_d */0,
                                            /* No_padding */0,
                                            /* No_precision */0,
                                            /* Char_literal */Block.__(12, [
                                                /* ")" */41,
                                                /* End_of_format */0
                                              ])
                                          ])
                                      ])
                                  ])
                              ])
                          ])
                      ])
                  ])
              ]),
            "(%d, %d) to (%d, %d)"
          ]), loc[/* start */1][/* line */0], loc[/* start */1][/* column */1], loc[/* _end */2][/* line */0], loc[/* _end */2][/* column */1]);
  return source + pos;
}

function source(loc) {
  return loc[/* source */0];
}

function source_is_lib_file(param) {
  if (typeof param === "number" || !param.tag) {
    return true;
  } else {
    return false;
  }
}

function filename_map(f, param) {
  if (typeof param === "number") {
    return /* Builtins */0;
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return /* LibFile */Block.__(0, [Curry._1(f, param[0])]);
      case 1 : 
          return /* SourceFile */Block.__(1, [Curry._1(f, param[0])]);
      case 2 : 
          return /* JsonFile */Block.__(2, [Curry._1(f, param[0])]);
      case 3 : 
          return /* ResourceFile */Block.__(3, [Curry._1(f, param[0])]);
      
    }
  }
}

function check_suffix(filename, suffix) {
  var f = function (fn) {
    return Curry._2(Filename.check_suffix, fn, suffix);
  };
  var param = filename;
  if (typeof param === "number") {
    return false;
  } else {
    return Curry._1(f, param[0]);
  }
}

function chop_suffix(filename, suffix) {
  return filename_map((function (fn) {
                return Filename.chop_suffix(fn, suffix);
              }), filename);
}

function with_suffix(filename, suffix) {
  return filename_map((function (fn) {
                return fn + suffix;
              }), filename);
}

var compare$1 = Caml_obj.caml_compare;

var FilenameKey = /* module */[
  /* to_string */string_of_filename,
  /* compare */compare$1
];

var none = /* record */[
  /* source : None */0,
  /* start : record */[
    /* line */0,
    /* column */0,
    /* offset */0
  ],
  /* _end : record */[
    /* line */0,
    /* column */0,
    /* offset */0
  ]
];

exports.none = none;
exports.from_lb = from_lb;
exports.from_curr_lb = from_curr_lb;
exports.btwn = btwn;
exports.btwn_exclusive = btwn_exclusive;
exports.char_before = char_before;
exports.contains = contains;
exports.filename_map = filename_map;
exports.string_of_filename = string_of_filename;
exports.compare = compare;
exports.to_string = to_string;
exports.source = source;
exports.source_is_lib_file = source_is_lib_file;
exports.check_suffix = check_suffix;
exports.chop_suffix = chop_suffix;
exports.with_suffix = with_suffix;
exports.FilenameKey = FilenameKey;
/* Filename Not a pure module */
