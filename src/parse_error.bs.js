// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var $$Error = Caml_exceptions.create("Parse_error-Jeason.Error");

function error(loc, e) {
  throw [
        $$Error,
        /* :: */[
          /* tuple */[
            loc,
            e
          ],
          /* [] */0
        ]
      ];
}

function error$1(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return "Unexpected number";
      case 1 : 
          return "Unexpected string";
      case 2 : 
          return "Unexpected identifier";
      case 3 : 
          return "Unexpected reserved word";
      case 4 : 
          return "Unexpected end of input";
      case 5 : 
          return "Unexpected variance sigil";
      case 6 : 
          return "Type aliases are not allowed in untyped mode";
      case 7 : 
          return "Type annotations are not allowed in untyped mode";
      case 8 : 
          return "Type declarations are not allowed in untyped mode";
      case 9 : 
          return "Type imports are not allowed in untyped mode";
      case 10 : 
          return "Type exports are not allowed in untyped mode";
      case 11 : 
          return "Interfaces are not allowed in untyped mode";
      case 12 : 
          return "Illegal newline after throw";
      case 13 : 
          return "Invalid regular expression";
      case 14 : 
          return "Invalid regular expression: missing /";
      case 15 : 
          return "Invalid left-hand side in assignment";
      case 16 : 
          return "Invalid left-hand side in exponentiation expression";
      case 17 : 
          return "Invalid left-hand side in for-in";
      case 18 : 
          return "Invalid left-hand side in for-of";
      case 19 : 
          return "Expected an object pattern, array pattern, or an identifier but found an expression instead";
      case 20 : 
          return "More than one default clause in switch statement";
      case 21 : 
          return "Missing catch or finally after try";
      case 22 : 
          return "Illegal continue statement";
      case 23 : 
          return "Illegal break statement";
      case 24 : 
          return "Illegal return statement";
      case 25 : 
          return "Illegal yield expression";
      case 26 : 
          return "Strict mode code may not include a with statement";
      case 27 : 
          return "Catch variable may not be eval or arguments in strict mode";
      case 28 : 
          return "Variable name may not be eval or arguments in strict mode";
      case 29 : 
          return "Parameter name eval or arguments is not allowed in strict mode";
      case 30 : 
          return "Strict mode function may not have duplicate parameter names";
      case 31 : 
          return "Function name may not be eval or arguments in strict mode";
      case 32 : 
          return "Octal literals are not allowed in strict mode.";
      case 33 : 
          return "Delete of an unqualified identifier in strict mode.";
      case 34 : 
          return "Duplicate data property in object literal not allowed in strict mode";
      case 35 : 
          return "Object literal may not have data and accessor property with the same name";
      case 36 : 
          return "Object literal may not have multiple get/set accessors with the same name";
      case 37 : 
          return "Assignment to eval or arguments is not allowed in strict mode";
      case 38 : 
          return "Postfix increment/decrement may not have eval or arguments operand in strict mode";
      case 39 : 
          return "Prefix increment/decrement may not have eval or arguments operand in strict mode";
      case 40 : 
          return "Use of future reserved word in strict mode";
      case 41 : 
          return "JSX attributes must only be assigned a non-empty expression";
      case 42 : 
          return "JSX value should be either an expression or a quoted JSX text";
      case 43 : 
          return "Const must be initialized";
      case 44 : 
          return "Destructuring assignment must be initialized";
      case 45 : 
          return "Illegal newline before arrow";
      case 46 : 
          return "In strict mode code, functions can only be declared at top level or immediately within another function.";
      case 47 : 
          return "Unexpected token <. Remember, adjacent JSX elements must be wrapped in an enclosing parent tag";
      case 48 : 
          return "Rest parameter must be final parameter of an argument list";
      case 49 : 
          return "async is an implementation detail and isn't necessary for your declare function statement. It is sufficient for your declare function to just have a Promise return type.";
      case 50 : 
          return "`declare export let` is not supported. Use `declare export var` instead.";
      case 51 : 
          return "`declare export const` is not supported. Use `declare export var` instead.";
      case 52 : 
          return "`declare export type` is not supported. Use `export type` instead.";
      case 53 : 
          return "`declare export interface` is not supported. Use `export interface` instead.";
      case 54 : 
          return "`export * as` is an early-stage proposal and is not enabled by default. To enable support in the parser, use the `esproposal_export_star_as` option";
      case 55 : 
          return "When exporting a class as a named export, you must specify a class name. Did you mean `export default class ...`?";
      case 56 : 
          return "When exporting a function as a named export, you must specify a function name. Did you mean `export default function ...`?";
      case 57 : 
          return "Found a decorator in an unsupported position.";
      case 58 : 
          return "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.";
      case 59 : 
          return "The Windows version of OCaml has a bug in how it parses hexidecimal numbers. It is fixed in OCaml 4.03.0. Until we can switch to 4.03.0, please avoid either hexidecimal notation or Windows.";
      case 60 : 
          return "Duplicate `declare module.exports` statement!";
      case 61 : 
          return "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module xor they are a CommonJS module.";
      case 62 : 
          return "Getter should have zero parameters";
      case 63 : 
          return "Setter should have exactly one parameter";
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return "Unexpected parser state: " + param[0];
      case 1 : 
          return "Unexpected token " + param[0];
      case 2 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "Unexpected token `",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "`. Did you mean `",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              "`?",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "Unexpected token `%s`. Did you mean `%s`?"
                        ]), param[0], param[1]);
      case 3 : 
          return "Invalid flags supplied to RegExp constructor '" + (param[0] + "'");
      case 4 : 
          return "Undefined label '" + (param[0] + "'");
      case 5 : 
          return param[0] + (" '" + (param[1] + "' has already been declared"));
      case 6 : 
          return "Expected corresponding JSX closing tag for " + param[0];
      case 7 : 
          return Curry._1(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "Duplicate export for `",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "`" */96,
                                      /* End_of_format */0
                                    ])
                                ])
                            ]),
                          "Duplicate export for `%s`"
                        ]), param[0]);
      
    }
  }
}

var PP = /* module */[/* error */error$1];

exports.$$Error = $$Error;
exports.error = error;
exports.PP = PP;
/* No side effect */
