// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var $$Set = require("bs-platform/lib/js/set.js");
var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Buffer = require("bs-platform/lib/js/buffer.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Loc$Jeason = require("./loc.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_module = require("bs-platform/lib/js/caml_module.js");
var Lexer_flow$Jeason = require("./lexer_flow.bs.js");
var Parser_env$Jeason = require("./parser_env.bs.js");
var Parse_error$Jeason = require("./parse_error.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var SSet = $$Set.Make([$$String.compare]);

var SMap = $$Map.Make([$$String.compare]);

function compare(param, param$1) {
  var loc = Loc$Jeason.compare(param[0], param$1[0]);
  if (loc === 0) {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  } else {
    return loc;
  }
}

var ErrorSet = $$Set.Make(/* module */[/* compare */compare]);

function filter_duplicate_errors(errs) {
  var errs$1 = List.rev(errs);
  var match = List.fold_left((function (param, err) {
          var deduped = param[1];
          var set = param[0];
          if (Curry._2(ErrorSet[/* mem */2], err, set)) {
            return /* tuple */[
                    set,
                    deduped
                  ];
          } else {
            return /* tuple */[
                    Curry._2(ErrorSet[/* add */3], err, set),
                    /* :: */[
                      err,
                      deduped
                    ]
                  ];
          }
        }), /* tuple */[
        ErrorSet[/* empty */0],
        /* [] */0
      ], errs$1);
  return List.rev(match[1]);
}

function with_loc(fn, env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var result = Curry._1(fn, env);
  var match = Parser_env$Jeason.last_loc(env);
  var end_loc = match ? match[0] : (Parser_env$Jeason.error(env, /* Assertion */Block.__(0, ["did not consume any tokens"])), Parser_env$Jeason.Peek[/* loc */2](/* None */0, env));
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          result
        ];
}

function string_starts_with($$long, $$short) {
  try {
    var $$long$1 = $$String.sub($$long, 0, $$short.length);
    return +($$long$1 === $$short);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

var Parse = Caml_module.init_mod([
      "/Users/javi/Development/github/jeason/src/parser_flow.ml",
      84,
      6
    ], [[
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]]);

function union(env) {
  Parser_env$Jeason.Expect[/* maybe */1](env, /* T_BIT_OR */83);
  var left = intersection(env);
  return Curry._2(union_with, env, left);
}

function variance(env) {
  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    if (match !== 97) {
      if (match !== 98) {
        return /* None */0;
      } else {
        Parser_env$Jeason.Eat[/* token */0](env);
        return /* Some */[/* tuple */[
                  loc,
                  /* Minus */1
                ]];
      }
    } else {
      Parser_env$Jeason.Eat[/* token */0](env);
      return /* Some */[/* tuple */[
                loc,
                /* Plus */0
              ]];
    }
  } else {
    return /* None */0;
  }
}

function prefix(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number" && match === 79) {
    var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    Parser_env$Jeason.Expect[/* token */0](env, /* T_PLING */79);
    var t = prefix(env);
    return /* tuple */[
            Loc$Jeason.btwn(loc, t[0]),
            /* Nullable */Block.__(0, [t])
          ];
  } else {
    var env$1 = env;
    var t$1 = primary(env$1);
    return postfix_with(env$1, t$1);
  }
}

function anon_function_without_parens_with(env, param) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number" && !(match !== 12 || Parser_env$Jeason.no_anon_function_type(env))) {
    var param$1 = anonymous_function_param(env, param);
    var match_000 = param$1[0];
    var match_002 = /* tuple */[
      /* :: */[
        param$1,
        /* [] */0
      ],
      /* None */0
    ];
    return function_with_params(env, match_000, /* None */0, match_002);
  } else {
    return param;
  }
}

function primitive(param) {
  if (typeof param === "number") {
    if (param !== 29) {
      if (param >= 110) {
        switch (param - 110 | 0) {
          case 0 : 
              return /* Some */[/* Any */0];
          case 1 : 
              return /* Some */[/* Mixed */1];
          case 2 : 
              return /* Some */[/* Empty */2];
          case 3 : 
              return /* Some */[/* Boolean */7];
          case 4 : 
              return /* Some */[/* Number */5];
          case 5 : 
              return /* Some */[/* String */6];
          case 6 : 
              return /* Some */[/* Void */3];
          
        }
      } else {
        return /* None */0;
      }
    } else {
      return /* Some */[/* Null */4];
    }
  } else {
    return /* None */0;
  }
}

function primary(env) {
  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof token === "number") {
    switch (token) {
      case 0 : 
          var match = generic(env);
          return /* tuple */[
                  match[0],
                  /* Generic */Block.__(4, [match[1]])
                ];
      case 1 : 
      case 3 : 
          exit = 2;
          break;
      case 5 : 
          var env$1 = env;
          var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
          var match$1 = param_list_or_type(env$1);
          if (match$1.tag) {
            return match$1[0];
          } else {
            return function_with_params(env$1, start_loc, /* None */0, match$1[0]);
          }
      case 7 : 
          var env$2 = env;
          var start_loc$1 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2);
          Parser_env$Jeason.Expect[/* token */0](env$2, /* T_LBRACKET */7);
          var tl = types(env$2, /* [] */0);
          var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2);
          Parser_env$Jeason.Expect[/* token */0](env$2, /* T_RBRACKET */8);
          return /* tuple */[
                  Loc$Jeason.btwn(start_loc$1, end_loc),
                  /* Tuple */Block.__(8, [tl])
                ];
      case 30 : 
      case 31 : 
          exit = 3;
          break;
      case 46 : 
          var start_loc$2 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
          Parser_env$Jeason.Expect[/* token */0](env, /* T_TYPEOF */46);
          var t = primary(env);
          return /* tuple */[
                  Loc$Jeason.btwn(start_loc$2, t[0]),
                  /* Typeof */Block.__(7, [t])
                ];
      case 92 : 
          var env$3 = env;
          var start_loc$3 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$3);
          var typeParameters = Curry._2(type_parameter_declaration, /* false */0, env$3);
          var params = function_param_list(env$3);
          return function_with_params(env$3, start_loc$3, typeParameters, params);
      case 100 : 
          Parser_env$Jeason.Expect[/* token */0](env, /* T_MULT */100);
          return /* tuple */[
                  loc,
                  /* Exists */8
                ];
      default:
        exit = 1;
    }
  } else {
    switch (token.tag | 0) {
      case 1 : 
          var match$2 = token[0];
          var octal = match$2[3];
          var raw = match$2[2];
          var value = match$2[1];
          var loc$1 = match$2[0];
          if (octal) {
            Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
          }
          Parser_env$Jeason.Expect[/* token */0](env, /* T_STRING */Block.__(1, [/* tuple */[
                    loc$1,
                    value,
                    raw,
                    octal
                  ]]));
          return /* tuple */[
                  loc$1,
                  /* StringLiteral */Block.__(9, [/* record */[
                        /* value */value,
                        /* raw */raw
                      ]])
                ];
      case 5 : 
          var value$1 = token[1];
          var number_type = token[0];
          var raw$1 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
          Parser_env$Jeason.Expect[/* token */0](env, /* T_NUMBER_SINGLETON_TYPE */Block.__(5, [
                  number_type,
                  value$1
                ]));
          if (number_type === /* LEGACY_OCTAL */1) {
            Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
          }
          return /* tuple */[
                  loc,
                  /* NumberLiteral */Block.__(10, [/* record */[
                        /* value */value$1,
                        /* raw */raw$1
                      ]])
                ];
      default:
        exit = 1;
    }
  }
  switch (exit) {
    case 1 : 
        var match$3 = primitive(token);
        if (match$3) {
          Parser_env$Jeason.Expect[/* token */0](env, token);
          return /* tuple */[
                  loc,
                  match$3[0]
                ];
        } else {
          Parser_env$Jeason.error_unexpected(env);
          return /* tuple */[
                  loc,
                  /* Any */0
                ];
        }
    case 2 : 
        var match$4 = Curry._3(_object, /* None */0, /* Some */[/* true */1], env);
        return /* tuple */[
                match$4[0],
                /* Object */Block.__(2, [match$4[1]])
              ];
    case 3 : 
        var raw$2 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
        Parser_env$Jeason.Expect[/* token */0](env, token);
        var value$2 = +(token === /* T_TRUE */31);
        return /* tuple */[
                loc,
                /* BooleanLiteral */Block.__(11, [/* record */[
                      /* value */value$2,
                      /* raw */raw$2
                    ]])
              ];
    
  }
}

function generic(env) {
  return Curry._2(raw_generic_with_identifier, env, Curry._2(Parse[/* identifier */12], /* None */0, env));
}

function postfix_with(env, _t) {
  while(true) {
    var t = _t;
    if (!Parser_env$Jeason.Peek[/* is_line_terminator */5](env) && Parser_env$Jeason.Expect[/* maybe */1](env, /* T_LBRACKET */7)) {
      var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
      var loc = Loc$Jeason.btwn(t[0], end_loc);
      var t_001 = /* Array */Block.__(3, [t]);
      var t$1 = /* tuple */[
        loc,
        t_001
      ];
      _t = t$1;
      continue ;
      
    } else {
      return t;
    }
  };
}

function function_param_list(env) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LPAREN */5);
  var ret = Curry._2(function_param_list_without_parens, env, /* [] */0);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RPAREN */6);
  return ret;
}

function function_with_params(env, start_loc, typeParameters, params) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_ARROW */12);
  var returnType = union(env);
  var end_loc = returnType[0];
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* Function */Block.__(1, [/* record */[
                /* params */params,
                /* returnType */returnType,
                /* typeParameters */typeParameters
              ]])
        ];
}

function anonymous_function_param(_, typeAnnotation) {
  return /* tuple */[
          typeAnnotation[0],
          /* record */[
            /* name : None */0,
            /* typeAnnotation */typeAnnotation,
            /* optional : false */0
          ]
        ];
}

function anon_function_without_parens(env) {
  var param = prefix(env);
  return anon_function_without_parens_with(env, param);
}

function generic_type_with_identifier(env, id) {
  var match = Curry._2(raw_generic_with_identifier, env, id);
  return /* tuple */[
          match[0],
          /* Generic */Block.__(4, [match[1]])
        ];
}

function function_param_with_id(env, name) {
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeAnnotation */7);
  }
  var optional = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_PLING */79);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
  var typeAnnotation = union(env);
  return /* tuple */[
          Loc$Jeason.btwn(name[0], typeAnnotation[0]),
          /* record */[
            /* name : Some */[name],
            /* typeAnnotation */typeAnnotation,
            /* optional */optional
          ]
        ];
}

function intersection(env) {
  Parser_env$Jeason.Expect[/* maybe */1](env, /* T_BIT_AND */85);
  var left = anon_function_without_parens(env);
  return Curry._2(intersection_with, env, left);
}

function function_param_or_generic_type(env) {
  var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number" && (match === 80 || match === 79)) {
    var param = function_param_with_id(env, id);
    Parser_env$Jeason.Expect[/* maybe */1](env, /* T_COMMA */10);
    return /* ParamList */Block.__(0, [Curry._2(function_param_list_without_parens, env, /* :: */[
                    param,
                    /* [] */0
                  ])]);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return /* Type */Block.__(1, [Curry._2(union_with, env, Curry._2(intersection_with, env, anon_function_without_parens_with(env, postfix_with(env, generic_type_with_identifier(env, id)))))]);
  }
  
}

function param_list_or_type(env) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LPAREN */5);
  var env$1 = Parser_env$Jeason.with_no_anon_function_type(/* false */0, env);
  var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
  var ret;
  var exit = 0;
  if (typeof token === "number") {
    if (token >= 13) {
      if (token !== 108) {
        if (token >= 14) {
          exit = 1;
        } else {
          ret = /* ParamList */Block.__(0, [Curry._2(function_param_list_without_parens, env$1, /* [] */0)]);
        }
      } else {
        ret = /* ParamList */Block.__(0, [Curry._2(function_param_list_without_parens, env$1, /* [] */0)]);
      }
    } else if (token !== 6) {
      if (token !== 0) {
        exit = 1;
      } else {
        ret = function_param_or_generic_type(env$1);
      }
    } else {
      ret = /* ParamList */Block.__(0, [/* tuple */[
            /* [] */0,
            /* None */0
          ]]);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match = primitive(token);
    if (match) {
      var match$1 = Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env$1);
      ret = typeof match$1 === "number" ? (
          match$1 === 80 || match$1 === 79 ? /* ParamList */Block.__(0, [Curry._2(function_param_list_without_parens, env$1, /* [] */0)]) : /* Type */Block.__(1, [union(env$1)])
        ) : /* Type */Block.__(1, [union(env$1)]);
    } else {
      ret = /* Type */Block.__(1, [union(env$1)]);
    }
  }
  var ret$1;
  if (ret.tag) {
    var t = ret[0];
    if (Parser_env$Jeason.no_anon_function_type(env)) {
      ret$1 = ret;
    } else {
      var match$2 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
      if (typeof match$2 === "number") {
        if (match$2 !== 6) {
          if (match$2 !== 10) {
            ret$1 = ret;
          } else {
            Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
            var param = anonymous_function_param(env, t);
            ret$1 = /* ParamList */Block.__(0, [Curry._2(function_param_list_without_parens, env, /* :: */[
                      param,
                      /* [] */0
                    ])]);
          }
        } else if (Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) === /* T_ARROW */12) {
          var param$1 = anonymous_function_param(env, t);
          ret$1 = /* ParamList */Block.__(0, [Curry._2(function_param_list_without_parens, env, /* :: */[
                    param$1,
                    /* [] */0
                  ])]);
        } else {
          ret$1 = /* Type */Block.__(1, [t]);
        }
      } else {
        ret$1 = ret;
      }
    }
  } else {
    ret$1 = ret;
  }
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RPAREN */6);
  return ret$1;
}

function rev_nonempty_acc(acc) {
  var end_loc;
  if (acc) {
    end_loc = acc[0][0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parser_flow.ml",
            130,
            13
          ]
        ];
  }
  var acc$1 = List.rev(acc);
  var start_loc;
  if (acc$1) {
    start_loc = acc$1[0][0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parser_flow.ml",
            134,
            13
          ]
        ];
  }
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          acc$1
        ];
}

function methodish(env, start_loc) {
  var typeParameters = Curry._2(type_parameter_declaration, /* false */0, env);
  var params = function_param_list(env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
  var returnType = union(env);
  var loc = Loc$Jeason.btwn(start_loc, returnType[0]);
  return /* tuple */[
          loc,
          /* record */[
            /* params */params,
            /* returnType */returnType,
            /* typeParameters */typeParameters
          ]
        ];
}

function method_property(env, start_loc, $$static, key) {
  var value = methodish(env, start_loc);
  var value_000 = value[0];
  var value_001 = /* Function */Block.__(1, [value[1]]);
  var value$1 = /* tuple */[
    value_000,
    value_001
  ];
  return /* tuple */[
          value_000,
          /* record */[
            /* key */key,
            /* value */value$1,
            /* optional : false */0,
            /* static */$$static,
            /* _method : true */1,
            /* variance : None */0
          ]
        ];
}

function call_property(env, start_loc, $$static) {
  var value = methodish(env, Parser_env$Jeason.Peek[/* loc */2](/* None */0, env));
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, value[0]),
          /* record */[
            /* value */value,
            /* static */$$static
          ]
        ];
}

function property(env, start_loc, $$static, variance, key) {
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeAnnotation */7);
  }
  var optional = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_PLING */79);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
  var value = union(env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, value[0]),
          /* record */[
            /* key */key,
            /* value */value,
            /* optional */optional,
            /* static */$$static,
            /* _method : false */0,
            /* variance */variance
          ]
        ];
}

function indexer_property(env, start_loc, $$static, variance) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LBRACKET */7);
  var id;
  if (Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) === /* T_COLON */80) {
    var match = Curry._1(Parse[/* identifier_or_reserved_keyword */13], env);
    Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
    id = /* Some */[match[0]];
  } else {
    id = /* None */0;
  }
  var key = union(env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
  var value = union(env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, value[0]),
          /* record */[
            /* id */id,
            /* key */key,
            /* value */value,
            /* static */$$static,
            /* variance */variance
          ]
        ];
}

function semicolon(exact, env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number" && match < 11) {
    switch (match) {
      case 2 : 
          if (exact) {
            return Parser_env$Jeason.error_unexpected(env);
          } else {
            return /* () */0;
          }
      case 4 : 
          if (exact) {
            return /* () */0;
          } else {
            return Parser_env$Jeason.error_unexpected(env);
          }
      case 0 : 
      case 1 : 
      case 3 : 
      case 5 : 
      case 6 : 
      case 7 : 
      case 8 : 
          return Parser_env$Jeason.error_unexpected(env);
      case 9 : 
      case 10 : 
          return Parser_env$Jeason.Eat[/* token */0](env);
      
    }
  } else {
    return Parser_env$Jeason.error_unexpected(env);
  }
}

function error_unsupported_variance(env, param) {
  if (param) {
    return Parser_env$Jeason.error_at(env, /* tuple */[
                param[0][0],
                /* UnexpectedVariance */5
              ]);
  } else {
    return /* () */0;
  }
}

function properties(allow_static, exact, env, _param) {
  while(true) {
    var param = _param;
    var callProperties = param[2];
    var indexers = param[1];
    var acc = param[0];
    var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    var $$static = allow_static && Parser_env$Jeason.Expect[/* maybe */1](env, /* T_STATIC */42);
    var variance$1 = variance(env);
    var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof token === "number") {
      if (token !== 92) {
        if (token !== 108) {
          if (token >= 8) {
            exit = 1;
          } else {
            switch (token) {
              case 2 : 
                  if (exact) {
                    exit = 1;
                  } else {
                    return /* tuple */[
                            List.rev(acc),
                            List.rev(indexers),
                            List.rev(callProperties)
                          ];
                  }
                  break;
              case 4 : 
                  if (exact) {
                    return /* tuple */[
                            List.rev(acc),
                            List.rev(indexers),
                            List.rev(callProperties)
                          ];
                  } else {
                    exit = 1;
                  }
                  break;
              case 5 : 
                  exit = 2;
                  break;
              case 0 : 
              case 1 : 
              case 3 : 
              case 6 : 
                  exit = 1;
                  break;
              case 7 : 
                  var indexer = indexer_property(env, start_loc, $$static, variance$1);
                  semicolon(exact, env);
                  _param = /* tuple */[
                    acc,
                    /* :: */[
                      indexer,
                      indexers
                    ],
                    callProperties
                  ];
                  continue ;
                  
            }
          }
        } else {
          return /* tuple */[
                  List.rev(acc),
                  List.rev(indexers),
                  List.rev(callProperties)
                ];
        }
      } else {
        exit = 2;
      }
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 : 
          var match;
          var exit$1 = 0;
          if ($$static !== 0 && !(variance$1 || !(typeof token === "number" && token === 80))) {
            Parser_env$Jeason.strict_error_at(env, /* tuple */[
                  start_loc,
                  /* StrictReservedWord */40
                ]);
            var static_key_001 = /* Identifier */Block.__(1, [/* tuple */[
                  start_loc,
                  "static"
                ]]);
            var static_key = /* tuple */[
              start_loc,
              static_key_001
            ];
            match = /* tuple */[
              /* false */0,
              static_key
            ];
          } else {
            exit$1 = 3;
          }
          if (exit$1 === 3) {
            Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* NORMAL */0);
            var key = Curry._1(Parse[/* object_key */20], env);
            Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
            match = /* tuple */[
              $$static,
              key
            ];
          }
          var key$1 = match[1][1];
          var $$static$1 = match[0];
          var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
          var property$1;
          var exit$2 = 0;
          if (typeof match$1 === "number" && !(match$1 !== 5 && match$1 !== 92)) {
            exit$2 = 3;
          } else {
            property$1 = property(env, start_loc, $$static$1, variance$1, key$1);
          }
          if (exit$2 === 3) {
            error_unsupported_variance(env, variance$1);
            property$1 = method_property(env, start_loc, $$static$1, key$1);
          }
          semicolon(exact, env);
          _param = /* tuple */[
            /* :: */[
              property$1,
              acc
            ],
            indexers,
            callProperties
          ];
          continue ;
          case 2 : 
          error_unsupported_variance(env, variance$1);
          var call_prop = call_property(env, start_loc, $$static);
          semicolon(exact, env);
          _param = /* tuple */[
            acc,
            indexers,
            /* :: */[
              call_prop,
              callProperties
            ]
          ];
          continue ;
          
    }
  };
}

function _object($staropt$star, $staropt$star$1, env) {
  var allow_static = $staropt$star ? $staropt$star[0] : /* false */0;
  var allow_exact = $staropt$star$1 ? $staropt$star$1[0] : /* false */0;
  var exact = allow_exact && +(Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LCURLYBAR */3);
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, exact ? /* T_LCURLYBAR */3 : /* T_LCURLY */1);
  var match = properties(allow_static, exact, env, /* tuple */[
        /* [] */0,
        /* [] */0,
        /* [] */0
      ]);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, exact ? /* T_RCURLYBAR */4 : /* T_RCURLY */2);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[
            /* exact */exact,
            /* properties */match[0],
            /* indexers */match[1],
            /* callProperties */match[2]
          ]
        ];
}

function types(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && !(match !== 8 && match !== 108)) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var acc_000 = union(env);
      var acc$1 = /* :: */[
        acc_000,
        acc
      ];
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RBRACKET */8) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      _acc = acc$1;
      continue ;
      
    }
    
  };
}

function params(env, allow_default, _require_default, _acc) {
  while(true) {
    var acc = _acc;
    var require_default = _require_default;
    var variance$1 = variance(env);
    var match = Curry._3(Parse[/* identifier_with_type */14], env, /* None */0, /* StrictParamName */29);
    var match$1 = match[1];
    var loc = match[0];
    var match$2 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var match$3;
    if (allow_default !== 0) {
      var exit = 0;
      if (typeof match$2 === "number" && match$2 === 78) {
        Parser_env$Jeason.Eat[/* token */0](env);
        match$3 = /* tuple */[
          /* Some */[union(env)],
          /* true */1
        ];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        if (require_default) {
          Parser_env$Jeason.error_at(env, /* tuple */[
                loc,
                /* MissingTypeParamDefault */58
              ]);
        }
        match$3 = /* tuple */[
          /* None */0,
          require_default
        ];
      }
      
    } else {
      match$3 = /* tuple */[
        /* None */0,
        /* false */0
      ];
    }
    var param_001 = /* record */[
      /* name */match$1[/* name */0][1],
      /* bound */match$1[/* typeAnnotation */1],
      /* variance */variance$1,
      /* default */match$3[0]
    ];
    var param = /* tuple */[
      loc,
      param_001
    ];
    var acc$1 = /* :: */[
      param,
      acc
    ];
    var match$4 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit$1 = 0;
    if (typeof match$4 === "number" && !(match$4 !== 93 && match$4 !== 108)) {
      return List.rev(acc$1);
    } else {
      exit$1 = 1;
    }
    if (exit$1 === 1) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_GREATER_THAN */93) {
        return List.rev(acc$1);
      } else {
        _acc = acc$1;
        _require_default = match$3[1];
        continue ;
        
      }
    }
    
  };
}

function type_parameter_declaration(allow_default, env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LESS_THAN */92) {
    if (!Parser_env$Jeason.should_parse_types(env)) {
      Parser_env$Jeason.error(env, /* UnexpectedTypeAnnotation */7);
    }
    Parser_env$Jeason.Expect[/* token */0](env, /* T_LESS_THAN */92);
    var params$1 = params(env, allow_default, /* false */0, /* [] */0);
    var loc = Loc$Jeason.btwn(start_loc, Parser_env$Jeason.Peek[/* loc */2](/* None */0, env));
    Parser_env$Jeason.Expect[/* token */0](env, /* T_GREATER_THAN */93);
    return /* Some */[/* tuple */[
              loc,
              /* record */[/* params */params$1]
            ]];
  } else {
    return /* None */0;
  }
}

function intersection_with(env, left) {
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_BIT_AND */85) {
    var env$1 = env;
    var _acc = /* :: */[
      left,
      /* [] */0
    ];
    while(true) {
      var acc = _acc;
      var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
      var exit = 0;
      if (typeof match === "number" && match === 85) {
        Parser_env$Jeason.Expect[/* token */0](env$1, /* T_BIT_AND */85);
        _acc = /* :: */[
          anon_function_without_parens(env$1),
          acc
        ];
        continue ;
        
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var match$1 = rev_nonempty_acc(acc);
        var acc$1 = match$1[1];
        if (acc$1) {
          var match$2 = acc$1[1];
          if (match$2) {
            return /* tuple */[
                    match$1[0],
                    /* Intersection */Block.__(6, [
                        acc$1[0],
                        match$2[0],
                        match$2[1]
                      ])
                  ];
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "parser_flow.ml",
                    173,
                    19
                  ]
                ];
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parser_flow.ml",
                  173,
                  19
                ]
              ];
        }
      }
      
    };
  } else {
    return left;
  }
}

function union_with(env, left) {
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_BIT_OR */83) {
    var env$1 = env;
    var _acc = /* :: */[
      left,
      /* [] */0
    ];
    while(true) {
      var acc = _acc;
      var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
      var exit = 0;
      if (typeof match === "number" && match === 83) {
        Parser_env$Jeason.Expect[/* token */0](env$1, /* T_BIT_OR */83);
        _acc = /* :: */[
          intersection(env$1),
          acc
        ];
        continue ;
        
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var match$1 = rev_nonempty_acc(acc);
        var acc$1 = match$1[1];
        if (acc$1) {
          var match$2 = acc$1[1];
          if (match$2) {
            return /* tuple */[
                    match$1[0],
                    /* Union */Block.__(5, [
                        acc$1[0],
                        match$2[0],
                        match$2[1]
                      ])
                  ];
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "parser_flow.ml",
                    152,
                    19
                  ]
                ];
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "parser_flow.ml",
                  152,
                  19
                ]
              ];
        }
      }
      
    };
  } else {
    return left;
  }
}

function param(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env);
  var exit = 0;
  if (typeof match === "number" && (match === 80 || match === 79)) {
    var match$1 = Curry._1(Parse[/* identifier_or_reserved_keyword */13], env);
    return function_param_with_id(env, match$1[0]);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var typeAnnotation = union(env);
    return anonymous_function_param(env, typeAnnotation);
  }
  
}

function function_param_list_without_parens(env) {
  return (function (param$1) {
      var env$1 = env;
      var _acc = param$1;
      while(true) {
        var acc = _acc;
        var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
        var exit = 0;
        if (typeof t === "number") {
          var switcher = t - 6 | 0;
          exit = switcher > 7 || switcher < 0 ? (
              switcher !== 102 ? 1 : 2
            ) : (
              switcher > 6 || switcher < 1 ? 2 : 1
            );
        } else {
          exit = 1;
        }
        switch (exit) {
          case 1 : 
              var acc_000 = param(env$1);
              var acc$1 = /* :: */[
                acc_000,
                acc
              ];
              if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1) !== /* T_RPAREN */6) {
                Parser_env$Jeason.Expect[/* token */0](env$1, /* T_COMMA */10);
              }
              _acc = acc$1;
              continue ;
              case 2 : 
              var rest;
              if (t === /* T_ELLIPSIS */13) {
                var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
                Parser_env$Jeason.Expect[/* token */0](env$1, /* T_ELLIPSIS */13);
                var argument = param(env$1);
                var loc = Loc$Jeason.btwn(start_loc, argument[0]);
                rest = /* Some */[/* tuple */[
                    loc,
                    /* record */[/* argument */argument]
                  ]];
              } else {
                rest = /* None */0;
              }
              return /* tuple */[
                      List.rev(acc),
                      rest
                    ];
          
        }
      };
    });
}

function identifier(env, _param) {
  while(true) {
    var param = _param;
    var qualification = param[1];
    var q_loc = param[0];
    if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_PERIOD */11) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_PERIOD */11);
      var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
      var loc = Loc$Jeason.btwn(q_loc, id[0]);
      var qualification$1 = /* Qualified */Block.__(1, [/* tuple */[
            loc,
            /* record */[
              /* qualification */qualification,
              /* id */id
            ]
          ]]);
      _param = /* tuple */[
        loc,
        qualification$1
      ];
      continue ;
      
    } else {
      return /* tuple */[
              q_loc,
              qualification
            ];
    }
  };
}

function raw_generic_with_identifier(env, id) {
  var id_000 = id[0];
  var id_001 = /* Unqualified */Block.__(0, [id]);
  var id$1 = /* tuple */[
    id_000,
    id_001
  ];
  var match = identifier(env, id$1);
  var id_loc = match[0];
  var typeParameters = Curry._1(type_parameter_instantiation, env);
  var loc = typeParameters ? Loc$Jeason.btwn(id_loc, typeParameters[0][0]) : id_loc;
  return /* tuple */[
          loc,
          /* record */[
            /* id */match[1],
            /* typeParameters */typeParameters
          ]
        ];
}

function params$1(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && !(match !== 93 && match !== 108)) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var acc_000 = union(env);
      var acc$1 = /* :: */[
        acc_000,
        acc
      ];
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_GREATER_THAN */93) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      _acc = acc$1;
      continue ;
      
    }
    
  };
}

function type_parameter_instantiation(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LESS_THAN */92) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_LESS_THAN */92);
    var params$2 = params$1(env, /* [] */0);
    var loc = Loc$Jeason.btwn(start_loc, Parser_env$Jeason.Peek[/* loc */2](/* None */0, env));
    Parser_env$Jeason.Expect[/* token */0](env, /* T_GREATER_THAN */93);
    return /* Some */[/* tuple */[
              loc,
              /* record */[/* params */params$2]
            ]];
  } else {
    return /* None */0;
  }
}

var _type = union;

function annotation(env) {
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeAnnotation */7);
  }
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
  var typeAnnotation = union(env);
  var match = Parser_env$Jeason.last_loc(env);
  var end_loc;
  if (match) {
    end_loc = match[0];
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parser_flow.ml",
            112,
            16
          ]
        ];
  }
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          typeAnnotation
        ];
}

function annotation_opt(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number" && match === 80) {
    return /* Some */[annotation(env)];
  } else {
    return /* None */0;
  }
}

function predicate(env) {
  var checks_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_CHECKS */65);
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LPAREN */5) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_LPAREN */5);
    Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* NORMAL */0);
    var exp = Curry._1(Parse[/* conditional */7], env);
    Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
    var rparen_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    Parser_env$Jeason.Expect[/* token */0](env, /* T_RPAREN */6);
    var loc = Loc$Jeason.btwn(checks_loc, rparen_loc);
    return /* tuple */[
            loc,
            /* Declared */[exp]
          ];
  } else {
    return /* tuple */[
            checks_loc,
            /* Inferred */0
          ];
  }
}

function predicate_opt(env) {
  var env$1 = Parser_env$Jeason.with_no_anon_function_type(/* false */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
  if (typeof match === "number" && match === 65) {
    return /* Some */[predicate(env$1)];
  } else {
    return /* None */0;
  }
}

function annotation_and_predicate_opt(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var match$1 = Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env);
  if (typeof match === "number") {
    if (match !== 80) {
      return /* tuple */[
              /* None */0,
              /* None */0
            ];
    } else {
      var exit = 0;
      if (typeof match$1 === "number" && match$1 === 65) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
        return /* tuple */[
                /* None */0,
                predicate_opt(env)
              ];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var annotation = annotation_opt(env);
        var predicate = predicate_opt(env);
        return /* tuple */[
                annotation,
                predicate
              ];
      }
      
    }
  } else {
    return /* tuple */[
            /* None */0,
            /* None */0
          ];
  }
}

function wrap(f, env) {
  var env$1 = Parser_env$Jeason.with_strict(/* true */1, env);
  Parser_env$Jeason.Eat[/* push_lex_mode */1](env$1, /* TYPE */1);
  var ret = Curry._1(f, env$1);
  Parser_env$Jeason.Eat[/* pop_lex_mode */2](env$1);
  return ret;
}

var partial_arg = Curry._1(type_parameter_declaration, /* true */1);

function type_parameter_declaration_with_defaults(param) {
  return wrap(partial_arg, param);
}

var partial_arg$1 = Curry._1(type_parameter_declaration, /* false */0);

function type_parameter_declaration$1(param) {
  return wrap(partial_arg$1, param);
}

function _object$1($staropt$star, env) {
  var allow_static = $staropt$star ? $staropt$star[0] : /* false */0;
  return wrap(Curry._2(_object, /* Some */[allow_static], /* Some */[/* false */0]), env);
}

function pattern(check_env, _param) {
  while(true) {
    var param = _param;
    var p = param[1];
    switch (p.tag | 0) {
      case 0 : 
          var check_env$1 = check_env;
          var o = p[0];
          return List.fold_left(object_property, check_env$1, o[/* properties */0]);
      case 1 : 
          var check_env$2 = check_env;
          var arr = p[0];
          return List.fold_left(array_element, check_env$2, arr[/* elements */0]);
      case 2 : 
          _param = p[0][/* left */0];
          continue ;
          case 3 : 
          var check_env$3 = check_env;
          var param$1 = p[0];
          var param$2 = check_env$3;
          var id = param$1[/* name */0];
          var name = id[1];
          var param_names = param$2[1];
          var env = param$2[0];
          if (Curry._2(SSet[/* mem */2], name, param_names)) {
            Parser_env$Jeason.error_at(env, /* tuple */[
                  id[0],
                  /* StrictParamDupe */30
                ]);
          }
          var match = identifier_no_dupe_check(/* tuple */[
                env,
                param_names
              ], id);
          return /* tuple */[
                  match[0],
                  Curry._2(SSet[/* add */3], name, match[1])
                ];
      case 4 : 
          Parser_env$Jeason.error_at(check_env[0], /* tuple */[
                param[0],
                /* ExpectedPatternFoundExpression */19
              ]);
          return check_env;
      
    }
  };
}

function object_property(check_env, param) {
  if (param.tag) {
    return pattern(check_env, param[0][1][/* argument */0]);
  } else {
    var property = param[0][1];
    var match = property[/* key */0];
    var check_env$1;
    switch (match.tag | 0) {
      case 1 : 
          check_env$1 = identifier_no_dupe_check(check_env, match[0]);
          break;
      case 0 : 
      case 2 : 
          check_env$1 = check_env;
          break;
      
    }
    return pattern(check_env$1, property[/* pattern */1]);
  }
}

function array_element(check_env, param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      return pattern(check_env, match[0][1][/* argument */0]);
    } else {
      return pattern(check_env, match[0]);
    }
  } else {
    return check_env;
  }
}

function identifier_no_dupe_check(param, param$1) {
  var name = param$1[1];
  var loc = param$1[0];
  var env = param[0];
  if (Parser_env$Jeason.is_restricted(name)) {
    Parser_env$Jeason.strict_error_at(env, /* tuple */[
          loc,
          /* StrictParamName */29
        ]);
  }
  if (Parser_env$Jeason.is_future_reserved(name) || Parser_env$Jeason.is_strict_reserved(name)) {
    Parser_env$Jeason.strict_error_at(env, /* tuple */[
          loc,
          /* StrictReservedWord */40
        ]);
  }
  return /* tuple */[
          env,
          param[1]
        ];
}

function strict_post_check(env, strict, simple, id, param) {
  if (strict || !simple) {
    var rest = param[1];
    var env$1 = strict ? Parser_env$Jeason.with_strict(1 - Parser_env$Jeason.in_strict_mode(env), env) : env;
    if (id) {
      var match = id[0];
      var name = match[1];
      var loc = match[0];
      if (Parser_env$Jeason.is_restricted(name)) {
        Parser_env$Jeason.strict_error_at(env$1, /* tuple */[
              loc,
              /* StrictFunctionName */31
            ]);
      }
      if (Parser_env$Jeason.is_future_reserved(name) || Parser_env$Jeason.is_strict_reserved(name)) {
        Parser_env$Jeason.strict_error_at(env$1, /* tuple */[
              loc,
              /* StrictReservedWord */40
            ]);
      }
      
    }
    var acc = List.fold_left(pattern, /* tuple */[
          env$1,
          SSet[/* empty */0]
        ], param[0]);
    if (rest) {
      pattern(acc, rest[0][1][/* argument */0]);
      return /* () */0;
    } else {
      return /* () */0;
    }
  } else {
    return 0;
  }
}

function param$1(env) {
  var left = Curry._2(Parse[/* pattern */18], env, /* StrictParamName */29);
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_ASSIGN */78) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78);
    var right = Curry._1(Parse[/* assignment */8], env);
    var loc = Loc$Jeason.btwn(left[0], right[0]);
    return /* tuple */[
            loc,
            /* Assignment */Block.__(2, [/* record */[
                  /* left */left,
                  /* right */right
                ]])
          ];
  } else {
    return left;
  }
}

function param_list(env, _acc) {
  while(true) {
    var acc = _acc;
    var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof t === "number") {
      var switcher = t - 6 | 0;
      exit = switcher > 7 || switcher < 0 ? (
          switcher !== 102 ? 1 : 2
        ) : (
          switcher > 6 || switcher < 1 ? 2 : 1
        );
    } else {
      exit = 1;
    }
    switch (exit) {
      case 1 : 
          var the_param = param$1(env);
          if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RPAREN */6) {
            Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
          }
          _acc = /* :: */[
            the_param,
            acc
          ];
          continue ;
          case 2 : 
          var rest;
          if (t === /* T_ELLIPSIS */13) {
            var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
            Parser_env$Jeason.Expect[/* token */0](env, /* T_ELLIPSIS */13);
            var id = Curry._2(Parse[/* pattern */18], env, /* StrictParamName */29);
            var loc = Loc$Jeason.btwn(start_loc, id[0]);
            rest = /* Some */[/* tuple */[
                loc,
                /* record */[/* argument */id]
              ]];
          } else {
            rest = /* None */0;
          }
          if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RPAREN */6) {
            Parser_env$Jeason.error(env, /* ParameterAfterRestParameter */48);
          }
          return /* tuple */[
                  List.rev(acc),
                  rest
                ];
      
    }
  };
}

function function_params(env) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LPAREN */5);
  var params = param_list(env, /* [] */0);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RPAREN */6);
  return params;
}

function function_body(env, async, generator) {
  var env$1 = Parser_env$Jeason.enter_function(env, async, generator);
  var match = Curry._1(Parse[/* function_block_body */16], env$1);
  var loc = match[0];
  return /* tuple */[
          loc,
          /* BodyBlock */Block.__(0, [/* tuple */[
                loc,
                match[1]
              ]]),
          match[2]
        ];
}

function variance$1(env, is_async, is_generator) {
  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var variance$2 = typeof match === "number" ? (
      match !== 97 ? (
          match !== 98 ? /* None */0 : (Parser_env$Jeason.Eat[/* token */0](env), /* Some */[/* tuple */[
                  loc,
                  /* Minus */1
                ]])
        ) : (Parser_env$Jeason.Eat[/* token */0](env), /* Some */[/* tuple */[
              loc,
              /* Plus */0
            ]])
    ) : /* None */0;
  if (variance$2 && (is_async || is_generator)) {
    Parser_env$Jeason.error_at(env, /* tuple */[
          variance$2[0][0],
          /* UnexpectedVariance */5
        ]);
    return /* None */0;
  } else {
    return variance$2;
  }
}

function is_simple_param(param) {
  if (param[1].tag === 3) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function is_simple_function_params(param) {
  if (param[1] === /* None */0) {
    return List.for_all(is_simple_param, param[0]);
  } else {
    return /* false */0;
  }
}

function _function(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var async = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_ASYNC */63);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_FUNCTION */15);
  var generator = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_MULT */100);
  var match = Parser_env$Jeason.in_export(env);
  var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var match$2;
  var exit = 0;
  if (match !== 0 && typeof match$1 === "number") {
    if (match$1 !== 5) {
      if (match$1 !== 92) {
        exit = 1;
      } else {
        var typeParams = Curry._1(type_parameter_declaration$1, env);
        var id = Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LPAREN */5 ? /* None */0 : /* Some */[Curry._2(Parse[/* identifier */12], /* Some */[/* StrictFunctionName */31], env)];
        match$2 = /* tuple */[
          typeParams,
          id
        ];
      }
    } else {
      match$2 = /* tuple */[
        /* None */0,
        /* None */0
      ];
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var id$1 = Curry._2(Parse[/* identifier */12], /* Some */[/* StrictFunctionName */31], env);
    match$2 = /* tuple */[
      Curry._1(type_parameter_declaration$1, env),
      /* Some */[id$1]
    ];
  }
  var id$2 = match$2[1];
  var params = function_params(env);
  var match$3 = wrap(annotation_and_predicate_opt, env);
  var match$4 = function_body(env, async, generator);
  var body = match$4[1];
  var simple = is_simple_function_params(params);
  strict_post_check(env, match$4[2], simple, id$2, params);
  var match$5;
  match$5 = body.tag ? /* tuple */[
      body[0][0],
      /* true */1
    ] : /* tuple */[
      body[0][0],
      /* false */0
    ];
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, match$5[0]),
          /* FunctionDeclaration */Block.__(17, [/* record */[
                /* id */id$2,
                /* params */params,
                /* body */body,
                /* async */async,
                /* generator */generator,
                /* predicate */match$3[1],
                /* expression */match$5[1],
                /* returnType */match$3[0],
                /* typeParameters */match$2[0]
              ]])
        ];
}

function variable_declaration(env) {
  var id = Curry._2(Parse[/* pattern */18], env, /* StrictVarName */28);
  var match;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_ASSIGN */78) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78);
    match = /* tuple */[
      /* Some */[Curry._1(Parse[/* assignment */8], env)],
      /* [] */0
    ];
  } else {
    match = id[1].tag === 3 ? /* tuple */[
        /* None */0,
        /* [] */0
      ] : /* tuple */[
        /* None */0,
        /* :: */[
          /* tuple */[
            id[0],
            /* NoUninitializedDestructuring */44
          ],
          /* [] */0
        ]
      ];
  }
  var init = match[0];
  var end_loc = init ? init[0][0] : id[0];
  return /* tuple */[
          /* tuple */[
            Loc$Jeason.btwn(id[0], end_loc),
            /* record */[
              /* id */id,
              /* init */init
            ]
          ],
          match[1]
        ];
}

function helper(env, _decls, _errs) {
  while(true) {
    var errs = _errs;
    var decls = _decls;
    var match = variable_declaration(env);
    var decl = match[0];
    var decls$1 = /* :: */[
      decl,
      decls
    ];
    var errs$1 = Pervasives.$at(match[1], errs);
    if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COMMA */10) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      _errs = errs$1;
      _decls = decls$1;
      continue ;
      
    } else {
      var end_loc = decl[0];
      var declarations = List.rev(decls$1);
      var start_loc = decl[0];
      return /* tuple */[
              Loc$Jeason.btwn(start_loc, end_loc),
              declarations,
              List.rev(errs$1)
            ];
    }
  };
}

function declarations(token, kind, env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, token);
  var match = helper(env, /* [] */0, /* [] */0);
  return /* tuple */[
          /* tuple */[
            Loc$Jeason.btwn(start_loc, match[0]),
            /* record */[
              /* declarations */match[1],
              /* kind */kind
            ]
          ],
          match[2]
        ];
}

function $$const(env) {
  var env$1 = Parser_env$Jeason.with_no_let(/* true */1, env);
  var match = declarations(/* T_CONST */27, /* Const */2, env$1);
  var match$1 = match[0];
  var variable = match$1[1];
  var errs = List.fold_left((function (errs, decl) {
          if (decl[1][/* init */1]) {
            return errs;
          } else {
            return /* :: */[
                    /* tuple */[
                      decl[0],
                      /* NoUninitializedConst */43
                    ],
                    errs
                  ];
          }
        }), match[1], variable[/* declarations */0]);
  return /* tuple */[
          /* tuple */[
            match$1[0],
            variable
          ],
          List.rev(errs)
        ];
}

function _let(env) {
  var env$1 = Parser_env$Jeason.with_no_let(/* true */1, env);
  return declarations(/* T_LET */28, /* Let */1, env$1);
}

function variable(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var match$1;
  if (typeof match === "number") {
    var switcher = match - 24 | 0;
    if (switcher > 4 || switcher < 0) {
      Parser_env$Jeason.error_unexpected(env);
      match$1 = declarations(/* T_VAR */24, /* Var */0, env);
    } else {
      switch (switcher) {
        case 0 : 
            match$1 = declarations(/* T_VAR */24, /* Var */0, env);
            break;
        case 1 : 
        case 2 : 
            Parser_env$Jeason.error_unexpected(env);
            match$1 = declarations(/* T_VAR */24, /* Var */0, env);
            break;
        case 3 : 
            match$1 = $$const(env);
            break;
        case 4 : 
            match$1 = _let(env);
            break;
        
      }
    }
  } else {
    Parser_env$Jeason.error_unexpected(env);
    match$1 = declarations(/* T_VAR */24, /* Var */0, env);
  }
  var match$2 = match$1[0];
  return /* tuple */[
          /* tuple */[
            Loc$Jeason.btwn(start_loc, match$2[0]),
            /* VariableDeclaration */Block.__(18, [match$2[1]])
          ],
          match$1[1]
        ];
}

function is_tighter(a, b) {
  var a_prec;
  a_prec = a.tag ? a[0] - 1 | 0 : a[0];
  return +(a_prec >= b[0]);
}

function is_lhs(param) {
  var tmp = param[1];
  if (typeof tmp === "number") {
    return /* false */0;
  } else {
    switch (tmp.tag | 0) {
      case 13 : 
      case 17 : 
      case 24 : 
          return /* true */1;
      default:
        return /* false */0;
    }
  }
}

function is_assignable_lhs(param) {
  var tmp = param[1];
  if (typeof tmp === "number") {
    return /* false */0;
  } else {
    switch (tmp.tag | 0) {
      case 0 : 
      case 1 : 
      case 13 : 
      case 17 : 
      case 24 : 
          return /* true */1;
      default:
        return /* false */0;
    }
  }
}

function assignment_op(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var op;
  if (typeof match === "number") {
    var switcher = match - 66 | 0;
    if (switcher > 12 || switcher < 0) {
      op = /* None */0;
    } else {
      switch (switcher) {
        case 0 : 
            op = /* Some */[/* RShift3Assign */9];
            break;
        case 1 : 
            op = /* Some */[/* RShiftAssign */8];
            break;
        case 2 : 
            op = /* Some */[/* LShiftAssign */7];
            break;
        case 3 : 
            op = /* Some */[/* BitXorAssign */11];
            break;
        case 4 : 
            op = /* Some */[/* BitOrAssign */10];
            break;
        case 5 : 
            op = /* Some */[/* BitAndAssign */12];
            break;
        case 6 : 
            op = /* Some */[/* ModAssign */6];
            break;
        case 7 : 
            op = /* Some */[/* DivAssign */5];
            break;
        case 8 : 
            op = /* Some */[/* MultAssign */3];
            break;
        case 9 : 
            op = /* Some */[/* ExpAssign */4];
            break;
        case 10 : 
            op = /* Some */[/* MinusAssign */2];
            break;
        case 11 : 
            op = /* Some */[/* PlusAssign */1];
            break;
        case 12 : 
            op = /* Some */[/* Assign */0];
            break;
        
      }
    }
  } else {
    op = /* None */0;
  }
  if (op !== /* None */0) {
    Parser_env$Jeason.Eat[/* token */0](env);
  }
  return op;
}

function conditional(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var expr = Curry._1(logical, env);
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_PLING */79) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_PLING */79);
    var env$prime = Parser_env$Jeason.with_no_in(/* false */0, env);
    var consequent = Curry._1(assignment, env$prime);
    Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
    var match = with_loc(assignment, env);
    var loc = Loc$Jeason.btwn(start_loc, match[0]);
    return /* tuple */[
            loc,
            /* Conditional */Block.__(10, [/* record */[
                  /* test */expr,
                  /* consequent */consequent,
                  /* alternate */match[1]
                ]])
          ];
  } else {
    return expr;
  }
}

function peek_unary_op(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    if (match >= 48) {
      if (match >= 97) {
        if (match >= 105) {
          return /* None */0;
        } else {
          switch (match - 97 | 0) {
            case 0 : 
                return /* Some */[/* Plus */1];
            case 1 : 
                return /* Some */[/* Minus */0];
            case 2 : 
            case 3 : 
            case 4 : 
            case 5 : 
                return /* None */0;
            case 6 : 
                return /* Some */[/* Not */2];
            case 7 : 
                return /* Some */[/* BitNot */3];
            
          }
        }
      } else if (match !== 64 || !Parser_env$Jeason.allow_await(env)) {
        return /* None */0;
      } else {
        return /* Some */[/* Await */7];
      }
    } else if (match >= 45) {
      switch (match - 45 | 0) {
        case 0 : 
            return /* Some */[/* Delete */6];
        case 1 : 
            return /* Some */[/* Typeof */4];
        case 2 : 
            return /* Some */[/* Void */5];
        
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function unary(env) {
  var begin_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var op = peek_unary_op(env);
  if (op) {
    var operator = op[0];
    Parser_env$Jeason.Eat[/* token */0](env);
    var argument = unary(env);
    var loc = Loc$Jeason.btwn(begin_loc, argument[0]);
    if (operator === 6) {
      var tmp = argument[1];
      if (typeof tmp !== "number") {
        if (tmp.tag === 17) {
          Parser_env$Jeason.strict_error_at(env, /* tuple */[
                loc,
                /* StrictDelete */33
              ]);
        }
        
      }
      
    }
    return /* tuple */[
            loc,
            /* Unary */Block.__(5, [/* record */[
                  /* operator */operator,
                  /* prefix : true */1,
                  /* argument */argument
                ]])
          ];
  } else {
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var op$1 = typeof match === "number" ? (
        match !== 105 ? (
            match !== 106 ? /* None */0 : /* Some */[/* Decrement */1]
          ) : /* Some */[/* Increment */0]
      ) : /* None */0;
    if (op$1) {
      Parser_env$Jeason.Eat[/* token */0](env);
      var argument$1 = unary(env);
      if (!is_lhs(argument$1)) {
        Parser_env$Jeason.error_at(env, /* tuple */[
              argument$1[0],
              /* InvalidLHSInAssignment */15
            ]);
      }
      var match$1 = argument$1[1];
      if (typeof match$1 !== "number") {
        if (match$1.tag === 17) {
          if (Parser_env$Jeason.is_restricted(match$1[0][1])) {
            Parser_env$Jeason.strict_error(env, /* StrictLHSPrefix */39);
          }
          
        }
        
      }
      return /* tuple */[
              Loc$Jeason.btwn(begin_loc, argument$1[0]),
              /* Update */Block.__(8, [/* record */[
                    /* operator */op$1[0],
                    /* argument */argument$1,
                    /* prefix : true */1
                  ]])
            ];
    } else {
      var env$1 = env;
      var argument$2 = left_hand_side(env$1);
      if (Parser_env$Jeason.Peek[/* is_line_terminator */5](env$1)) {
        return argument$2;
      } else {
        var match$2 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
        var op$2 = typeof match$2 === "number" ? (
            match$2 !== 105 ? (
                match$2 !== 106 ? /* None */0 : /* Some */[/* Decrement */1]
              ) : /* Some */[/* Increment */0]
          ) : /* None */0;
        if (op$2) {
          if (!is_lhs(argument$2)) {
            Parser_env$Jeason.error_at(env$1, /* tuple */[
                  argument$2[0],
                  /* InvalidLHSInAssignment */15
                ]);
          }
          var match$3 = argument$2[1];
          if (typeof match$3 !== "number") {
            if (match$3.tag === 17) {
              if (Parser_env$Jeason.is_restricted(match$3[0][1])) {
                Parser_env$Jeason.strict_error(env$1, /* StrictLHSPostfix */38);
              }
              
            }
            
          }
          var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
          Parser_env$Jeason.Eat[/* token */0](env$1);
          return /* tuple */[
                  Loc$Jeason.btwn(argument$2[0], end_loc),
                  /* Update */Block.__(8, [/* record */[
                        /* operator */op$2[0],
                        /* argument */argument$2,
                        /* prefix : false */0
                      ]])
                ];
        } else {
          return argument$2;
        }
      }
    }
  }
}

function left_hand_side(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var allow_new = 1 - Parser_env$Jeason.no_new(env);
  var env$1 = Parser_env$Jeason.with_no_new(/* false */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
  var expr;
  var exit = 0;
  if (typeof match === "number" && !(match !== 44 || !allow_new)) {
    expr = new_expression(env$1);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    expr = Parser_env$Jeason.Peek[/* is_function */10](/* None */0, env$1) ? _function$1(env$1) : primary$1(env$1);
  }
  var expr$1 = member(env$1, start_loc, expr);
  var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
  if (typeof match$1 === "number") {
    if (match$1 === 5) {
      return call(env$1, start_loc, expr$1);
    } else {
      return expr$1;
    }
  } else if (match$1.tag === 2) {
    return member(env$1, start_loc, tagged_template(env$1, start_loc, expr$1, match$1[0]));
  } else {
    return expr$1;
  }
}

function call(env, start_loc, _left) {
  while(true) {
    var left = _left;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number") {
      switch (match) {
        case 5 : 
            if (Parser_env$Jeason.no_call(env)) {
              return left;
            } else {
              var match$1 = Curry._1($$arguments, env);
              var loc = Loc$Jeason.btwn(start_loc, match$1[0]);
              _left = /* tuple */[
                loc,
                /* Call */Block.__(12, [/* record */[
                      /* callee */left,
                      /* arguments */match$1[1]
                    ]])
              ];
              continue ;
              
            }
        case 7 : 
            Parser_env$Jeason.Expect[/* token */0](env, /* T_LBRACKET */7);
            var expr = Curry._1(Parse[/* expression */6], env);
            var last_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
            var loc$1 = Loc$Jeason.btwn(start_loc, last_loc);
            Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
            _left = /* tuple */[
              loc$1,
              /* Member */Block.__(13, [/* record */[
                    /* _object */left,
                    /* property : PropertyExpression */Block.__(1, [expr]),
                    /* computed : true */1
                  ]])
            ];
            continue ;
            case 11 : 
            Parser_env$Jeason.Expect[/* token */0](env, /* T_PERIOD */11);
            var match$2 = identifier_or_reserved_keyword(env);
            var id = match$2[0];
            var loc$2 = Loc$Jeason.btwn(start_loc, id[0]);
            _left = /* tuple */[
              loc$2,
              /* Member */Block.__(13, [/* record */[
                    /* _object */left,
                    /* property : PropertyIdentifier */Block.__(0, [id]),
                    /* computed : false */0
                  ]])
            ];
            continue ;
            default:
          return left;
      }
    } else if (match.tag === 2) {
      return tagged_template(env, start_loc, left, match[0]);
    } else {
      return left;
    }
  };
}

function new_expression(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_NEW */44);
  if (Parser_env$Jeason.in_function(env) && Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_PERIOD */11) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_PERIOD */11);
    var meta = /* tuple */[
      start_loc,
      "new"
    ];
    if (Parser_env$Jeason.Peek[/* value */1](/* None */0, env) === "target") {
      var property = Curry._2(Parse[/* identifier */12], /* None */0, env);
      var end_loc = property[0];
      return /* tuple */[
              Loc$Jeason.btwn(start_loc, end_loc),
              /* MetaProperty */Block.__(24, [/* record */[
                    /* meta */meta,
                    /* property */property
                  ]])
            ];
    } else {
      Parser_env$Jeason.error_unexpected(env);
      Parser_env$Jeason.Eat[/* token */0](env);
      return /* tuple */[
              start_loc,
              /* Identifier */Block.__(17, [meta])
            ];
    }
  } else {
    var callee_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var expr;
    var exit = 0;
    if (typeof match === "number" && match === 44) {
      expr = new_expression(env);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      expr = Parser_env$Jeason.Peek[/* is_function */10](/* None */0, env) ? _function$1(env) : primary$1(env);
    }
    var callee = member(Parser_env$Jeason.with_no_call(/* true */1, env), callee_loc, expr);
    var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var callee$1;
    callee$1 = typeof match$1 === "number" || match$1.tag !== 2 ? callee : tagged_template(env, callee_loc, callee, match$1[0]);
    var match$2 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var match$3 = typeof match$2 === "number" ? (
        match$2 !== 5 ? /* tuple */[
            callee$1[0],
            /* [] */0
          ] : Curry._1($$arguments, env)
      ) : /* tuple */[
        callee$1[0],
        /* [] */0
      ];
    return /* tuple */[
            Loc$Jeason.btwn(start_loc, match$3[0]),
            /* New */Block.__(11, [/* record */[
                  /* callee */callee$1,
                  /* arguments */match$3[1]
                ]])
          ];
  }
}

function member(env, start_loc, left) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    if (match !== 7) {
      if (match !== 11) {
        return left;
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_PERIOD */11);
        var match$1 = identifier_or_reserved_keyword(env);
        var id = match$1[0];
        var loc = Loc$Jeason.btwn(start_loc, id[0]);
        return call(env, start_loc, /* tuple */[
                    loc,
                    /* Member */Block.__(13, [/* record */[
                          /* _object */left,
                          /* property : PropertyIdentifier */Block.__(0, [id]),
                          /* computed : false */0
                        ]])
                  ]);
      }
    } else {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_LBRACKET */7);
      var expr = Curry._1(Parse[/* expression */6], Parser_env$Jeason.with_no_call(/* false */0, env));
      var last_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
      var loc$1 = Loc$Jeason.btwn(start_loc, last_loc);
      return call(env, start_loc, /* tuple */[
                  loc$1,
                  /* Member */Block.__(13, [/* record */[
                        /* _object */left,
                        /* property : PropertyExpression */Block.__(1, [expr]),
                        /* computed : true */1
                      ]])
                ]);
    }
  } else {
    return left;
  }
}

function _function$1(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var async = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_ASYNC */63);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_FUNCTION */15);
  var generator = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_MULT */100);
  var match;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LPAREN */5) {
    match = /* tuple */[
      /* None */0,
      /* None */0
    ];
  } else {
    var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var id = typeof match$1 === "number" ? (
        match$1 !== 92 ? /* Some */[Curry._2(Parse[/* identifier */12], /* Some */[/* StrictFunctionName */31], env)] : /* None */0
      ) : /* Some */[Curry._2(Parse[/* identifier */12], /* Some */[/* StrictFunctionName */31], env)];
    match = /* tuple */[
      id,
      Curry._1(type_parameter_declaration$1, env)
    ];
  }
  var id$1 = match[0];
  var params = function_params(env);
  var match$2 = wrap(annotation_and_predicate_opt, env);
  var match$3 = function_body(env, async, generator);
  var body = match$3[1];
  var simple = is_simple_function_params(params);
  strict_post_check(env, match$3[2], simple, id$1, params);
  var expression;
  expression = body.tag ? /* true */1 : /* false */0;
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, match$3[0]),
          /* Function */Block.__(2, [/* record */[
                /* id */id$1,
                /* params */params,
                /* body */body,
                /* async */async,
                /* generator */generator,
                /* predicate */match$2[1],
                /* expression */expression,
                /* returnType */match$2[0],
                /* typeParameters */match[1]
              ]])
        ];
}

function number(env, number_type) {
  var value = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
  var value$1;
  if (number_type !== 0) {
    switch (number_type - 1 | 0) {
      case 0 : 
          Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
          value$1 = Caml_format.caml_int_of_string("0o" + value);
          break;
      case 1 : 
          value$1 = Caml_format.caml_int_of_string(value);
          break;
      case 2 : 
          try {
            value$1 = Lexer_flow$Jeason.FloatOfString[/* float_of_string */0](value);
          }
          catch (exn){
            if (Sys.win32) {
              Parser_env$Jeason.error(env, /* WindowsFloatOfString */59);
              value$1 = 789.0;
            } else {
              throw exn;
            }
          }
          break;
      
    }
  } else {
    value$1 = Caml_format.caml_int_of_string(value);
  }
  Parser_env$Jeason.Expect[/* token */0](env, /* T_NUMBER */Block.__(0, [number_type]));
  return value$1;
}

function primary$1(env) {
  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof token === "number") {
    switch (token) {
      case 1 : 
          var env$1 = env;
          var match = Curry._1(Parse[/* object_initializer */10], env$1);
          return /* tuple */[
                  match[0],
                  /* Object */Block.__(1, [match[1]])
                ];
      case 5 : 
          var env$2 = env;
          Parser_env$Jeason.Expect[/* token */0](env$2, /* T_LPAREN */5);
          var expression = Curry._1(assignment, env$2);
          var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$2);
          var ret;
          if (typeof match$1 === "number") {
            if (match$1 !== 10) {
              if (match$1 !== 80) {
                ret = expression;
              } else {
                var typeAnnotation = wrap(annotation, env$2);
                ret = /* tuple */[
                  Loc$Jeason.btwn(expression[0], typeAnnotation[0]),
                  /* TypeCast */Block.__(23, [/* record */[
                        /* expression */expression,
                        /* typeAnnotation */typeAnnotation
                      ]])
                ];
              }
            } else {
              ret = sequence(env$2, /* :: */[
                    expression,
                    /* [] */0
                  ]);
            }
          } else {
            ret = expression;
          }
          Parser_env$Jeason.Expect[/* token */0](env$2, /* T_RPAREN */6);
          return ret;
      case 7 : 
          var match$2 = Curry._1(array_initializer, env);
          return /* tuple */[
                  match$2[0],
                  /* Array */Block.__(0, [match$2[1]])
                ];
      case 21 : 
          Parser_env$Jeason.Expect[/* token */0](env, /* T_THIS */21);
          return /* tuple */[
                  loc,
                  /* This */0
                ];
      case 29 : 
          var raw = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
          Parser_env$Jeason.Expect[/* token */0](env, /* T_NULL */29);
          return /* tuple */[
                  loc,
                  /* Literal */Block.__(18, [/* record */[
                        /* value : Null */0,
                        /* raw */raw
                      ]])
                ];
      case 30 : 
      case 31 : 
          exit = 2;
          break;
      case 40 : 
          return Curry._1(Parse[/* class_expression */22], env);
      case 51 : 
          var loc$1 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
          Parser_env$Jeason.Expect[/* token */0](env, /* T_SUPER */51);
          return /* tuple */[
                  loc$1,
                  /* Super */1
                ];
      case 92 : 
          var match$3 = Curry._1(Parse[/* jsx_element */17], env);
          return /* tuple */[
                  match$3[0],
                  /* JSXElement */Block.__(21, [match$3[1]])
                ];
      case 73 : 
      case 99 : 
          var env$3 = env;
          Parser_env$Jeason.Eat[/* push_lex_mode */1](env$3, /* REGEXP */5);
          var loc$2 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$3);
          var match$4 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$3);
          var match$5;
          if (typeof match$4 === "number") {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "parser_flow.ml",
                    1845,
                    15
                  ]
                ];
          } else if (match$4.tag === 3) {
            var match$6 = match$4[0];
            var raw$1 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$3);
            Parser_env$Jeason.Eat[/* token */0](env$3);
            match$5 = /* tuple */[
              raw$1,
              match$6[1],
              match$6[2]
            ];
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "parser_flow.ml",
                    1845,
                    15
                  ]
                ];
          }
          var raw_flags = match$5[2];
          Parser_env$Jeason.Eat[/* pop_lex_mode */2](env$3);
          var filtered_flags = Buffer.create(raw_flags.length);
          $$String.iter((function (c) {
                  var switcher = c - 103 | 0;
                  if (switcher > 18 || switcher < 0) {
                    return /* () */0;
                  } else {
                    switch (switcher) {
                      case 1 : 
                      case 3 : 
                      case 4 : 
                      case 5 : 
                      case 7 : 
                      case 8 : 
                      case 9 : 
                      case 10 : 
                      case 11 : 
                      case 12 : 
                      case 13 : 
                      case 15 : 
                      case 16 : 
                      case 17 : 
                          return /* () */0;
                      case 0 : 
                      case 2 : 
                      case 6 : 
                      case 14 : 
                      case 18 : 
                          return Buffer.add_char(filtered_flags, c);
                      
                    }
                  }
                }), raw_flags);
          var flags = Buffer.contents(filtered_flags);
          if (flags !== raw_flags) {
            Parser_env$Jeason.error(env$3, /* InvalidRegExpFlags */Block.__(3, [raw_flags]));
          }
          var value = /* RegExp */Block.__(3, [/* record */[
                /* pattern */match$5[1],
                /* flags */flags
              ]]);
          return /* tuple */[
                  loc$2,
                  /* Literal */Block.__(18, [/* record */[
                        /* value */value,
                        /* raw */match$5[0]
                      ]])
                ];
      default:
        exit = 1;
    }
  } else {
    switch (token.tag | 0) {
      case 0 : 
          var raw$2 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
          var value$1 = /* Number */Block.__(2, [number(env, token[0])]);
          return /* tuple */[
                  loc,
                  /* Literal */Block.__(18, [/* record */[
                        /* value */value$1,
                        /* raw */raw$2
                      ]])
                ];
      case 1 : 
          var match$7 = token[0];
          var octal = match$7[3];
          var raw$3 = match$7[2];
          var value$2 = match$7[1];
          var loc$3 = match$7[0];
          if (octal) {
            Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
          }
          Parser_env$Jeason.Expect[/* token */0](env, /* T_STRING */Block.__(1, [/* tuple */[
                    loc$3,
                    value$2,
                    raw$3,
                    octal
                  ]]));
          var value$3 = /* String */Block.__(0, [value$2]);
          return /* tuple */[
                  loc$3,
                  /* Literal */Block.__(18, [/* record */[
                        /* value */value$3,
                        /* raw */raw$3
                      ]])
                ];
      case 2 : 
          var match$8 = Curry._2(template_literal, env, token[0]);
          return /* tuple */[
                  match$8[0],
                  /* TemplateLiteral */Block.__(19, [match$8[1]])
                ];
      default:
        exit = 1;
    }
  }
  switch (exit) {
    case 1 : 
        if (Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, env)) {
          var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
          return /* tuple */[
                  id[0],
                  /* Identifier */Block.__(17, [id])
                ];
        } else {
          Parser_env$Jeason.error_unexpected(env);
          if (token === /* T_ERROR */107) {
            Parser_env$Jeason.Eat[/* token */0](env);
          }
          return /* tuple */[
                  loc,
                  /* Literal */Block.__(18, [/* record */[
                        /* value : Null */0,
                        /* raw */"null"
                      ]])
                ];
        }
    case 2 : 
        var raw$4 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
        Parser_env$Jeason.Expect[/* token */0](env, token);
        var value$4 = /* Boolean */Block.__(1, [+(token === /* T_TRUE */31)]);
        return /* tuple */[
                loc,
                /* Literal */Block.__(18, [/* record */[
                      /* value */value$4,
                      /* raw */raw$4
                    ]])
              ];
    
  }
}

function tagged_template(env, start_loc, tag, part) {
  var quasi = Curry._2(template_literal, env, part);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, quasi[0]),
          /* TaggedTemplate */Block.__(20, [/* record */[
                /* tag */tag,
                /* quasi */quasi
              ]])
        ];
}

function sequence(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && match === 10) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      var expr = Curry._1(assignment, env);
      _acc = /* :: */[
        expr,
        acc
      ];
      continue ;
      
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var last_loc = acc ? acc[0][0] : Loc$Jeason.none;
      var expressions = List.rev(acc);
      var first_loc = expressions ? expressions[0][0] : Loc$Jeason.none;
      return /* tuple */[
              Loc$Jeason.btwn(first_loc, last_loc),
              /* Sequence */Block.__(4, [/* record */[/* expressions */expressions]])
            ];
    }
    
  };
}

function identifier_or_reserved_keyword(env) {
  var lex_token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var lex_value = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
  var lex_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var exit = 0;
  if (typeof lex_token === "number") {
    if (lex_token >= 60) {
      if (lex_token >= 64) {
        exit = 1;
      } else {
        return /* tuple */[
                Curry._2(Parse[/* identifier */12], /* None */0, env),
                /* None */0
              ];
      }
    } else if (lex_token !== 0) {
      exit = 1;
    } else {
      return /* tuple */[
              Curry._2(Parse[/* identifier */12], /* None */0, env),
              /* None */0
            ];
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var err;
    var exit$1 = 0;
    if (typeof lex_token === "number") {
      if (lex_token >= 65) {
        if (lex_token !== 110 && lex_token < 113) {
          Parser_env$Jeason.error_unexpected(env);
          err = /* None */0;
        } else {
          exit$1 = 2;
        }
      } else if (lex_token >= 60) {
        if (lex_token >= 64) {
          exit$1 = 2;
        } else {
          Parser_env$Jeason.error_unexpected(env);
          err = /* None */0;
        }
      } else if (lex_token >= 15) {
        exit$1 = 2;
      } else {
        Parser_env$Jeason.error_unexpected(env);
        err = /* None */0;
      }
    } else {
      Parser_env$Jeason.error_unexpected(env);
      err = /* None */0;
    }
    if (exit$1 === 2) {
      err = /* Some */[/* tuple */[
          lex_loc,
          Parser_env$Jeason.get_unexpected_error(/* tuple */[
                lex_token,
                lex_value
              ])
        ]];
    }
    Parser_env$Jeason.Eat[/* token */0](env);
    return /* tuple */[
            /* tuple */[
              lex_loc,
              lex_value
            ],
            err
          ];
  }
  
}

function assignment_but_not_arrow_function(env) {
  var expr = conditional(env);
  var match = assignment_op(env);
  if (match) {
    if (!is_assignable_lhs(expr)) {
      Parser_env$Jeason.error_at(env, /* tuple */[
            expr[0],
            /* InvalidLHSInAssignment */15
          ]);
    }
    var match$1 = expr[1];
    if (typeof match$1 !== "number") {
      if (match$1.tag === 17) {
        if (Parser_env$Jeason.is_restricted(match$1[0][1])) {
          Parser_env$Jeason.strict_error_at(env, /* tuple */[
                expr[0],
                /* StrictLHSAssignment */37
              ]);
        }
        
      }
      
    }
    var left = Curry._2(Parse[/* pattern_from_expr */19], env, expr);
    var right = Curry._1(assignment, env);
    var loc = Loc$Jeason.btwn(left[0], right[0]);
    return /* tuple */[
            loc,
            /* Assignment */Block.__(7, [/* record */[
                  /* operator */match[0],
                  /* left */left,
                  /* right */right
                ]])
          ];
  } else {
    return expr;
  }
}

function error_callback(_, _$1) {
  throw Parser_env$Jeason.Try[/* Rollback */0];
}

function try_assignment_but_not_arrow_function(env) {
  var env$1 = Parser_env$Jeason.with_error_callback(error_callback, env);
  var ret = assignment_but_not_arrow_function(env$1);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
  var exit = 0;
  if (typeof match === "number") {
    if (match !== 12) {
      if (match !== 80) {
        exit = 1;
      } else {
        throw Parser_env$Jeason.Try[/* Rollback */0];
      }
    } else {
      throw Parser_env$Jeason.Try[/* Rollback */0];
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, env$1)) {
      var match$1 = ret[1];
      if (typeof match$1 === "number" || !(match$1.tag === 17 && match$1[0][1] === "async" && !Parser_env$Jeason.Peek[/* is_line_terminator */5](env$1))) {
        return ret;
      } else {
        throw Parser_env$Jeason.Try[/* Rollback */0];
      }
    } else {
      return ret;
    }
  }
  
}

function assignment(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var match$1 = Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, env);
  var exit = 0;
  var exit$1 = 0;
  if (typeof match === "number") {
    var switcher = match - 6 | 0;
    if (switcher > 85 || switcher < 0) {
      if ((switcher + 1 >>> 0) > 87) {
        exit$1 = 2;
      } else {
        exit = 1;
      }
    } else if (switcher !== 52 || !Parser_env$Jeason.allow_yield(env)) {
      exit$1 = 2;
    } else {
      var env$1 = env;
      var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
      Parser_env$Jeason.Expect[/* token */0](env$1, /* T_YIELD */58);
      if (!Parser_env$Jeason.allow_yield(env$1)) {
        Parser_env$Jeason.error(env$1, /* IllegalYield */25);
      }
      var delegate = Parser_env$Jeason.Expect[/* maybe */1](env$1, /* T_MULT */100);
      var has_argument = 1 - (+(Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1) === /* T_SEMICOLON */9) || Parser_env$Jeason.Peek[/* is_implicit_semicolon */6](env$1));
      var argument = delegate || has_argument ? /* Some */[Curry._1(assignment, env$1)] : /* None */0;
      var end_loc;
      if (argument) {
        end_loc = argument[0][0];
      } else {
        var match$2 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$1);
        var end_loc$1 = match$2 ? match$2[0] : start_loc;
        Parser_env$Jeason.Eat[/* semicolon */4](env$1);
        end_loc = end_loc$1;
      }
      return /* tuple */[
              Loc$Jeason.btwn(start_loc, end_loc),
              /* Yield */Block.__(14, [/* record */[
                    /* argument */argument,
                    /* delegate */delegate
                  ]])
            ];
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    if (match$1 !== 0) {
      exit = 1;
    } else {
      return assignment_but_not_arrow_function(env);
    }
  }
  if (exit === 1) {
    var match$3 = Parser_env$Jeason.Try[/* to_parse */1](env, try_assignment_but_not_arrow_function);
    if (match$3) {
      return match$3[0];
    } else {
      var match$4 = Parser_env$Jeason.Try[/* to_parse */1](env, try_arrow_function);
      if (match$4) {
        return match$4[0];
      } else {
        return assignment_but_not_arrow_function(env);
      }
    }
  }
  
}

function make_logical(left, right, operator, loc) {
  return /* tuple */[
          loc,
          /* Logical */Block.__(9, [/* record */[
                /* operator */operator,
                /* left */left,
                /* right */right
              ]])
        ];
}

function logical_and(env, _left, _lloc) {
  while(true) {
    var lloc = _lloc;
    var left = _left;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number") {
      if (match !== 82) {
        return /* tuple */[
                lloc,
                left
              ];
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_AND */82);
        var match$1 = with_loc(binary, env);
        var loc = Loc$Jeason.btwn(lloc, match$1[0]);
        _lloc = loc;
        _left = make_logical(left, match$1[1], /* And */1, loc);
        continue ;
        
      }
    } else {
      return /* tuple */[
              lloc,
              left
            ];
    }
  };
}

function logical_or(env, _left, _lloc) {
  while(true) {
    var lloc = _lloc;
    var left = _left;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number") {
      if (match !== 81) {
        return /* tuple */[
                lloc,
                left
              ];
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_OR */81);
        var match$1 = with_loc(binary, env);
        var match$2 = logical_and(env, match$1[1], match$1[0]);
        var loc = Loc$Jeason.btwn(lloc, match$2[0]);
        _lloc = loc;
        _left = make_logical(left, match$2[1], /* Or */0, loc);
        continue ;
        
      }
    } else {
      return /* tuple */[
              lloc,
              left
            ];
    }
  };
}

function logical(env) {
  var match = with_loc(binary, env);
  var match$1 = logical_and(env, match[1], match[0]);
  return logical_or(env, match$1[1], match$1[0])[1];
}

function binary_op(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var ret;
  if (typeof match === "number") {
    var switcher = match - 17 | 0;
    if (switcher === 0 || switcher === 1) {
      ret = switcher !== 0 ? /* Some */[/* tuple */[
            /* Instanceof */21,
            /* Left_assoc */Block.__(0, [6])
          ]] : (
          Parser_env$Jeason.no_in(env) ? /* None */0 : /* Some */[/* tuple */[
                /* In */20,
                /* Left_assoc */Block.__(0, [6])
              ]]
        );
    } else if (switcher >= 66) {
      switch (switcher - 66 | 0) {
        case 0 : 
            ret = /* Some */[/* tuple */[
                /* BitOr */17,
                /* Left_assoc */Block.__(0, [2])
              ]];
            break;
        case 1 : 
            ret = /* Some */[/* tuple */[
                /* Xor */18,
                /* Left_assoc */Block.__(0, [3])
              ]];
            break;
        case 2 : 
            ret = /* Some */[/* tuple */[
                /* BitAnd */19,
                /* Left_assoc */Block.__(0, [4])
              ]];
            break;
        case 3 : 
            ret = /* Some */[/* tuple */[
                /* Equal */0,
                /* Left_assoc */Block.__(0, [5])
              ]];
            break;
        case 4 : 
            ret = /* Some */[/* tuple */[
                /* NotEqual */1,
                /* Left_assoc */Block.__(0, [5])
              ]];
            break;
        case 5 : 
            ret = /* Some */[/* tuple */[
                /* StrictEqual */2,
                /* Left_assoc */Block.__(0, [5])
              ]];
            break;
        case 6 : 
            ret = /* Some */[/* tuple */[
                /* StrictNotEqual */3,
                /* Left_assoc */Block.__(0, [5])
              ]];
            break;
        case 7 : 
            ret = /* Some */[/* tuple */[
                /* LessThanEqual */5,
                /* Left_assoc */Block.__(0, [6])
              ]];
            break;
        case 8 : 
            ret = /* Some */[/* tuple */[
                /* GreaterThanEqual */7,
                /* Left_assoc */Block.__(0, [6])
              ]];
            break;
        case 9 : 
            ret = /* Some */[/* tuple */[
                /* LessThan */4,
                /* Left_assoc */Block.__(0, [6])
              ]];
            break;
        case 10 : 
            ret = /* Some */[/* tuple */[
                /* GreaterThan */6,
                /* Left_assoc */Block.__(0, [6])
              ]];
            break;
        case 11 : 
            ret = /* Some */[/* tuple */[
                /* LShift */8,
                /* Left_assoc */Block.__(0, [7])
              ]];
            break;
        case 12 : 
            ret = /* Some */[/* tuple */[
                /* RShift */9,
                /* Left_assoc */Block.__(0, [7])
              ]];
            break;
        case 13 : 
            ret = /* Some */[/* tuple */[
                /* RShift3 */10,
                /* Left_assoc */Block.__(0, [7])
              ]];
            break;
        case 14 : 
            ret = /* Some */[/* tuple */[
                /* Plus */11,
                /* Left_assoc */Block.__(0, [8])
              ]];
            break;
        case 15 : 
            ret = /* Some */[/* tuple */[
                /* Minus */12,
                /* Left_assoc */Block.__(0, [8])
              ]];
            break;
        case 16 : 
            ret = /* Some */[/* tuple */[
                /* Div */15,
                /* Left_assoc */Block.__(0, [9])
              ]];
            break;
        case 17 : 
            ret = /* Some */[/* tuple */[
                /* Mult */13,
                /* Left_assoc */Block.__(0, [9])
              ]];
            break;
        case 18 : 
            ret = /* Some */[/* tuple */[
                /* Exp */14,
                /* Right_assoc */Block.__(1, [10])
              ]];
            break;
        case 19 : 
            ret = /* Some */[/* tuple */[
                /* Mod */16,
                /* Left_assoc */Block.__(0, [9])
              ]];
            break;
        case 20 : 
        case 21 : 
        case 22 : 
        case 23 : 
        case 24 : 
        case 25 : 
        case 26 : 
        case 27 : 
        case 28 : 
        case 29 : 
        case 30 : 
        case 31 : 
        case 32 : 
        case 33 : 
            ret = /* None */0;
            break;
        
      }
    } else {
      ret = /* None */0;
    }
  } else {
    ret = /* None */0;
  }
  if (ret !== /* None */0) {
    Parser_env$Jeason.Eat[/* token */0](env);
  }
  return ret;
}

function make_binary(left, right, operator, loc) {
  return /* tuple */[
          loc,
          /* Binary */Block.__(6, [/* record */[
                /* operator */operator,
                /* left */left,
                /* right */right
              ]])
        ];
}

function add_to_stack(_right, _param, _rloc, _stack) {
  while(true) {
    var param = _param;
    var stack = _stack;
    var rloc = _rloc;
    var right = _right;
    var rpri = param[1];
    var rop = param[0];
    var exit = 0;
    if (stack) {
      var match = stack[0];
      var match$1 = match[1];
      if (is_tighter(match$1[1], rpri)) {
        var loc = Loc$Jeason.btwn(match[2], rloc);
        var right$1 = make_binary(match[0], right, match$1[0], loc);
        _stack = stack[1];
        _rloc = loc;
        _param = /* tuple */[
          rop,
          rpri
        ];
        _right = right$1;
        continue ;
        
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      return /* :: */[
              /* tuple */[
                right,
                /* tuple */[
                  rop,
                  rpri
                ],
                rloc
              ],
              stack
            ];
    }
    
  };
}

function binary(env) {
  var env$1 = env;
  var _stack = /* [] */0;
  while(true) {
    var stack = _stack;
    var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
    var is_unary = +(peek_unary_op(env$1) !== /* None */0);
    var right = unary(Parser_env$Jeason.with_no_in(/* false */0, env$1));
    var match = Parser_env$Jeason.last_loc(env$1);
    var end_loc = match ? match[0] : right[0];
    var right_loc = Loc$Jeason.btwn(start_loc, end_loc);
    if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1) === /* T_LESS_THAN */92) {
      var tmp = right[1];
      if (typeof tmp !== "number") {
        if (tmp.tag === 21) {
          Parser_env$Jeason.error(env$1, /* AdjacentJSXElements */47);
        }
        
      }
      
    }
    var match$1 = binary_op(env$1);
    if (match$1) {
      var match$2 = match$1[0];
      var rop = match$2[0];
      if (is_unary && rop === /* Exp */14) {
        Parser_env$Jeason.error_at(env$1, /* tuple */[
              right_loc,
              /* InvalidLHSInExponentiation */16
            ]);
      }
      _stack = add_to_stack(right, /* tuple */[
            rop,
            match$2[1]
          ], right_loc, stack);
      continue ;
      
    } else {
      var _right = right;
      var _rloc = right_loc;
      var _param = stack;
      while(true) {
        var param = _param;
        var rloc = _rloc;
        var right$1 = _right;
        if (param) {
          var match$3 = param[0];
          var loc = Loc$Jeason.btwn(match$3[2], rloc);
          _param = param[1];
          _rloc = loc;
          _right = make_binary(match$3[0], right$1, match$3[1][0], loc);
          continue ;
          
        } else {
          return right$1;
        }
      };
    }
  };
}

function argument(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    if (match !== 13) {
      return /* Expression */Block.__(0, [Curry._1(assignment, env)]);
    } else {
      var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_ELLIPSIS */13);
      var argument$1 = Curry._1(assignment, env);
      var loc = Loc$Jeason.btwn(start_loc, argument$1[0]);
      return /* Spread */Block.__(1, [/* tuple */[
                  loc,
                  /* record */[/* argument */argument$1]
                ]]);
    }
  } else {
    return /* Expression */Block.__(0, [Curry._1(assignment, env)]);
  }
}

function arguments$prime(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && !(match !== 6 && match !== 108)) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var acc_000 = argument(env);
      var acc$1 = /* :: */[
        acc_000,
        acc
      ];
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RPAREN */6) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      _acc = acc$1;
      continue ;
      
    }
    
  };
}

function $$arguments(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LPAREN */5);
  var args = arguments$prime(env, /* [] */0);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RPAREN */6);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          args
        ];
}

function template_parts(env, _quasis, _expressions) {
  while(true) {
    var expressions = _expressions;
    var quasis = _quasis;
    var expr = Curry._1(Parse[/* expression */6], env);
    var expressions$1 = /* :: */[
      expr,
      expressions
    ];
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && match === 2) {
      Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* TEMPLATE */4);
      var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
      var match$2;
      if (typeof match$1 === "number") {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "parser_flow.ml",
                1747,
                19
              ]
            ];
      } else if (match$1.tag === 2) {
        var match$3 = match$1[0];
        var tail = match$3[2];
        var match$4 = match$3[1];
        Parser_env$Jeason.Eat[/* token */0](env);
        match$2 = /* tuple */[
          match$3[0],
          /* record */[
            /* value : record */[
              /* raw */match$4[/* raw */1],
              /* cooked */match$4[/* cooked */0]
            ],
            /* tail */tail
          ],
          tail
        ];
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              [
                "parser_flow.ml",
                1747,
                19
              ]
            ];
      }
      var loc = match$2[0];
      Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
      var quasis_000 = /* tuple */[
        loc,
        match$2[1]
      ];
      var quasis$1 = /* :: */[
        quasis_000,
        quasis
      ];
      if (match$2[2]) {
        return /* tuple */[
                loc,
                List.rev(quasis$1),
                List.rev(expressions$1)
              ];
      } else {
        _expressions = expressions$1;
        _quasis = quasis$1;
        continue ;
        
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      Parser_env$Jeason.error_unexpected(env);
      var imaginary_quasi_000 = expr[0];
      var imaginary_quasi_001 = /* record */[
        /* value : record */[
          /* raw */"",
          /* cooked */""
        ],
        /* tail : true */1
      ];
      var imaginary_quasi = /* tuple */[
        imaginary_quasi_000,
        imaginary_quasi_001
      ];
      return /* tuple */[
              expr[0],
              List.rev(/* :: */[
                    imaginary_quasi,
                    quasis
                  ]),
              List.rev(expressions$1)
            ];
    }
    
  };
}

function template_literal(env, part) {
  var is_tail = part[2];
  var match = part[1];
  var start_loc = part[0];
  Parser_env$Jeason.Expect[/* token */0](env, /* T_TEMPLATE_PART */Block.__(2, [part]));
  var head_001 = /* record */[
    /* value : record */[
      /* raw */match[/* raw */1],
      /* cooked */match[/* cooked */0]
    ],
    /* tail */is_tail
  ];
  var head = /* tuple */[
    start_loc,
    head_001
  ];
  var match$1 = is_tail ? /* tuple */[
      start_loc,
      /* :: */[
        head,
        /* [] */0
      ],
      /* [] */0
    ] : template_parts(env, /* :: */[
          head,
          /* [] */0
        ], /* [] */0);
  var loc = Loc$Jeason.btwn(start_loc, match$1[0]);
  return /* tuple */[
          loc,
          /* record */[
            /* quasis */match$1[1],
            /* expressions */match$1[2]
          ]
        ];
}

function elements(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number") {
      if (match >= 14) {
        if (match !== 108) {
          exit = 1;
        } else {
          return List.rev(acc);
        }
      } else if (match >= 8) {
        switch (match - 8 | 0) {
          case 0 : 
              return List.rev(acc);
          case 2 : 
              Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
              _acc = /* :: */[
                /* None */0,
                acc
              ];
              continue ;
              case 1 : 
          case 3 : 
          case 4 : 
              exit = 1;
              break;
          case 5 : 
              var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
              Parser_env$Jeason.Expect[/* token */0](env, /* T_ELLIPSIS */13);
              var argument = Curry._1(assignment, env);
              var loc = Loc$Jeason.btwn(start_loc, argument[0]);
              var elem = /* Spread */Block.__(1, [/* tuple */[
                    loc,
                    /* record */[/* argument */argument]
                  ]]);
              if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RBRACKET */8) {
                Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
              }
              _acc = /* :: */[
                /* Some */[elem],
                acc
              ];
              continue ;
              
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var elem$1 = /* Expression */Block.__(0, [Curry._1(assignment, env)]);
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RBRACKET */8) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      _acc = /* :: */[
        /* Some */[elem$1],
        acc
      ];
      continue ;
      
    }
    
  };
}

function array_initializer(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LBRACKET */7);
  var elements$1 = elements(env, /* [] */0);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* elements */elements$1]
        ];
}

function error_callback$1(_, param) {
  if (typeof param === "number") {
    var switcher = param - 29 | 0;
    if (switcher > 16 || switcher < 0) {
      if (switcher !== 19) {
        throw Parser_env$Jeason.Try[/* Rollback */0];
      } else {
        return /* () */0;
      }
    } else if (switcher > 15 || switcher < 1) {
      return /* () */0;
    } else {
      throw Parser_env$Jeason.Try[/* Rollback */0];
    }
  } else {
    throw Parser_env$Jeason.Try[/* Rollback */0];
  }
}

function try_arrow_function(env) {
  var env$1 = Parser_env$Jeason.with_error_callback(error_callback$1, env);
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
  var async = +(Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env$1) !== /* T_ARROW */12) && Parser_env$Jeason.Expect[/* maybe */1](env$1, /* T_ASYNC */63);
  var typeParameters = Curry._1(type_parameter_declaration$1, env$1);
  var match;
  if (Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, env$1) && typeParameters === /* None */0) {
    var match$1 = Curry._2(Parse[/* identifier */12], /* Some */[/* StrictParamName */29], env$1);
    var loc = match$1[0];
    var param_001 = /* Identifier */Block.__(3, [/* record */[
          /* name : tuple */[
            loc,
            match$1[1]
          ],
          /* typeAnnotation : None */0,
          /* optional : false */0
        ]]);
    var param = /* tuple */[
      loc,
      param_001
    ];
    match = /* tuple */[
      /* tuple */[
        /* :: */[
          param,
          /* [] */0
        ],
        /* None */0
      ],
      /* None */0,
      /* None */0
    ];
  } else {
    var params = function_params(env$1);
    var match$2 = wrap(annotation_and_predicate_opt, Parser_env$Jeason.with_no_anon_function_type(/* true */1, env$1));
    match = /* tuple */[
      params,
      match$2[0],
      match$2[1]
    ];
  }
  var params$1 = match[0];
  var env$2 = params$1[1] || !params$1[0] ? Parser_env$Jeason.without_error_callback(env$1) : env$1;
  if (Parser_env$Jeason.Peek[/* is_line_terminator */5](env$2) && Parser_env$Jeason.Peek[/* token */0](/* None */0, env$2) === /* T_ARROW */12) {
    Parser_env$Jeason.error(env$2, /* NewlineBeforeArrow */45);
  }
  Parser_env$Jeason.Expect[/* token */0](env$2, /* T_ARROW */12);
  var env$3 = Parser_env$Jeason.without_error_callback(env$2);
  var match$3 = with_loc((function (param) {
          var env = param;
          var async$1 = async;
          var generator = /* false */0;
          var env$1 = Parser_env$Jeason.with_in_function(/* true */1, env);
          var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
          var exit = 0;
          if (typeof match === "number" && match === 1) {
            var match$1 = function_body(env$1, async$1, generator);
            return /* tuple */[
                    match$1[1],
                    match$1[2]
                  ];
          } else {
            exit = 1;
          }
          if (exit === 1) {
            var env$2 = Parser_env$Jeason.enter_function(env$1, async$1, generator);
            var expr = Curry._1(Parse[/* assignment */8], env$2);
            return /* tuple */[
                    /* BodyExpression */Block.__(1, [expr]),
                    Parser_env$Jeason.in_strict_mode(env$2)
                  ];
          }
          
        }), env$3);
  var match$4 = match$3[1];
  var body = match$4[0];
  var simple = is_simple_function_params(params$1);
  strict_post_check(env$3, match$4[1], simple, /* None */0, params$1);
  var expression;
  expression = body.tag ? /* true */1 : /* false */0;
  var loc$1 = Loc$Jeason.btwn(start_loc, match$3[0]);
  return /* tuple */[
          loc$1,
          /* ArrowFunction */Block.__(3, [/* record */[
                /* id : None */0,
                /* params */params$1,
                /* body */body,
                /* async */async,
                /* generator : false */0,
                /* predicate */match[2],
                /* expression */expression,
                /* returnType */match[1],
                /* typeParameters */typeParameters
              ]])
        ];
}

function decorator_list_helper(env, _decorators) {
  while(true) {
    var decorators = _decorators;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number" && match === 14) {
      Parser_env$Jeason.Eat[/* token */0](env);
      _decorators = /* :: */[
        left_hand_side(env),
        decorators
      ];
      continue ;
      
    } else {
      return decorators;
    }
  };
}

function decorator_list(env) {
  if (Parser_env$Jeason.parse_options(env)[/* esproposal_decorators */2]) {
    return List.rev(decorator_list_helper(env, /* [] */0));
  } else {
    return /* [] */0;
  }
}

function key(env) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number") {
    if (match === 7) {
      var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_LBRACKET */7);
      var expr = Curry._1(Parse[/* assignment */8], Parser_env$Jeason.with_no_in(/* false */0, env));
      var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
      return /* tuple */[
              Loc$Jeason.btwn(start_loc, end_loc),
              /* Computed */Block.__(2, [expr])
            ];
    } else {
      exit = 1;
    }
  } else {
    switch (match.tag | 0) {
      case 0 : 
          var raw = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
          var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
          var value = number(env, match[0]);
          var value$1 = /* Number */Block.__(2, [value]);
          return /* tuple */[
                  loc,
                  /* Literal */Block.__(0, [/* tuple */[
                        loc,
                        /* record */[
                          /* value */value$1,
                          /* raw */raw
                        ]
                      ]])
                ];
      case 1 : 
          var match$1 = match[0];
          var octal = match$1[3];
          var raw$1 = match$1[2];
          var value$2 = match$1[1];
          var loc$1 = match$1[0];
          if (octal) {
            Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
          }
          Parser_env$Jeason.Expect[/* token */0](env, /* T_STRING */Block.__(1, [/* tuple */[
                    loc$1,
                    value$2,
                    raw$1,
                    octal
                  ]]));
          var value$3 = /* String */Block.__(0, [value$2]);
          return /* tuple */[
                  loc$1,
                  /* Literal */Block.__(0, [/* tuple */[
                        loc$1,
                        /* record */[
                          /* value */value$3,
                          /* raw */raw$1
                        ]
                      ]])
                ];
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    var match$2 = identifier_or_reserved_keyword(env);
    var id = match$2[0];
    return /* tuple */[
            id[0],
            /* Identifier */Block.__(1, [id])
          ];
  }
  
}

function _method(env, kind) {
  var generator = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_MULT */100);
  var match = key(env);
  var key_loc = match[0];
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var typeParameters = kind !== 0 ? /* None */0 : Curry._1(type_parameter_declaration$1, env);
  var params = function_params(env);
  switch (kind) {
    case 0 : 
        break;
    case 1 : 
        if (params[0]) {
          Parser_env$Jeason.error_at(env, /* tuple */[
                key_loc,
                /* GetterArity */62
              ]);
        } else if (params[1]) {
          Parser_env$Jeason.error_at(env, /* tuple */[
                key_loc,
                /* GetterArity */62
              ]);
        }
        break;
    case 2 : 
        var match$1 = params[0];
        var exit = 0;
        if (match$1 && match$1[0][1].tag === 2 && !(match$1[1] || params[1])) {
          Parser_env$Jeason.error_at(env, /* tuple */[
                key_loc,
                /* SetterArity */63
              ]);
        } else {
          exit = 1;
        }
        if (exit === 1) {
          if (params[1]) {
            Parser_env$Jeason.error_at(env, /* tuple */[
                  key_loc,
                  /* SetterArity */63
                ]);
          } else if (match$1) {
            if (match$1[1]) {
              Parser_env$Jeason.error_at(env, /* tuple */[
                    key_loc,
                    /* SetterArity */63
                  ]);
            }
            
          } else {
            Parser_env$Jeason.error_at(env, /* tuple */[
                  key_loc,
                  /* SetterArity */63
                ]);
          }
        }
        break;
    
  }
  var returnType = wrap(annotation_opt, env);
  var match$2 = function_body(env, /* false */0, generator);
  var body = match$2[1];
  var simple = is_simple_function_params(params);
  strict_post_check(env, match$2[2], simple, /* None */0, params);
  var match$3;
  match$3 = body.tag ? /* tuple */[
      body[0][0],
      /* true */1
    ] : /* tuple */[
      body[0][0],
      /* false */0
    ];
  var loc = Loc$Jeason.btwn(start_loc, match$3[0]);
  var value_001 = /* record */[
    /* id : None */0,
    /* params */params,
    /* body */body,
    /* async : false */0,
    /* generator */generator,
    /* predicate : None */0,
    /* expression */match$3[1],
    /* returnType */returnType,
    /* typeParameters */typeParameters
  ];
  var value = /* tuple */[
    loc,
    value_001
  ];
  return /* tuple */[
          match[1],
          value
        ];
}

function property$1(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_ELLIPSIS */13) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_ELLIPSIS */13);
    var argument = Curry._1(Parse[/* assignment */8], env);
    return /* SpreadProperty */Block.__(1, [/* tuple */[
                Loc$Jeason.btwn(start_loc, argument[0]),
                /* record */[/* argument */argument]
              ]]);
  } else {
    var async = Parser_env$Jeason.Peek[/* is_literal_property_name */9](/* Some */[1], env) && Parser_env$Jeason.Expect[/* maybe */1](env, /* T_ASYNC */63);
    var match = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_MULT */100);
    var match$1 = key(env);
    var tmp;
    var exit = 0;
    if (async !== 0 || match !== 0) {
      exit = 1;
    } else {
      var key$1 = match$1[1];
      switch (key$1.tag | 0) {
        case 1 : 
            switch (key$1[0][1]) {
              case "get" : 
                  var match$2 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
                  var exit$1 = 0;
                  if (typeof match$2 === "number") {
                    var switcher = match$2 - 80 | 0;
                    if (switcher > 12 || switcher < 0) {
                      if (switcher >= -69) {
                        tmp = get(env, start_loc);
                      } else {
                        switch (switcher + 80 | 0) {
                          case 0 : 
                          case 1 : 
                          case 3 : 
                          case 4 : 
                          case 6 : 
                          case 7 : 
                          case 8 : 
                          case 9 : 
                              tmp = get(env, start_loc);
                              break;
                          case 2 : 
                          case 5 : 
                          case 10 : 
                              exit$1 = 2;
                              break;
                          
                        }
                      }
                    } else if (switcher > 11 || switcher < 1) {
                      exit$1 = 2;
                    } else {
                      tmp = get(env, start_loc);
                    }
                  } else {
                    tmp = get(env, start_loc);
                  }
                  if (exit$1 === 2) {
                    tmp = init(env, start_loc, key$1, /* false */0, /* false */0);
                  }
                  break;
              case "set" : 
                  var match$3 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
                  var exit$2 = 0;
                  if (typeof match$3 === "number") {
                    var switcher$1 = match$3 - 80 | 0;
                    if (switcher$1 > 12 || switcher$1 < 0) {
                      if (switcher$1 >= -69) {
                        tmp = set(env, start_loc);
                      } else {
                        switch (switcher$1 + 80 | 0) {
                          case 0 : 
                          case 1 : 
                          case 3 : 
                          case 4 : 
                          case 6 : 
                          case 7 : 
                          case 8 : 
                          case 9 : 
                              tmp = set(env, start_loc);
                              break;
                          case 2 : 
                          case 5 : 
                          case 10 : 
                              exit$2 = 2;
                              break;
                          
                        }
                      }
                    } else if (switcher$1 > 11 || switcher$1 < 1) {
                      exit$2 = 2;
                    } else {
                      tmp = set(env, start_loc);
                    }
                  } else {
                    tmp = set(env, start_loc);
                  }
                  if (exit$2 === 2) {
                    tmp = init(env, start_loc, key$1, /* false */0, /* false */0);
                  }
                  break;
              default:
                exit = 1;
            }
            break;
        case 0 : 
        case 2 : 
            exit = 1;
            break;
        
      }
    }
    if (exit === 1) {
      tmp = init(env, start_loc, match$1[1], async, match);
    }
    return /* Property */Block.__(0, [tmp]);
  }
}

function get(env, start_loc) {
  var match = _method(env, /* Get */1);
  var match$1 = match[1];
  var end_loc = match$1[0];
  var value_001 = /* Function */Block.__(2, [match$1[1]]);
  var value = /* tuple */[
    end_loc,
    value_001
  ];
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[
            /* key */match[0],
            /* value */value,
            /* kind : Get */1,
            /* _method : false */0,
            /* shorthand : false */0
          ]
        ];
}

function set(env, start_loc) {
  var match = _method(env, /* Set */2);
  var match$1 = match[1];
  var end_loc = match$1[0];
  var value_001 = /* Function */Block.__(2, [match$1[1]]);
  var value = /* tuple */[
    end_loc,
    value_001
  ];
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[
            /* key */match[0],
            /* value */value,
            /* kind : Set */2,
            /* _method : false */0,
            /* shorthand : false */0
          ]
        ];
}

function init(env, start_loc, key, async, generator) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var match$1;
  var exit = 0;
  if (typeof match === "number") {
    if (match !== 92) {
      if (match >= 11) {
        exit = 1;
      } else {
        switch (match) {
          case 5 : 
              exit = 3;
              break;
          case 0 : 
          case 1 : 
          case 3 : 
          case 4 : 
          case 6 : 
          case 7 : 
          case 8 : 
          case 9 : 
              exit = 1;
              break;
          case 2 : 
          case 10 : 
              exit = 2;
              break;
          
        }
      }
    } else {
      exit = 3;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 : 
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
        match$1 = /* tuple */[
          Curry._1(Parse[/* assignment */8], env),
          /* false */0,
          /* false */0
        ];
        break;
    case 2 : 
        var tmp;
        switch (key.tag | 0) {
          case 0 : 
              var lit = key[0];
              tmp = /* tuple */[
                lit[0],
                /* Literal */Block.__(18, [lit[1]])
              ];
              break;
          case 1 : 
              var id = key[0];
              tmp = /* tuple */[
                id[0],
                /* Identifier */Block.__(17, [id])
              ];
              break;
          case 2 : 
              tmp = key[0];
              break;
          
        }
        match$1 = /* tuple */[
          tmp,
          /* true */1,
          /* false */0
        ];
        break;
    case 3 : 
        var start_loc$1 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
        var typeParameters = Curry._1(type_parameter_declaration$1, env);
        var params = function_params(env);
        var returnType = wrap(annotation_opt, env);
        var match$2 = function_body(env, async, generator);
        var body = match$2[1];
        var simple = is_simple_function_params(params);
        strict_post_check(env, match$2[2], simple, /* None */0, params);
        var match$3;
        match$3 = body.tag ? /* tuple */[
            body[0][0],
            /* true */1
          ] : /* tuple */[
            body[0][0],
            /* false */0
          ];
        var loc = Loc$Jeason.btwn(start_loc$1, match$3[0]);
        var value_001 = /* Function */Block.__(2, [/* record */[
              /* id : None */0,
              /* params */params,
              /* body */body,
              /* async */async,
              /* generator */generator,
              /* predicate : None */0,
              /* expression */match$3[1],
              /* returnType */returnType,
              /* typeParameters */typeParameters
            ]]);
        var value = /* tuple */[
          loc,
          value_001
        ];
        match$1 = /* tuple */[
          value,
          /* false */0,
          /* true */1
        ];
        break;
    
  }
  var value$1 = match$1[0];
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, value$1[0]),
          /* record */[
            /* key */key,
            /* value */value$1,
            /* kind : Init */0,
            /* _method */match$1[2],
            /* shorthand */match$1[1]
          ]
        ];
}

function properties$1(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && !(match !== 2 && match !== 108)) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var prop = property$1(env);
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RCURLY */2) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      _acc = /* :: */[
        prop,
        acc
      ];
      continue ;
      
    }
    
  };
}

function _initializer(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
  var props = properties$1(env, /* [] */0);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* properties */props]
        ];
}

function class_implements(env, _acc) {
  while(true) {
    var acc = _acc;
    var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
    var typeParameters = wrap(type_parameter_instantiation, env);
    var loc = typeParameters ? Loc$Jeason.btwn(id[0], typeParameters[0][0]) : id[0];
    var implement_001 = /* record */[
      /* id */id,
      /* typeParameters */typeParameters
    ];
    var implement = /* tuple */[
      loc,
      implement_001
    ];
    var acc$1 = /* :: */[
      implement,
      acc
    ];
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number" && match === 10) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      _acc = acc$1;
      continue ;
      
    } else {
      return List.rev(acc$1);
    }
  };
}

function error_unsupported_variance$1(env, param) {
  if (param) {
    return Parser_env$Jeason.error_at(env, /* tuple */[
                param[0][0],
                /* UnexpectedVariance */5
              ]);
  } else {
    return /* () */0;
  }
}

function init$1(env, start_loc, decorators, key, async, generator, $$static, variance) {
  while(true) {
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    var exit$1 = 0;
    if (typeof match === "number") {
      var switcher = match - 78 | 0;
      if (switcher > 2 || switcher < 0) {
        if (switcher !== -69) {
          exit = 1;
        } else {
          exit$1 = 2;
        }
      } else if (switcher !== 1) {
        exit$1 = 2;
      } else {
        Parser_env$Jeason.error_unexpected(env);
        Parser_env$Jeason.Eat[/* token */0](env);
        continue ;
        
      }
    } else {
      exit = 1;
    }
    if (exit$1 === 2) {
      if (!async && !generator) {
        var typeAnnotation = wrap(annotation_opt, env);
        var options = Parser_env$Jeason.parse_options(env);
        var value = Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_ASSIGN */78 && ($$static && options[/* esproposal_class_static_fields */1] || !$$static && options[/* esproposal_class_instance_fields */0]) ? (Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78), /* Some */[Curry._1(Parse[/* expression */6], env)]) : /* None */0;
        var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
        if (!Parser_env$Jeason.Expect[/* maybe */1](env, /* T_SEMICOLON */9)) {
          if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LBRACKET */7 || Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_LPAREN */5) {
            Parser_env$Jeason.error_unexpected(env);
          }
          
        }
        var loc = Loc$Jeason.btwn(start_loc, end_loc);
        return /* Property */Block.__(1, [/* tuple */[
                    loc,
                    /* record */[
                      /* key */key,
                      /* value */value,
                      /* typeAnnotation */typeAnnotation,
                      /* static */$$static,
                      /* variance */variance
                    ]
                  ]]);
      } else {
        exit = 1;
      }
    }
    if (exit === 1) {
      error_unsupported_variance$1(env, variance);
      var func_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      var typeParameters = Curry._1(type_parameter_declaration$1, env);
      var params = function_params(env);
      var returnType = wrap(annotation_opt, env);
      var match$1 = function_body(env, async, generator);
      var body = match$1[1];
      var simple = is_simple_function_params(params);
      strict_post_check(env, match$1[2], simple, /* None */0, params);
      var match$2;
      match$2 = body.tag ? /* tuple */[
          body[0][0],
          /* true */1
        ] : /* tuple */[
          body[0][0],
          /* false */0
        ];
      var end_loc$1 = match$2[0];
      var loc$1 = Loc$Jeason.btwn(func_loc, end_loc$1);
      var value_001 = /* record */[
        /* id : None */0,
        /* params */params,
        /* body */body,
        /* async */async,
        /* generator */generator,
        /* predicate : None */0,
        /* expression */match$2[1],
        /* returnType */returnType,
        /* typeParameters */typeParameters
      ];
      var value$1 = /* tuple */[
        loc$1,
        value_001
      ];
      var kind;
      switch (key.tag | 0) {
        case 0 : 
            var match$3 = key[0][1][/* value */0];
            kind = typeof match$3 === "number" || !(!match$3.tag && match$3[0] === "constructor") ? /* Method */1 : /* Constructor */0;
            break;
        case 1 : 
            kind = key[0][1] === "constructor" ? /* Constructor */0 : /* Method */1;
            break;
        case 2 : 
            kind = /* Method */1;
            break;
        
      }
      return /* Method */Block.__(0, [/* tuple */[
                  Loc$Jeason.btwn(start_loc, end_loc$1),
                  /* record */[
                    /* kind */kind,
                    /* key */key,
                    /* value */value$1,
                    /* static */$$static,
                    /* decorators */decorators
                  ]
                ]]);
    }
    
  };
}

function class_element(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var decorators = decorator_list(env);
  var $$static = +(Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) !== /* T_LPAREN */5) && +(Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) !== /* T_LESS_THAN */92) && Parser_env$Jeason.Expect[/* maybe */1](env, /* T_STATIC */42);
  var async = +(Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) !== /* T_LPAREN */5) && +(Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) !== /* T_COLON */80) && Parser_env$Jeason.Expect[/* maybe */1](env, /* T_ASYNC */63);
  var generator = Parser_env$Jeason.Expect[/* maybe */1](env, /* T_MULT */100);
  var variance$2 = variance$1(env, async, generator);
  var generator$1 = generator !== 0 || !variance$2 ? generator : Parser_env$Jeason.Expect[/* maybe */1](env, /* T_MULT */100);
  var match = key(env);
  var exit = 0;
  if (async !== 0 || generator$1 !== 0) {
    exit = 1;
  } else {
    var key$1 = match[1];
    switch (key$1.tag | 0) {
      case 1 : 
          switch (key$1[0][1]) {
            case "get" : 
                var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
                var exit$1 = 0;
                exit$1 = typeof match$1 === "number" ? (
                    match$1 >= 78 ? (
                        match$1 >= 81 ? (
                            match$1 !== 92 ? 2 : 3
                          ) : (
                            match$1 !== 79 ? 3 : 2
                          )
                      ) : (
                        match$1 !== 5 && match$1 !== 9 ? 2 : 3
                      )
                  ) : 2;
                switch (exit$1) {
                  case 2 : 
                      error_unsupported_variance$1(env, variance$2);
                      var env$1 = env;
                      var start_loc$1 = start_loc;
                      var decorators$1 = decorators;
                      var $$static$1 = $$static;
                      var match$2 = _method(env$1, /* Get */1);
                      var value = match$2[1];
                      return /* Method */Block.__(0, [/* tuple */[
                                  Loc$Jeason.btwn(start_loc$1, value[0]),
                                  /* record */[
                                    /* kind : Get */2,
                                    /* key */match$2[0],
                                    /* value */value,
                                    /* static */$$static$1,
                                    /* decorators */decorators$1
                                  ]
                                ]]);
                  case 3 : 
                      return init$1(env, start_loc, decorators, key$1, async, generator$1, $$static, variance$2);
                  
                }
                break;
            case "set" : 
                var match$3 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
                var exit$2 = 0;
                exit$2 = typeof match$3 === "number" ? (
                    match$3 >= 78 ? (
                        match$3 >= 81 ? (
                            match$3 !== 92 ? 2 : 3
                          ) : (
                            match$3 !== 79 ? 3 : 2
                          )
                      ) : (
                        match$3 !== 5 && match$3 !== 9 ? 2 : 3
                      )
                  ) : 2;
                switch (exit$2) {
                  case 2 : 
                      error_unsupported_variance$1(env, variance$2);
                      var env$2 = env;
                      var start_loc$2 = start_loc;
                      var decorators$2 = decorators;
                      var $$static$2 = $$static;
                      var match$4 = _method(env$2, /* Set */2);
                      var value$1 = match$4[1];
                      return /* Method */Block.__(0, [/* tuple */[
                                  Loc$Jeason.btwn(start_loc$2, value$1[0]),
                                  /* record */[
                                    /* kind : Set */3,
                                    /* key */match$4[0],
                                    /* value */value$1,
                                    /* static */$$static$2,
                                    /* decorators */decorators$2
                                  ]
                                ]]);
                  case 3 : 
                      return init$1(env, start_loc, decorators, key$1, async, generator$1, $$static, variance$2);
                  
                }
                break;
            default:
              exit = 1;
          }
          break;
      case 0 : 
      case 2 : 
          exit = 1;
          break;
      
    }
  }
  if (exit === 1) {
    return init$1(env, start_loc, decorators, match[1], async, generator$1, $$static, variance$2);
  }
  
}

function elements$1(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number") {
      var switcher = match - 3 | 0;
      if (switcher > 104 || switcher < 0) {
        if ((switcher + 1 >>> 0) > 106) {
          exit = 1;
        } else {
          return List.rev(acc);
        }
      } else if (switcher !== 6) {
        exit = 1;
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_SEMICOLON */9);
        continue ;
        
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      _acc = /* :: */[
        Curry._1(class_element, env),
        acc
      ];
      continue ;
      
    }
    
  };
}

function class_body(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
  var body = elements$1(env, /* [] */0);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* body */body]
        ];
}

function _class(env) {
  var match;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_EXTENDS */41) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_EXTENDS */41);
    var superClass = left_hand_side(Parser_env$Jeason.with_allow_yield(/* false */0, env));
    var superTypeParameters = wrap(type_parameter_instantiation, env);
    match = /* tuple */[
      /* Some */[superClass],
      superTypeParameters
    ];
  } else {
    match = /* tuple */[
      /* None */0,
      /* None */0
    ];
  }
  var $$implements;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_IMPLEMENTS */52) {
    if (!Parser_env$Jeason.should_parse_types(env)) {
      Parser_env$Jeason.error(env, /* UnexpectedTypeInterface */11);
    }
    Parser_env$Jeason.Expect[/* token */0](env, /* T_IMPLEMENTS */52);
    $$implements = class_implements(env, /* [] */0);
  } else {
    $$implements = /* [] */0;
  }
  var body = Curry._1(class_body, env);
  return /* tuple */[
          body,
          match[0],
          match[1],
          $$implements
        ];
}

function class_declaration(env, decorators) {
  var env$1 = Parser_env$Jeason.with_strict(/* true */1, env);
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
  var decorators$1 = Pervasives.$at(decorators, decorator_list(env$1));
  Parser_env$Jeason.Expect[/* token */0](env$1, /* T_CLASS */40);
  var tmp_env = Parser_env$Jeason.with_no_let(/* true */1, env$1);
  var match = Parser_env$Jeason.in_export(env$1);
  var match$1 = Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, tmp_env);
  var id = match !== 0 ? (
      match$1 !== 0 ? /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, tmp_env)] : /* None */0
    ) : /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, tmp_env)];
  var typeParameters = Curry._1(type_parameter_declaration_with_defaults, env$1);
  var match$2 = _class(env$1);
  var body = match$2[0];
  var loc = Loc$Jeason.btwn(start_loc, body[0]);
  return /* tuple */[
          loc,
          /* ClassDeclaration */Block.__(19, [/* record */[
                /* id */id,
                /* body */body,
                /* superClass */match$2[1],
                /* typeParameters */typeParameters,
                /* superTypeParameters */match$2[2],
                /* implements */match$2[3],
                /* classDecorators */decorators$1
              ]])
        ];
}

function class_expression(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var decorators = decorator_list(env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_CLASS */40);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var match$1;
  var exit = 0;
  if (typeof match === "number") {
    var switcher = match - 1 | 0;
    if (switcher > 40 || switcher < 0) {
      if (switcher !== 91) {
        exit = 1;
      } else {
        match$1 = /* tuple */[
          /* None */0,
          /* None */0
        ];
      }
    } else if (switcher > 39 || switcher < 1) {
      match$1 = /* tuple */[
        /* None */0,
        /* None */0
      ];
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var id = /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, env)];
    var typeParameters = Curry._1(type_parameter_declaration_with_defaults, env);
    match$1 = /* tuple */[
      id,
      typeParameters
    ];
  }
  var match$2 = _class(env);
  var body = match$2[0];
  var loc = Loc$Jeason.btwn(start_loc, body[0]);
  return /* tuple */[
          loc,
          /* Class */Block.__(22, [/* record */[
                /* id */match$1[0],
                /* body */body,
                /* superClass */match$2[1],
                /* typeParameters */match$1[1],
                /* superTypeParameters */match$2[2],
                /* implements */match$2[3],
                /* classDecorators */decorators
              ]])
        ];
}

function declare_var_statement(env, start_loc) {
  var match = declare_var(env, start_loc);
  return /* tuple */[
          match[0],
          /* DeclareVariable */Block.__(21, [match[1]])
        ];
}

function $$interface(env) {
  if (Parser_env$Jeason.Peek[/* is_identifier */8](/* Some */[1], env)) {
    var match = Curry._1(interface_helper, env);
    return /* tuple */[
            match[0],
            /* InterfaceDeclaration */Block.__(20, [match[1]])
          ];
  } else {
    return expression(env);
  }
}

function type_alias(env) {
  if (Parser_env$Jeason.Peek[/* is_identifier */8](/* Some */[1], env)) {
    var match = type_alias_helper(env);
    return /* tuple */[
            match[0],
            /* TypeAlias */Block.__(7, [match[1]])
          ];
  } else {
    return Curry._1(Parse[/* statement */1], env);
  }
}

function declare_export_declaration($staropt$star, env) {
  var allow_export_type = $staropt$star ? $staropt$star[0] : /* false */0;
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeDeclaration */8);
  }
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
  var env$1 = Parser_env$Jeason.with_in_export(/* true */1, Parser_env$Jeason.with_strict(/* true */1, env));
  Parser_env$Jeason.Expect[/* token */0](env$1, /* T_EXPORT */49);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
  var exit = 0;
  if (typeof match === "number") {
    if (match >= 54) {
      if (match !== 61) {
        if (match !== 100) {
          exit = 1;
        } else {
          var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
          Parser_env$Jeason.Expect[/* token */0](env$1, /* T_MULT */100);
          var parse_export_star_as = Parser_env$Jeason.parse_options(env$1)[/* esproposal_export_star_as */3];
          var local_name = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$1) === "as" ? (Parser_env$Jeason.Expect[/* contextual */2](env$1, "as"), parse_export_star_as ? /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, env$1)] : (Parser_env$Jeason.error(env$1, /* UnexpectedTypeDeclaration */8), /* None */0)) : /* None */0;
          var specifiers = /* Some */[/* ExportBatchSpecifier */Block.__(1, [
                loc,
                local_name
              ])];
          var source = export_source(env$1);
          var match$1 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$1);
          var end_loc = match$1 ? match$1[0] : source[0];
          var source$1 = /* Some */[source];
          Parser_env$Jeason.Eat[/* semicolon */4](env$1);
          return /* tuple */[
                  Loc$Jeason.btwn(start_loc, end_loc),
                  /* DeclareExportDeclaration */Block.__(26, [/* record */[
                        /* default : false */0,
                        /* declaration : None */0,
                        /* specifiers */specifiers,
                        /* source */source$1
                      ]])
                ];
        }
      } else if (allow_export_type) {
        var match$2 = type_alias_helper(env$1);
        var alias_loc = match$2[0];
        var loc$1 = Loc$Jeason.btwn(start_loc, alias_loc);
        return /* tuple */[
                loc$1,
                /* DeclareExportDeclaration */Block.__(26, [/* record */[
                      /* default : false */0,
                      /* declaration : Some */[/* NamedType */Block.__(4, [/* tuple */[
                              alias_loc,
                              match$2[1]
                            ]])],
                      /* specifiers : None */0,
                      /* source : None */0
                    ]])
              ];
      } else {
        exit = 1;
      }
    } else if (match >= 41) {
      if (match >= 53 && allow_export_type) {
        var match$3 = Curry._1(interface_helper, env$1);
        var iface_loc = match$3[0];
        var loc$2 = Loc$Jeason.btwn(start_loc, iface_loc);
        return /* tuple */[
                loc$2,
                /* DeclareExportDeclaration */Block.__(26, [/* record */[
                      /* default : false */0,
                      /* declaration : Some */[/* Interface */Block.__(5, [/* tuple */[
                              iface_loc,
                              match$3[1]
                            ]])],
                      /* specifiers : None */0,
                      /* source : None */0
                    ]])
              ];
      } else {
        exit = 1;
      }
    } else if (match >= 15) {
      switch (match - 15 | 0) {
        case 21 : 
            Parser_env$Jeason.Expect[/* token */0](env$1, /* T_DEFAULT */36);
            var match$4 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
            var match$5;
            var exit$1 = 0;
            if (typeof match$4 === "number") {
              if (match$4 !== 15) {
                if (match$4 !== 40) {
                  exit$1 = 3;
                } else {
                  var _class = Curry._2(declare_class, env$1, start_loc);
                  match$5 = /* tuple */[
                    _class[0],
                    /* Some */[/* Class */Block.__(2, [_class])]
                  ];
                }
              } else {
                var fn = declare_function(env$1, start_loc);
                match$5 = /* tuple */[
                  fn[0],
                  /* Some */[/* Function */Block.__(1, [fn])]
                ];
              }
            } else {
              exit$1 = 3;
            }
            if (exit$1 === 3) {
              var _type$1 = wrap(_type, env$1);
              var match$6 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$1);
              var end_loc$1 = match$6 ? match$6[0] : _type$1[0];
              Parser_env$Jeason.Eat[/* semicolon */4](env$1);
              match$5 = /* tuple */[
                end_loc$1,
                /* Some */[/* DefaultType */Block.__(3, [_type$1])]
              ];
            }
            return /* tuple */[
                    Loc$Jeason.btwn(start_loc, match$5[0]),
                    /* DeclareExportDeclaration */Block.__(26, [/* record */[
                          /* default : true */1,
                          /* declaration */match$5[1],
                          /* specifiers : None */0,
                          /* source : None */0
                        ]])
                  ];
        case 1 : 
        case 2 : 
        case 3 : 
        case 4 : 
        case 5 : 
        case 6 : 
        case 7 : 
        case 8 : 
        case 10 : 
        case 11 : 
        case 14 : 
        case 15 : 
        case 16 : 
        case 17 : 
        case 18 : 
        case 19 : 
        case 20 : 
        case 22 : 
        case 23 : 
        case 24 : 
            exit = 1;
            break;
        case 0 : 
        case 9 : 
        case 12 : 
        case 13 : 
        case 25 : 
            exit = 2;
            break;
        
      }
    } else {
      exit = 1;
    }
  } else {
    exit = 1;
  }
  switch (exit) {
    case 1 : 
        var match$7 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
        if (typeof match$7 === "number") {
          if (match$7 !== 53) {
            if (match$7 !== 61) {
              
            } else {
              Parser_env$Jeason.error(env$1, /* DeclareExportType */52);
            }
          } else {
            Parser_env$Jeason.error(env$1, /* DeclareExportInterface */53);
          }
        }
        Parser_env$Jeason.Expect[/* token */0](env$1, /* T_LCURLY */1);
        var match$8 = export_specifiers_and_errs(env$1, /* [] */0, /* [] */0);
        var specifiers$1 = /* Some */[/* ExportSpecifiers */Block.__(0, [match$8[0]])];
        var end_loc$2 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
        Parser_env$Jeason.Expect[/* token */0](env$1, /* T_RCURLY */2);
        var source$2 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$1) === "from" ? /* Some */[export_source(env$1)] : (List.iter((function (param) {
                    return Parser_env$Jeason.error_at(env$1, param);
                  }), match$8[1]), /* None */0);
        var match$9 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$1);
        var end_loc$3 = match$9 ? match$9[0] : (
            source$2 ? source$2[0][0] : end_loc$2
          );
        Parser_env$Jeason.Eat[/* semicolon */4](env$1);
        return /* tuple */[
                Loc$Jeason.btwn(start_loc, end_loc$3),
                /* DeclareExportDeclaration */Block.__(26, [/* record */[
                      /* default : false */0,
                      /* declaration : None */0,
                      /* specifiers */specifiers$1,
                      /* source */source$2
                    ]])
              ];
    case 2 : 
        var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
        var match$10;
        var exit$2 = 0;
        if (typeof token === "number") {
          if (token >= 25) {
            if (token >= 29) {
              if (token !== 40) {
                exit$2 = 3;
              } else {
                var _class$1 = Curry._2(declare_class, env$1, start_loc);
                match$10 = /* tuple */[
                  _class$1[0],
                  /* Some */[/* Class */Block.__(2, [_class$1])]
                ];
              }
            } else {
              exit$2 = token >= 27 ? 4 : 3;
            }
          } else if (token !== 15) {
            exit$2 = token >= 24 ? 4 : 3;
          } else {
            var fn$1 = declare_function(env$1, start_loc);
            match$10 = /* tuple */[
              fn$1[0],
              /* Some */[/* Function */Block.__(1, [fn$1])]
            ];
          }
        } else {
          exit$2 = 3;
        }
        switch (exit$2) {
          case 3 : 
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "parser_flow.ml",
                      3593,
                      17
                    ]
                  ];
          case 4 : 
              if (typeof token === "number") {
                if (token !== 27) {
                  if (token !== 28) {
                    
                  } else {
                    Parser_env$Jeason.error(env$1, /* DeclareExportLet */50);
                  }
                } else {
                  Parser_env$Jeason.error(env$1, /* DeclareExportConst */51);
                }
              }
              var $$var = declare_var(env$1, start_loc);
              match$10 = /* tuple */[
                $$var[0],
                /* Some */[/* Variable */Block.__(0, [$$var])]
              ];
              break;
          
        }
        return /* tuple */[
                Loc$Jeason.btwn(start_loc, match$10[0]),
                /* DeclareExportDeclaration */Block.__(26, [/* record */[
                      /* default : false */0,
                      /* declaration */match$10[1],
                      /* specifiers : None */0,
                      /* source : None */0
                    ]])
              ];
    
  }
}

function declare_function_statement(env, start_loc) {
  var match = declare_function(env, start_loc);
  return /* tuple */[
          match[0],
          /* DeclareFunction */Block.__(22, [match[1]])
        ];
}

function declare_var(env, start_loc) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_VAR */24);
  var match = Curry._3(Parse[/* identifier_with_type */14], env, /* Some */[/* true */1], /* StrictVarName */28);
  var match$1 = match[1];
  var match$2 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env);
  var end_loc = match$2 ? match$2[0] : match[0];
  var loc = Loc$Jeason.btwn(start_loc, end_loc);
  Parser_env$Jeason.Eat[/* semicolon */4](env);
  return /* tuple */[
          loc,
          /* record */[
            /* id */match$1[/* name */0],
            /* typeAnnotation */match$1[/* typeAnnotation */1]
          ]
        ];
}

function type_alias_helper(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeAlias */6);
  }
  Parser_env$Jeason.Expect[/* token */0](env, /* T_TYPE */61);
  Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* TYPE */1);
  var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
  var typeParameters = Curry._1(type_parameter_declaration_with_defaults, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78);
  var right = wrap(_type, env);
  var match = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env);
  var end_loc = match ? match[0] : right[0];
  Parser_env$Jeason.Eat[/* semicolon */4](env);
  Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[
            /* id */id,
            /* typeParameters */typeParameters,
            /* right */right
          ]
        ];
}

function export_source(env) {
  Parser_env$Jeason.Expect[/* contextual */2](env, "from");
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 1) {
    exit = 1;
  } else {
    var match$1 = match[0];
    var octal = match$1[3];
    var raw = match$1[2];
    var value = match$1[1];
    var loc = match$1[0];
    if (octal) {
      Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
    }
    Parser_env$Jeason.Expect[/* token */0](env, /* T_STRING */Block.__(1, [/* tuple */[
              loc,
              value,
              raw,
              octal
            ]]));
    var value$1 = /* String */Block.__(0, [value]);
    return /* tuple */[
            loc,
            /* record */[
              /* value */value$1,
              /* raw */raw
            ]
          ];
  }
  if (exit === 1) {
    var raw$1 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
    var value$2 = /* String */Block.__(0, [raw$1]);
    var ret_000 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    var ret_001 = /* record */[
      /* value */value$2,
      /* raw */raw$1
    ];
    var ret = /* tuple */[
      ret_000,
      ret_001
    ];
    Parser_env$Jeason.error_unexpected(env);
    return ret;
  }
  
}

function declare_function(env, start_loc) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_FUNCTION */15);
  var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
  var start_sig_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var typeParameters = Curry._1(type_parameter_declaration$1, env);
  var params = wrap(function_param_list, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
  var returnType = wrap(_type, env);
  var end_loc = returnType[0];
  var predicate = wrap(predicate_opt, env);
  var loc = Loc$Jeason.btwn(start_sig_loc, end_loc);
  var typeAnnotation_001 = /* Function */Block.__(1, [/* record */[
        /* params */params,
        /* returnType */returnType,
        /* typeParameters */typeParameters
      ]]);
  var typeAnnotation = /* tuple */[
    loc,
    typeAnnotation_001
  ];
  var typeAnnotation$1 = /* tuple */[
    loc,
    typeAnnotation
  ];
  var id_000 = Loc$Jeason.btwn(id[0], end_loc);
  var id_001 = id[1];
  var id$1 = /* tuple */[
    id_000,
    id_001
  ];
  var match = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env);
  var end_loc$1 = match ? match[0] : end_loc;
  Parser_env$Jeason.Eat[/* semicolon */4](env);
  var loc$1 = Loc$Jeason.btwn(start_loc, end_loc$1);
  return /* tuple */[
          loc$1,
          /* record */[
            /* id */id$1,
            /* typeAnnotation */typeAnnotation$1,
            /* predicate */predicate
          ]
        ];
}

function export_specifiers_and_errs(env, _specifiers, _errs) {
  while(true) {
    var errs = _errs;
    var specifiers = _specifiers;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number") {
      if (match !== 2) {
        if (match !== 108) {
          exit = 1;
        } else {
          return /* tuple */[
                  List.rev(specifiers),
                  List.rev(errs)
                ];
        }
      } else {
        return /* tuple */[
                List.rev(specifiers),
                List.rev(errs)
              ];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$1 = Curry._1(Parse[/* identifier_or_reserved_keyword */13], env);
      var local = match$1[0];
      var match$2;
      if (Parser_env$Jeason.Peek[/* value */1](/* None */0, env) === "as") {
        Parser_env$Jeason.Expect[/* contextual */2](env, "as");
        var match$3 = Curry._1(Parse[/* identifier_or_reserved_keyword */13], env);
        var name = match$3[0];
        Parser_env$Jeason.record_export(env, /* tuple */[
              name[0],
              extract_ident_name(name)
            ]);
        match$2 = /* tuple */[
          /* Some */[name],
          /* None */0,
          name[0]
        ];
      } else {
        var loc = local[0];
        Parser_env$Jeason.record_export(env, /* tuple */[
              loc,
              extract_ident_name(local)
            ]);
        match$2 = /* tuple */[
          /* None */0,
          match$1[1],
          loc
        ];
      }
      var err = match$2[1];
      var loc$1 = Loc$Jeason.btwn(local[0], match$2[2]);
      var specifier_001 = /* record */[
        /* local */local,
        /* exported */match$2[0]
      ];
      var specifier = /* tuple */[
        loc$1,
        specifier_001
      ];
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COMMA */10) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      var errs$1 = err ? /* :: */[
          err[0],
          errs
        ] : errs;
      _errs = errs$1;
      _specifiers = /* :: */[
        specifier,
        specifiers
      ];
      continue ;
      
    }
    
  };
}

function extract_ident_name(param) {
  return param[1];
}

function declare($staropt$star, env) {
  var in_module = $staropt$star ? $staropt$star[0] : /* false */0;
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeDeclaration */8);
  }
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env);
  var exit = 0;
  if (typeof match === "number") {
    if (match >= 24) {
      if (match >= 40) {
        if (match >= 64) {
          exit = 1;
        } else {
          switch (match - 40 | 0) {
            case 0 : 
                Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
                var env$1 = env;
                var start_loc$1 = start_loc;
                var match$1 = Curry._2(declare_class, env$1, start_loc$1);
                return /* tuple */[
                        match$1[0],
                        /* DeclareClass */Block.__(23, [match$1[1]])
                      ];
            case 9 : 
                if (in_module) {
                  return declare_export_declaration(/* Some */[in_module], env);
                } else {
                  exit = 1;
                }
                break;
            case 13 : 
                Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
                return $$interface(env);
            case 21 : 
                Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
                return type_alias(env);
            case 1 : 
            case 2 : 
            case 3 : 
            case 4 : 
            case 5 : 
            case 6 : 
            case 7 : 
            case 8 : 
            case 10 : 
            case 11 : 
            case 12 : 
            case 14 : 
            case 15 : 
            case 16 : 
            case 17 : 
            case 18 : 
            case 19 : 
            case 20 : 
            case 22 : 
                exit = 1;
                break;
            case 23 : 
                Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
                Parser_env$Jeason.error(env, /* DeclareAsync */49);
                Parser_env$Jeason.Expect[/* token */0](env, /* T_ASYNC */63);
                return declare_function_statement(env, start_loc);
            
          }
        }
      } else if (match >= 25) {
        exit = 1;
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
        return declare_var_statement(env, start_loc);
      }
    } else if (match !== 15) {
      if (match !== 0 || Parser_env$Jeason.Peek[/* value */1](/* Some */[1], env) !== "module") {
        exit = 1;
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
        Parser_env$Jeason.Expect[/* contextual */2](env, "module");
        if (in_module || Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_PERIOD */11) {
          var env$2 = env;
          var start_loc$2 = start_loc;
          Parser_env$Jeason.Expect[/* token */0](env$2, /* T_PERIOD */11);
          Parser_env$Jeason.Expect[/* contextual */2](env$2, "exports");
          var type_annot = wrap(annotation, env$2);
          var match$2 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$2);
          var end_loc = match$2 ? match$2[0] : type_annot[0];
          Parser_env$Jeason.Eat[/* semicolon */4](env$2);
          var loc = Loc$Jeason.btwn(start_loc$2, end_loc);
          return /* tuple */[
                  loc,
                  /* DeclareModuleExports */Block.__(25, [type_annot])
                ];
        } else {
          var env$3 = env;
          var start_loc$3 = start_loc;
          var match$3 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$3);
          var id;
          if (typeof match$3 === "number") {
            id = /* Identifier */Block.__(0, [Curry._2(Parse[/* identifier */12], /* None */0, env$3)]);
          } else if (match$3.tag === 1) {
            var match$4 = match$3[0];
            var octal = match$4[3];
            var raw = match$4[2];
            var value = match$4[1];
            var loc$1 = match$4[0];
            if (octal) {
              Parser_env$Jeason.strict_error(env$3, /* StrictOctalLiteral */32);
            }
            Parser_env$Jeason.Expect[/* token */0](env$3, /* T_STRING */Block.__(1, [/* tuple */[
                      loc$1,
                      value,
                      raw,
                      octal
                    ]]));
            var value$1 = /* String */Block.__(0, [value]);
            id = /* Literal */Block.__(1, [/* tuple */[
                  loc$1,
                  /* record */[
                    /* value */value$1,
                    /* raw */raw
                  ]
                ]]);
          } else {
            id = /* Identifier */Block.__(0, [Curry._2(Parse[/* identifier */12], /* None */0, env$3)]);
          }
          var body_start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$3);
          Parser_env$Jeason.Expect[/* token */0](env$3, /* T_LCURLY */1);
          var match$5 = module_items(env$3, /* None */0, /* [] */0);
          var module_kind = match$5[0];
          Parser_env$Jeason.Expect[/* token */0](env$3, /* T_RCURLY */2);
          var body_end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$3);
          var body_loc = Loc$Jeason.btwn(body_start_loc, body_end_loc);
          var body_001 = /* record */[/* body */match$5[1]];
          var body = /* tuple */[
            body_loc,
            body_001
          ];
          var loc$2 = Loc$Jeason.btwn(start_loc$3, body_loc);
          var kind = module_kind ? module_kind[0] : /* CommonJS */Block.__(0, [loc$2]);
          return /* tuple */[
                  loc$2,
                  /* DeclareModule */Block.__(24, [/* record */[
                        /* id */id,
                        /* body */body,
                        /* kind */kind
                      ]])
                ];
        }
      }
    } else {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
      return declare_function_statement(env, start_loc);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (in_module) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_DECLARE */60);
      return declare_var_statement(env, start_loc);
    } else {
      return Curry._1(Parse[/* statement */1], env);
    }
  }
  
}

function expression(env) {
  var match = with_loc(Parse[/* expression */6], env);
  var loc = match[0];
  var match$1 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env);
  var loc$1 = match$1 ? Loc$Jeason.btwn(loc, match$1[0]) : loc;
  Parser_env$Jeason.Eat[/* semicolon */4](env);
  return /* tuple */[
          loc$1,
          /* Expression */Block.__(1, [/* record */[/* expression */match[1]]])
        ];
}

function module_items(env, _module_kind, _acc) {
  while(true) {
    var acc = _acc;
    var module_kind = _module_kind;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number") {
      if (match !== 2) {
        if (match !== 108) {
          exit = 1;
        } else {
          return /* tuple */[
                  module_kind,
                  List.rev(acc)
                ];
        }
      } else {
        return /* tuple */[
                module_kind,
                List.rev(acc)
              ];
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var stmt = declare(/* Some */[/* true */1], env);
      var stmt$1 = stmt[1];
      var loc = stmt[0];
      var module_kind$1;
      if (module_kind) {
        if (module_kind[0].tag) {
          if (typeof stmt$1 === "number" || stmt$1.tag !== 25) {
            module_kind$1 = module_kind;
          } else {
            Parser_env$Jeason.error(env, /* AmbiguousDeclareModuleKind */61);
            module_kind$1 = module_kind;
          }
        } else if (typeof stmt$1 === "number") {
          module_kind$1 = module_kind;
        } else {
          switch (stmt$1.tag | 0) {
            case 25 : 
                Parser_env$Jeason.error(env, /* DuplicateDeclareModuleExports */60);
                module_kind$1 = module_kind;
                break;
            case 26 : 
                var declaration = stmt$1[0][/* declaration */1];
                if (declaration) {
                  switch (declaration[0].tag | 0) {
                    case 4 : 
                    case 5 : 
                        break;
                    default:
                      Parser_env$Jeason.error(env, /* AmbiguousDeclareModuleKind */61);
                  }
                } else {
                  Parser_env$Jeason.error(env, /* AmbiguousDeclareModuleKind */61);
                }
                module_kind$1 = module_kind;
                break;
            default:
              module_kind$1 = module_kind;
          }
        }
      } else if (typeof stmt$1 === "number") {
        module_kind$1 = module_kind;
      } else {
        switch (stmt$1.tag | 0) {
          case 25 : 
              module_kind$1 = /* Some */[/* CommonJS */Block.__(0, [loc])];
              break;
          case 26 : 
              var declaration$1 = stmt$1[0][/* declaration */1];
              if (declaration$1) {
                switch (declaration$1[0].tag | 0) {
                  case 4 : 
                  case 5 : 
                      module_kind$1 = module_kind;
                      break;
                  default:
                    module_kind$1 = /* Some */[/* ES */Block.__(1, [loc])];
                }
              } else {
                module_kind$1 = /* Some */[/* ES */Block.__(1, [loc])];
              }
              break;
          default:
            module_kind$1 = module_kind;
        }
      }
      _acc = /* :: */[
        stmt,
        acc
      ];
      _module_kind = module_kind$1;
      continue ;
      
    }
    
  };
}

function supers(env, _acc) {
  while(true) {
    var acc = _acc;
    var $$super = wrap(generic, env);
    var acc$1 = /* :: */[
      $$super,
      acc
    ];
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number" && match === 10) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      _acc = acc$1;
      continue ;
      
    } else {
      return List.rev(acc$1);
    }
  };
}

function declare_class(env, start_loc) {
  var env$1 = Parser_env$Jeason.with_strict(/* true */1, env);
  Parser_env$Jeason.Expect[/* token */0](env$1, /* T_CLASS */40);
  var id = Curry._2(Parse[/* identifier */12], /* None */0, env$1);
  var typeParameters = Curry._1(type_parameter_declaration_with_defaults, env$1);
  var $$extends = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1) === /* T_EXTENDS */41 ? (Parser_env$Jeason.Expect[/* token */0](env$1, /* T_EXTENDS */41), supers(env$1, /* [] */0)) : /* [] */0;
  var mixins = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$1) === "mixins" ? (Parser_env$Jeason.Expect[/* contextual */2](env$1, "mixins"), supers(env$1, /* [] */0)) : /* [] */0;
  var body = _object$1(/* Some */[/* true */1], env$1);
  var loc = Loc$Jeason.btwn(start_loc, body[0]);
  return /* tuple */[
          loc,
          /* record */[
            /* id */id,
            /* typeParameters */typeParameters,
            /* body */body,
            /* extends */$$extends,
            /* mixins */mixins
          ]
        ];
}

function supers$1(env, _acc) {
  while(true) {
    var acc = _acc;
    var $$super = wrap(generic, env);
    var acc$1 = /* :: */[
      $$super,
      acc
    ];
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number" && match === 10) {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      _acc = acc$1;
      continue ;
      
    } else {
      return List.rev(acc$1);
    }
  };
}

function interface_helper(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  if (!Parser_env$Jeason.should_parse_types(env)) {
    Parser_env$Jeason.error(env, /* UnexpectedTypeInterface */11);
  }
  Parser_env$Jeason.Expect[/* token */0](env, /* T_INTERFACE */53);
  var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
  var typeParameters = Curry._1(type_parameter_declaration_with_defaults, env);
  var $$extends = Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_EXTENDS */41 ? (Parser_env$Jeason.Expect[/* token */0](env, /* T_EXTENDS */41), supers$1(env, /* [] */0)) : /* [] */0;
  var body = _object$1(/* Some */[/* true */1], env);
  var loc = Loc$Jeason.btwn(start_loc, body[0]);
  return /* tuple */[
          loc,
          /* record */[
            /* id */id,
            /* typeParameters */typeParameters,
            /* body */body,
            /* extends */$$extends,
            /* mixins : [] */0
          ]
        ];
}

function fold(acc, _param) {
  while(true) {
    var param = _param;
    var match = param[1];
    switch (match.tag | 0) {
      case 0 : 
          return List.fold_left((function (acc, prop) {
                        if (prop.tag) {
                          return fold(acc, prop[0][1][/* argument */0]);
                        } else {
                          return fold(acc, prop[0][1][/* pattern */1]);
                        }
                      }), acc, match[0][/* properties */0]);
      case 1 : 
          return List.fold_left((function (acc, elem) {
                        if (elem) {
                          var match = elem[0];
                          if (match.tag) {
                            return fold(acc, match[0][1][/* argument */0]);
                          } else {
                            return fold(acc, match[0]);
                          }
                        } else {
                          return acc;
                        }
                      }), acc, match[0][/* elements */0]);
      case 2 : 
          _param = match[0][/* left */0];
          continue ;
          case 3 : 
          return /* :: */[
                  match[0][/* name */0],
                  acc
                ];
      case 4 : 
          return Pervasives.failwith("Parser error: No such thing as an expression pattern!");
      
    }
  };
}

function assert_can_be_forin_or_forof(env, err, param) {
  if (param) {
    var match = param[0];
    if (match.tag) {
      var match$1 = match[0];
      var loc = match$1[0];
      if (Curry._1(Parse[/* is_assignable_lhs */23], /* tuple */[
              loc,
              match$1[1]
            ])) {
        return 0;
      } else {
        return Parser_env$Jeason.error_at(env, /* tuple */[
                    loc,
                    err
                  ]);
      }
    } else {
      var match$2 = match[0];
      var declarations = match$2[1][/* declarations */0];
      var exit = 0;
      if (declarations && !(declarations[0][1][/* init */1] || declarations[1])) {
        return /* () */0;
      } else {
        exit = 1;
      }
      if (exit === 1) {
        return Parser_env$Jeason.error_at(env, /* tuple */[
                    match$2[0],
                    err
                  ]);
      }
      
    }
  } else {
    return Parser_env$Jeason.error(env, err);
  }
}

function _if(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_IF */16);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LPAREN */5);
  var test = Curry._1(Parse[/* expression */6], env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RPAREN */6);
  Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var consequent = Parser_env$Jeason.Peek[/* is_function */10](/* None */0, env) ? (Parser_env$Jeason.strict_error(env, /* StrictFunctionStatement */46), _function(env)) : Curry._1(Parse[/* statement */1], env);
  var alternate = Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_ELSE */43 ? (Parser_env$Jeason.Expect[/* token */0](env, /* T_ELSE */43), /* Some */[Curry._1(Parse[/* statement */1], env)]) : /* None */0;
  var end_loc = alternate ? alternate[0][0] : consequent[0];
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* If */Block.__(2, [/* record */[
                /* test */test,
                /* consequent */consequent,
                /* alternate */alternate
              ]])
        ];
}

function case_list(env, _param) {
  while(true) {
    var param = _param;
    var acc = param[1];
    var seen_default = param[0];
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && !(match !== 2 && match !== 108)) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
      var test;
      var exit$1 = 0;
      if (typeof match$1 === "number" && match$1 === 36) {
        if (seen_default) {
          Parser_env$Jeason.error(env, /* MultipleDefaultsInSwitch */20);
        }
        Parser_env$Jeason.Expect[/* token */0](env, /* T_DEFAULT */36);
        test = /* None */0;
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_CASE */33);
        test = /* Some */[Curry._1(Parse[/* expression */6], env)];
      }
      var seen_default$1 = seen_default || +(test === /* None */0);
      var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
      var term_fn = function (param) {
        if (typeof param === "number") {
          var switcher = param - 2 | 0;
          if (switcher > 31 || switcher < 0) {
            if (switcher !== 34) {
              return /* false */0;
            } else {
              return /* true */1;
            }
          } else if (switcher > 30 || switcher < 1) {
            return /* true */1;
          } else {
            return /* false */0;
          }
        } else {
          return /* false */0;
        }
      };
      var consequent = Curry._2(Parse[/* statement_list */3], term_fn, Parser_env$Jeason.with_in_switch(/* true */1, env));
      var match$2 = List.rev(consequent);
      var end_loc$1 = match$2 ? match$2[0][0] : end_loc;
      var acc_000 = /* tuple */[
        Loc$Jeason.btwn(start_loc, end_loc$1),
        /* record */[
          /* test */test,
          /* consequent */consequent
        ]
      ];
      var acc$1 = /* :: */[
        acc_000,
        acc
      ];
      _param = /* tuple */[
        seen_default$1,
        acc$1
      ];
      continue ;
      
    }
    
  };
}

function var_or_const(env) {
  var match = variable(env);
  var match$1 = match[0];
  var start_loc = match$1[0];
  var match$2 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env);
  var end_loc = match$2 ? match$2[0] : start_loc;
  Parser_env$Jeason.Eat[/* semicolon */4](env);
  List.iter((function (param) {
          return Parser_env$Jeason.error_at(env, param);
        }), match[1]);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          match$1[1]
        ];
}

function source(env) {
  Parser_env$Jeason.Expect[/* contextual */2](env, "from");
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 1) {
    exit = 1;
  } else {
    var match$1 = match[0];
    var octal = match$1[3];
    var raw = match$1[2];
    var value = match$1[1];
    var loc = match$1[0];
    if (octal) {
      Parser_env$Jeason.strict_error(env, /* StrictOctalLiteral */32);
    }
    Parser_env$Jeason.Expect[/* token */0](env, /* T_STRING */Block.__(1, [/* tuple */[
              loc,
              value,
              raw,
              octal
            ]]));
    var value$1 = /* String */Block.__(0, [value]);
    return /* tuple */[
            loc,
            /* record */[
              /* value */value$1,
              /* raw */raw
            ]
          ];
  }
  if (exit === 1) {
    var raw$1 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
    var value$2 = /* String */Block.__(0, [raw$1]);
    var ret_000 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    var ret_001 = /* record */[
      /* value */value$2,
      /* raw */raw$1
    ];
    var ret = /* tuple */[
      ret_000,
      ret_001
    ];
    Parser_env$Jeason.error_unexpected(env);
    return ret;
  }
  
}

function specifier_list(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number" && !(match !== 2 && match !== 108)) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var match$1 = Curry._1(Parse[/* identifier_or_reserved_keyword */13], env);
      var err = match$1[1];
      var remote = match$1[0];
      var specifier;
      if (Parser_env$Jeason.Peek[/* value */1](/* None */0, env) === "as") {
        Parser_env$Jeason.Expect[/* contextual */2](env, "as");
        var local = /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, env)];
        specifier = /* ImportNamedSpecifier */Block.__(0, [/* record */[
              /* local */local,
              /* remote */remote
            ]]);
      } else {
        if (err) {
          Parser_env$Jeason.error_at(env, err[0]);
        }
        specifier = /* ImportNamedSpecifier */Block.__(0, [/* record */[
              /* local : None */0,
              /* remote */remote
            ]]);
      }
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COMMA */10) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
      }
      _acc = /* :: */[
        specifier,
        acc
      ];
      continue ;
      
    }
    
  };
}

function named_or_namespace_specifier(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number" && match === 100) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_MULT */100);
    Parser_env$Jeason.Expect[/* contextual */2](env, "as");
    var id = Curry._2(Parse[/* identifier */12], /* None */0, env);
    return /* :: */[
            /* ImportNamespaceSpecifier */Block.__(2, [/* tuple */[
                  Loc$Jeason.btwn(start_loc, id[0]),
                  id
                ]]),
            /* [] */0
          ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
    var specifiers = specifier_list(env, /* [] */0);
    Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
    return specifiers;
  }
  
}

function from_expr(env, param) {
  var expr = param[1];
  var loc = param[0];
  var exit = 0;
  if (typeof expr === "number") {
    exit = 1;
  } else {
    switch (expr.tag | 0) {
      case 0 : 
          var env$1 = env;
          var param$1 = /* tuple */[
            loc,
            expr[0]
          ];
          var elements = List.map((function (param) {
                  var env$2 = env$1;
                  var param$1 = param;
                  if (param$1) {
                    var match = param$1[0];
                    if (match.tag) {
                      var match$1 = match[0];
                      var argument = Curry._2(Parse[/* pattern_from_expr */19], env$2, match$1[1][/* argument */0]);
                      return /* Some */[/* RestElement */Block.__(1, [/* tuple */[
                                    match$1[0],
                                    /* record */[/* argument */argument]
                                  ]])];
                    } else {
                      var match$2 = match[0];
                      return /* Some */[/* Element */Block.__(0, [Curry._2(Parse[/* pattern_from_expr */19], env$2, /* tuple */[
                                        match$2[0],
                                        match$2[1]
                                      ])])];
                    }
                  } else {
                    return /* None */0;
                  }
                }), param$1[1][/* elements */0]);
          return /* tuple */[
                  param$1[0],
                  /* Array */Block.__(1, [/* record */[
                        /* elements */elements,
                        /* typeAnnotation : None */0
                      ]])
                ];
      case 1 : 
          var env$2 = env;
          var param$2 = /* tuple */[
            loc,
            expr[0]
          ];
          var properties = List.map((function (param) {
                  var env$3 = env$2;
                  var prop = param;
                  if (prop.tag) {
                    var match = prop[0];
                    var argument = Curry._2(Parse[/* pattern_from_expr */19], env$3, match[1][/* argument */0]);
                    return /* RestProperty */Block.__(1, [/* tuple */[
                                match[0],
                                /* record */[/* argument */argument]
                              ]]);
                  } else {
                    var match$1 = prop[0];
                    var match$2 = match$1[1];
                    var key = match$2[/* key */0];
                    var key$1;
                    switch (key.tag | 0) {
                      case 0 : 
                          key$1 = /* Literal */Block.__(0, [key[0]]);
                          break;
                      case 1 : 
                          key$1 = /* Identifier */Block.__(1, [key[0]]);
                          break;
                      case 2 : 
                          key$1 = /* Computed */Block.__(2, [key[0]]);
                          break;
                      
                    }
                    var pattern = Curry._2(Parse[/* pattern_from_expr */19], env$3, match$2[/* value */1]);
                    return /* Property */Block.__(0, [/* tuple */[
                                match$1[0],
                                /* record */[
                                  /* key */key$1,
                                  /* pattern */pattern,
                                  /* shorthand */match$2[/* shorthand */4]
                                ]
                              ]]);
                  }
                }), param$2[1][/* properties */0]);
          return /* tuple */[
                  param$2[0],
                  /* Object */Block.__(0, [/* record */[
                        /* properties */properties,
                        /* typeAnnotation : None */0
                      ]])
                ];
      case 7 : 
          var match = expr[0];
          if (match[/* operator */0] !== 0) {
            exit = 1;
          } else {
            return /* tuple */[
                    loc,
                    /* Assignment */Block.__(2, [/* record */[
                          /* left */match[/* left */1],
                          /* right */match[/* right */2]
                        ]])
                  ];
          }
          break;
      case 17 : 
          return /* tuple */[
                  loc,
                  /* Identifier */Block.__(3, [/* record */[
                        /* name */expr[0],
                        /* typeAnnotation : None */0,
                        /* optional : false */0
                      ]])
                ];
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    return /* tuple */[
            loc,
            /* Expression */Block.__(4, [/* tuple */[
                  loc,
                  expr
                ]])
          ];
  }
  
}

function _object$2(restricted_error) {
  var property = function (env) {
    var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
    if (Parser_env$Jeason.Expect[/* maybe */1](env, /* T_ELLIPSIS */13)) {
      var argument = pattern$1(env, restricted_error);
      var loc = Loc$Jeason.btwn(start_loc, argument[0]);
      return /* Some */[/* RestProperty */Block.__(1, [/* tuple */[
                    loc,
                    /* record */[/* argument */argument]
                  ]])];
    } else {
      var match = Curry._1(Parse[/* object_key */20], env);
      var match$1 = match[1];
      var key;
      switch (match$1.tag | 0) {
        case 0 : 
            key = /* Literal */Block.__(0, [match$1[0]]);
            break;
        case 1 : 
            key = /* Identifier */Block.__(1, [match$1[0]]);
            break;
        case 2 : 
            key = /* Computed */Block.__(2, [match$1[0]]);
            break;
        
      }
      var match$2 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
      var prop;
      var exit = 0;
      if (typeof match$2 === "number" && match$2 === 80) {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
        prop = /* Some */[/* tuple */[
            pattern$1(env, restricted_error),
            /* false */0
          ]];
      } else {
        exit = 1;
      }
      if (exit === 1) {
        switch (key.tag | 0) {
          case 1 : 
              var name = key[0];
              var pattern_000 = name[0];
              var pattern_001 = /* Identifier */Block.__(3, [/* record */[
                    /* name */name,
                    /* typeAnnotation : None */0,
                    /* optional : false */0
                  ]]);
              var pattern$2 = /* tuple */[
                pattern_000,
                pattern_001
              ];
              prop = /* Some */[/* tuple */[
                  pattern$2,
                  /* true */1
                ]];
              break;
          case 0 : 
          case 2 : 
              Parser_env$Jeason.error_unexpected(env);
              prop = /* None */0;
              break;
          
        }
      }
      if (prop) {
        var match$3 = prop[0];
        var pattern$3 = match$3[0];
        var match$4 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
        var pattern$4;
        if (typeof match$4 === "number" && match$4 === 78) {
          Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78);
          var $$default = Curry._1(Parse[/* assignment */8], env);
          var loc$1 = Loc$Jeason.btwn(pattern$3[0], $$default[0]);
          pattern$4 = /* tuple */[
            loc$1,
            /* Assignment */Block.__(2, [/* record */[
                  /* left */pattern$3,
                  /* right */$$default
                ]])
          ];
        } else {
          pattern$4 = pattern$3;
        }
        var loc$2 = Loc$Jeason.btwn(start_loc, pattern$4[0]);
        return /* Some */[/* Property */Block.__(0, [/* tuple */[
                      loc$2,
                      /* record */[
                        /* key */key,
                        /* pattern */pattern$4,
                        /* shorthand */match$3[1]
                      ]
                    ]])];
      } else {
        return /* None */0;
      }
    }
  };
  var properties = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
      var exit = 0;
      if (typeof match === "number" && !(match !== 2 && match !== 108)) {
        return List.rev(acc);
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var match$1 = property(env);
        if (match$1) {
          if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RCURLY */2) {
            Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
          }
          _acc = /* :: */[
            match$1[0],
            acc
          ];
          continue ;
          
        } else {
          continue ;
          
        }
      }
      
    };
  };
  return (function (env) {
      var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
      var properties$1 = properties(env, /* [] */0);
      var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
      var match;
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COLON */80) {
        var typeAnnotation = wrap(annotation, env);
        match = /* tuple */[
          typeAnnotation[0],
          /* Some */[typeAnnotation]
        ];
      } else {
        match = /* tuple */[
          end_loc,
          /* None */0
        ];
      }
      return /* tuple */[
              Loc$Jeason.btwn(start_loc, match[0]),
              /* Object */Block.__(0, [/* record */[
                    /* properties */properties$1,
                    /* typeAnnotation */match[1]
                  ]])
            ];
    });
}

function _array(restricted_error) {
  var elements = function (env, _acc) {
    while(true) {
      var acc = _acc;
      var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
      var exit = 0;
      if (typeof match === "number") {
        if (match >= 14) {
          if (match !== 108) {
            exit = 1;
          } else {
            return List.rev(acc);
          }
        } else if (match >= 8) {
          switch (match - 8 | 0) {
            case 0 : 
                return List.rev(acc);
            case 2 : 
                Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
                _acc = /* :: */[
                  /* None */0,
                  acc
                ];
                continue ;
                case 1 : 
            case 3 : 
            case 4 : 
                exit = 1;
                break;
            case 5 : 
                var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
                Parser_env$Jeason.Expect[/* token */0](env, /* T_ELLIPSIS */13);
                var argument = pattern$1(env, restricted_error);
                var loc = Loc$Jeason.btwn(start_loc, argument[0]);
                var element = /* RestElement */Block.__(1, [/* tuple */[
                      loc,
                      /* record */[/* argument */argument]
                    ]]);
                _acc = /* :: */[
                  /* Some */[element],
                  acc
                ];
                continue ;
                
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
      if (exit === 1) {
        var pattern$2 = pattern$1(env, restricted_error);
        var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
        var pattern$3;
        if (typeof match$1 === "number" && match$1 === 78) {
          Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78);
          var $$default = Curry._1(Parse[/* expression */6], env);
          var loc$1 = Loc$Jeason.btwn(pattern$2[0], $$default[0]);
          pattern$3 = /* tuple */[
            loc$1,
            /* Assignment */Block.__(2, [/* record */[
                  /* left */pattern$2,
                  /* right */$$default
                ]])
          ];
        } else {
          pattern$3 = pattern$2;
        }
        var element$1 = /* Element */Block.__(0, [pattern$3]);
        if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) !== /* T_RBRACKET */8) {
          Parser_env$Jeason.Expect[/* token */0](env, /* T_COMMA */10);
        }
        _acc = /* :: */[
          /* Some */[element$1],
          acc
        ];
        continue ;
        
      }
      
    };
  };
  return (function (env) {
      var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_LBRACKET */7);
      var elements$1 = elements(env, /* [] */0);
      var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_RBRACKET */8);
      var match;
      if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COLON */80) {
        var typeAnnotation = wrap(annotation, env);
        match = /* tuple */[
          typeAnnotation[0],
          /* Some */[typeAnnotation]
        ];
      } else {
        match = /* tuple */[
          end_loc,
          /* None */0
        ];
      }
      return /* tuple */[
              Loc$Jeason.btwn(start_loc, match[0]),
              /* Array */Block.__(1, [/* record */[
                    /* elements */elements$1,
                    /* typeAnnotation */match[1]
                  ]])
            ];
    });
}

function pattern$1(env, restricted_error) {
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number") {
    if (match !== 1) {
      if (match !== 7) {
        exit = 1;
      } else {
        return _array(restricted_error)(env);
      }
    } else {
      return _object$2(restricted_error)(env);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var match$1 = Curry._3(Parse[/* identifier_with_type */14], env, /* None */0, restricted_error);
    return /* tuple */[
            match$1[0],
            /* Identifier */Block.__(3, [match$1[1]])
          ];
  }
  
}

function spread_attribute(env) {
  Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* NORMAL */0);
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_ELLIPSIS */13);
  var argument = Curry._1(assignment, env);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
  Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* argument */argument]
        ];
}

function expression_container(env) {
  Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* NORMAL */0);
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
  var expression;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_RCURLY */2) {
    var empty_loc = Loc$Jeason.btwn_exclusive(start_loc, Parser_env$Jeason.Peek[/* loc */2](/* None */0, env));
    expression = /* EmptyExpression */Block.__(1, [empty_loc]);
  } else {
    expression = /* Expression */Block.__(0, [Curry._1(Parse[/* expression */6], env)]);
  }
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
  Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* expression */expression]
        ];
}

function identifier$1(env) {
  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var name = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_JSX_IDENTIFIER */109);
  return /* tuple */[
          loc,
          /* record */[/* name */name]
        ];
}

function member_expression(env, _member) {
  while(true) {
    var member = _member;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number" && match === 11) {
      var _object = /* MemberExpression */Block.__(1, [member]);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_PERIOD */11);
      var property = identifier$1(env);
      var loc = Loc$Jeason.btwn(member[0], property[0]);
      var member_001 = /* record */[
        /* _object */_object,
        /* property */property
      ];
      var member$1 = /* tuple */[
        loc,
        member_001
      ];
      _member = member$1;
      continue ;
      
    } else {
      return member;
    }
  };
}

function name(env) {
  var name$1 = identifier$1(env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    if (match !== 11) {
      if (match !== 80) {
        return /* Identifier */Block.__(0, [name$1]);
      } else {
        Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
        var name$2 = identifier$1(env);
        var loc = Loc$Jeason.btwn(name$1[0], name$2[0]);
        return /* NamespacedName */Block.__(1, [/* tuple */[
                    loc,
                    /* record */[
                      /* namespace */name$1,
                      /* name */name$2
                    ]
                  ]]);
      }
    } else {
      var _object = /* Identifier */Block.__(0, [name$1]);
      Parser_env$Jeason.Expect[/* token */0](env, /* T_PERIOD */11);
      var property = identifier$1(env);
      var loc$1 = Loc$Jeason.btwn(name$1[0], property[0]);
      var member_001 = /* record */[
        /* _object */_object,
        /* property */property
      ];
      var member = /* tuple */[
        loc$1,
        member_001
      ];
      return /* MemberExpression */Block.__(2, [member_expression(env, member)]);
    }
  } else {
    return /* Identifier */Block.__(0, [name$1]);
  }
}

function attribute(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var name = identifier$1(env);
  var match;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COLON */80) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_COLON */80);
    var name$1 = identifier$1(env);
    var loc = Loc$Jeason.btwn(name[0], name$1[0]);
    match = /* tuple */[
      loc,
      /* NamespacedName */Block.__(1, [/* tuple */[
            loc,
            /* record */[
              /* namespace */name,
              /* name */name$1
            ]
          ]])
    ];
  } else {
    match = /* tuple */[
      name[0],
      /* Identifier */Block.__(0, [name])
    ];
  }
  var match$1;
  if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_ASSIGN */78) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_ASSIGN */78);
    var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof token === "number") {
      if (token === 1) {
        var match$2 = expression_container(env);
        var expression_container$1 = match$2[1];
        var loc$1 = match$2[0];
        var match$3 = expression_container$1[/* expression */0];
        if (match$3.tag) {
          Parser_env$Jeason.error_at(env, /* tuple */[
                loc$1,
                /* JSXAttributeValueEmptyExpression */41
              ]);
        }
        match$1 = /* tuple */[
          loc$1,
          /* Some */[/* ExpressionContainer */Block.__(1, [
                loc$1,
                expression_container$1
              ])]
        ];
      } else {
        exit = 1;
      }
    } else if (token.tag === 4) {
      var match$4 = token[0];
      var loc$2 = match$4[0];
      Parser_env$Jeason.Expect[/* token */0](env, token);
      var value = /* String */Block.__(0, [match$4[1]]);
      match$1 = /* tuple */[
        loc$2,
        /* Some */[/* Literal */Block.__(0, [
              loc$2,
              /* record */[
                /* value */value,
                /* raw */match$4[2]
              ]
            ])]
      ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      Parser_env$Jeason.error(env, /* InvalidJSXAttributeValue */42);
      var loc$3 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
      match$1 = /* tuple */[
        loc$3,
        /* Some */[/* Literal */Block.__(0, [
              loc$3,
              /* record */[
                /* value : String */Block.__(0, [""]),
                /* raw */""
              ]
            ])]
      ];
    }
    
  } else {
    match$1 = /* tuple */[
      match[0],
      /* None */0
    ];
  }
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, match$1[0]),
          /* record */[
            /* name */match[1],
            /* value */match$1[1]
          ]
        ];
}

function attributes(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof match === "number") {
      if (match >= 94) {
        if (match !== 99 && match !== 108) {
          exit = 1;
        } else {
          return List.rev(acc);
        }
      } else if (match !== 1) {
        if (match >= 93) {
          return List.rev(acc);
        } else {
          exit = 1;
        }
      } else {
        var attribute$1 = /* SpreadAttribute */Block.__(1, [spread_attribute(env)]);
        _acc = /* :: */[
          attribute$1,
          acc
        ];
        continue ;
        
      }
    } else {
      exit = 1;
    }
    if (exit === 1) {
      var attribute$2 = /* Attribute */Block.__(0, [attribute(env)]);
      _acc = /* :: */[
        attribute$2,
        acc
      ];
      continue ;
      
    }
    
  };
}

function opening_element_without_lt(env, start_loc) {
  var name$1 = name(env);
  var attributes$1 = attributes(env, /* [] */0);
  var selfClosing = +(Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_DIV */99);
  if (selfClosing) {
    Parser_env$Jeason.Expect[/* token */0](env, /* T_DIV */99);
  }
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_GREATER_THAN */93);
  Parser_env$Jeason.Eat[/* pop_lex_mode */2](env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[
            /* name */name$1,
            /* selfClosing */selfClosing,
            /* attributes */attributes$1
          ]
        ];
}

function closing_element_without_lt(env, start_loc) {
  Parser_env$Jeason.Expect[/* token */0](env, /* T_DIV */99);
  var name$1 = name(env);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_GREATER_THAN */93);
  Parser_env$Jeason.Eat[/* double_pop_lex_mode */3](env);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* name */name$1]
        ];
}

function child(env) {
  var token = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof token === "number") {
    if (token === 1) {
      var expression_container$1 = expression_container(env);
      return /* tuple */[
              expression_container$1[0],
              /* ExpressionContainer */Block.__(1, [expression_container$1[1]])
            ];
    } else {
      exit = 1;
    }
  } else if (token.tag === 4) {
    var match = token[0];
    Parser_env$Jeason.Expect[/* token */0](env, token);
    return /* tuple */[
            match[0],
            /* Text */Block.__(2, [/* record */[
                  /* value */match[1],
                  /* raw */match[2]
                ]])
          ];
  } else {
    exit = 1;
  }
  if (exit === 1) {
    var element$1 = element(env);
    return /* tuple */[
            element$1[0],
            /* Element */Block.__(0, [element$1[1]])
          ];
  }
  
}

function element(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* JSX_TAG */2);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LESS_THAN */92);
  return Curry._2(element_without_lt, env, start_loc);
}

function element_or_closing(env) {
  Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* JSX_TAG */2);
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LESS_THAN */92);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    if (match !== 99) {
      if (match !== 108) {
        return /* ChildElement */Block.__(1, [Curry._2(element_without_lt, env, start_loc)]);
      } else {
        return /* Closing */Block.__(0, [closing_element_without_lt(env, start_loc)]);
      }
    } else {
      return /* Closing */Block.__(0, [closing_element_without_lt(env, start_loc)]);
    }
  } else {
    return /* ChildElement */Block.__(1, [Curry._2(element_without_lt, env, start_loc)]);
  }
}

function children_and_closing(env, _acc) {
  while(true) {
    var acc = _acc;
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    if (typeof match === "number") {
      if (match !== 92) {
        if (match !== 108) {
          _acc = /* :: */[
            child(env),
            acc
          ];
          continue ;
          
        } else {
          Parser_env$Jeason.error_unexpected(env);
          return /* tuple */[
                  List.rev(acc),
                  /* None */0
                ];
        }
      } else {
        var match$1 = element_or_closing(env);
        if (match$1.tag) {
          var element = match$1[0];
          var element_000 = element[0];
          var element_001 = /* Element */Block.__(0, [element[1]]);
          var element$1 = /* tuple */[
            element_000,
            element_001
          ];
          _acc = /* :: */[
            element$1,
            acc
          ];
          continue ;
          
        } else {
          return /* tuple */[
                  List.rev(acc),
                  /* Some */[match$1[0]]
                ];
        }
      }
    } else {
      _acc = /* :: */[
        child(env),
        acc
      ];
      continue ;
      
    }
  };
}

function normalize(name) {
  switch (name.tag | 0) {
    case 0 : 
        return name[0][1][/* name */0];
    case 1 : 
        var match = name[0][1];
        return match[/* namespace */0][1][/* name */0] + (":" + match[/* name */1][1][/* name */0]);
    case 2 : 
        var match$1 = name[0][1];
        var _object = match$1[/* _object */0];
        var _object$1;
        _object$1 = _object.tag ? normalize(/* MemberExpression */Block.__(2, [_object[0]])) : _object[0][1][/* name */0];
        return _object$1 + ("." + match$1[/* property */1][1][/* name */0]);
    
  }
}

function element_without_lt(env, start_loc) {
  var openingElement = opening_element_without_lt(env, start_loc);
  var match = openingElement[1][/* selfClosing */1] ? /* tuple */[
      /* [] */0,
      /* None */0
    ] : (Parser_env$Jeason.Eat[/* push_lex_mode */1](env, /* JSX_CHILD */3), children_and_closing(env, /* [] */0));
  var closingElement = match[1];
  var end_loc;
  if (closingElement) {
    var match$1 = closingElement[0];
    var opening_name = normalize(openingElement[1][/* name */0]);
    if (normalize(match$1[1][/* name */0]) !== opening_name) {
      Parser_env$Jeason.error(env, /* ExpectedJSXClosingTag */Block.__(6, [opening_name]));
    }
    end_loc = match$1[0];
  } else {
    end_loc = openingElement[0];
  }
  return /* tuple */[
          Loc$Jeason.btwn(openingElement[0], end_loc),
          /* record */[
            /* openingElement */openingElement,
            /* closingElement */closingElement,
            /* children */match[0]
          ]
        ];
}

function statement_list_item($staropt$star, env) {
  var decorators = $staropt$star ? $staropt$star[0] : /* [] */0;
  if (!Parser_env$Jeason.Peek[/* is_class */11](/* None */0, env)) {
    Parser_env$Jeason.error_on_decorators(env)(decorators);
  }
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number") {
    if (match !== 27) {
      if (match !== 28) {
        exit = 1;
      } else {
        var env$1 = env;
        var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$1);
        Parser_env$Jeason.Expect[/* token */0](env$1, /* T_LET */28);
        var match$1 = helper(Parser_env$Jeason.with_no_let(/* true */1, env$1), /* [] */0, /* [] */0);
        var declaration = /* VariableDeclaration */Block.__(18, [/* record */[
              /* declarations */match$1[1],
              /* kind : Let */1
            ]]);
        var match$2 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$1);
        var end_loc = match$2 ? match$2[0] : match$1[0];
        Parser_env$Jeason.Eat[/* semicolon */4](env$1);
        List.iter((function (param) {
                return Parser_env$Jeason.error_at(env$1, param);
              }), match$1[2]);
        return /* tuple */[
                Loc$Jeason.btwn(start_loc, end_loc),
                declaration
              ];
      }
    } else {
      return var_or_const(env);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (Parser_env$Jeason.Peek[/* is_function */10](/* None */0, env)) {
      return _function(env);
    } else if (Parser_env$Jeason.Peek[/* is_class */11](/* None */0, env)) {
      return class_declaration$1(env, decorators);
    } else if (typeof match === "number") {
      var switcher = match - 53 | 0;
      if (switcher > 8 || switcher < 0) {
        return statement(env);
      } else {
        switch (switcher) {
          case 0 : 
              return $$interface(env);
          case 1 : 
          case 2 : 
          case 3 : 
          case 4 : 
          case 5 : 
          case 6 : 
              return statement(env);
          case 7 : 
              return declare(/* None */0, env);
          case 8 : 
              return type_alias(env);
          
        }
      }
    } else {
      return statement(env);
    }
  }
  
}

function statement(env) {
  while(true) {
    var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    var exit$1 = 0;
    if (typeof match === "number") {
      if (match !== 108) {
        if (match >= 60) {
          exit$1 = 2;
        } else {
          switch (match) {
            case 1 : 
                var env$1 = env;
                var match$1 = Curry._1(Parse[/* block_body */15], env$1);
                return /* tuple */[
                        match$1[0],
                        /* Block */Block.__(0, [match$1[1]])
                      ];
            case 9 : 
                var env$2 = env;
                var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2);
                Parser_env$Jeason.Expect[/* token */0](env$2, /* T_SEMICOLON */9);
                return /* tuple */[
                        loc,
                        /* Empty */0
                      ];
            case 16 : 
                return _if(env);
            case 19 : 
                var env$3 = env;
                if (!Parser_env$Jeason.in_function(env$3)) {
                  Parser_env$Jeason.error(env$3, /* IllegalReturn */24);
                }
                var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$3);
                Parser_env$Jeason.Expect[/* token */0](env$3, /* T_RETURN */19);
                var argument = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$3) === /* T_SEMICOLON */9 || Parser_env$Jeason.Peek[/* is_implicit_semicolon */6](env$3) ? /* None */0 : /* Some */[Curry._1(Parse[/* expression */6], env$3)];
                var match$2 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$3);
                var end_loc = match$2 ? match$2[0] : (
                    argument ? argument[0][0] : start_loc
                  );
                Parser_env$Jeason.Eat[/* semicolon */4](env$3);
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc, end_loc),
                        /* Return */Block.__(9, [/* record */[/* argument */argument]])
                      ];
            case 20 : 
                var env$4 = env;
                var start_loc$1 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$4);
                Parser_env$Jeason.Expect[/* token */0](env$4, /* T_SWITCH */20);
                Parser_env$Jeason.Expect[/* token */0](env$4, /* T_LPAREN */5);
                var discriminant = Curry._1(Parse[/* expression */6], env$4);
                Parser_env$Jeason.Expect[/* token */0](env$4, /* T_RPAREN */6);
                Parser_env$Jeason.Expect[/* token */0](env$4, /* T_LCURLY */1);
                var cases = case_list(env$4, /* tuple */[
                      /* false */0,
                      /* [] */0
                    ]);
                var end_loc$1 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$4);
                Parser_env$Jeason.Expect[/* token */0](env$4, /* T_RCURLY */2);
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$1, end_loc$1),
                        /* Switch */Block.__(8, [/* record */[
                              /* discriminant */discriminant,
                              /* cases */cases
                            ]])
                      ];
            case 22 : 
                var env$5 = env;
                var start_loc$2 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$5);
                Parser_env$Jeason.Expect[/* token */0](env$5, /* T_THROW */22);
                if (Parser_env$Jeason.Peek[/* is_line_terminator */5](env$5)) {
                  Parser_env$Jeason.error_at(env$5, /* tuple */[
                        start_loc$2,
                        /* NewlineAfterThrow */12
                      ]);
                }
                var argument$1 = Curry._1(Parse[/* expression */6], env$5);
                var match$3 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$5);
                var end_loc$2 = match$3 ? match$3[0] : argument$1[0];
                Parser_env$Jeason.Eat[/* semicolon */4](env$5);
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$2, end_loc$2),
                        /* Throw */Block.__(10, [/* record */[/* argument */argument$1]])
                      ];
            case 23 : 
                var env$6 = env;
                var start_loc$3 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$6);
                Parser_env$Jeason.Expect[/* token */0](env$6, /* T_TRY */23);
                var block = Curry._1(Parse[/* block_body */15], env$6);
                var match$4 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$6);
                var handler;
                if (typeof match$4 === "number" && match$4 === 34) {
                  var start_loc$4 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$6);
                  Parser_env$Jeason.Expect[/* token */0](env$6, /* T_CATCH */34);
                  Parser_env$Jeason.Expect[/* token */0](env$6, /* T_LPAREN */5);
                  var id = Curry._2(Parse[/* identifier */12], /* Some */[/* StrictCatchVariable */27], env$6);
                  var param_000 = id[0];
                  var param_001 = /* Identifier */Block.__(3, [/* record */[
                        /* name */id,
                        /* typeAnnotation : None */0,
                        /* optional : false */0
                      ]]);
                  var param = /* tuple */[
                    param_000,
                    param_001
                  ];
                  Parser_env$Jeason.Expect[/* token */0](env$6, /* T_RPAREN */6);
                  var body = Curry._1(Parse[/* block_body */15], env$6);
                  var loc$1 = Loc$Jeason.btwn(start_loc$4, body[0]);
                  handler = /* Some */[/* tuple */[
                      loc$1,
                      /* record */[
                        /* param */param,
                        /* body */body
                      ]
                    ]];
                } else {
                  handler = /* None */0;
                }
                var match$5 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$6);
                var finalizer = typeof match$5 === "number" && match$5 === 38 ? (Parser_env$Jeason.Expect[/* token */0](env$6, /* T_FINALLY */38), /* Some */[Curry._1(Parse[/* block_body */15], env$6)]) : /* None */0;
                var end_loc$3 = finalizer ? finalizer[0][0] : (
                    handler ? handler[0][0] : (Parser_env$Jeason.error_at(env$6, /* tuple */[
                              block[0],
                              /* NoCatchOrFinally */21
                            ]), block[0])
                  );
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$3, end_loc$3),
                        /* Try */Block.__(11, [/* record */[
                              /* block */block,
                              /* handler */handler,
                              /* finalizer */finalizer
                            ]])
                      ];
            case 24 : 
                return var_or_const(env);
            case 25 : 
                var env$7 = env;
                var start_loc$5 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$7);
                Parser_env$Jeason.Expect[/* token */0](env$7, /* T_WHILE */25);
                Parser_env$Jeason.Expect[/* token */0](env$7, /* T_LPAREN */5);
                var test = Curry._1(Parse[/* expression */6], env$7);
                Parser_env$Jeason.Expect[/* token */0](env$7, /* T_RPAREN */6);
                var body$1 = Curry._1(Parse[/* statement */1], Parser_env$Jeason.with_in_loop(/* true */1, env$7));
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$5, body$1[0]),
                        /* While */Block.__(12, [/* record */[
                              /* test */test,
                              /* body */body$1
                            ]])
                      ];
            case 26 : 
                var env$8 = env;
                var start_loc$6 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$8);
                Parser_env$Jeason.Expect[/* token */0](env$8, /* T_WITH */26);
                Parser_env$Jeason.Expect[/* token */0](env$8, /* T_LPAREN */5);
                var _object = Curry._1(Parse[/* expression */6], env$8);
                Parser_env$Jeason.Expect[/* token */0](env$8, /* T_RPAREN */6);
                var body$2 = Curry._1(Parse[/* statement */1], env$8);
                var loc$2 = Loc$Jeason.btwn(start_loc$6, body$2[0]);
                Parser_env$Jeason.strict_error_at(env$8, /* tuple */[
                      loc$2,
                      /* StrictModeWith */26
                    ]);
                return /* tuple */[
                        loc$2,
                        /* With */Block.__(6, [/* record */[
                              /* _object */_object,
                              /* body */body$2
                            ]])
                      ];
            case 32 : 
                var env$9 = env;
                var start_loc$7 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$9);
                Parser_env$Jeason.Expect[/* token */0](env$9, /* T_BREAK */32);
                var label;
                if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env$9) === /* T_SEMICOLON */9 || Parser_env$Jeason.Peek[/* is_implicit_semicolon */6](env$9)) {
                  label = /* None */0;
                } else {
                  var label$1 = Curry._2(Parse[/* identifier */12], /* None */0, env$9);
                  var name = label$1[1];
                  if (!Curry._2(SSet[/* mem */2], name, Parser_env$Jeason.labels(env$9))) {
                    Parser_env$Jeason.error(env$9, /* UnknownLabel */Block.__(4, [name]));
                  }
                  label = /* Some */[label$1];
                }
                var match$6 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$9);
                var end_loc$4 = match$6 ? match$6[0] : (
                    label ? label[0][0] : start_loc$7
                  );
                var loc$3 = Loc$Jeason.btwn(start_loc$7, end_loc$4);
                if (label === /* None */0 && !(Parser_env$Jeason.in_loop(env$9) || Parser_env$Jeason.in_switch(env$9))) {
                  Parser_env$Jeason.error_at(env$9, /* tuple */[
                        loc$3,
                        /* IllegalBreak */23
                      ]);
                }
                Parser_env$Jeason.Eat[/* semicolon */4](env$9);
                return /* tuple */[
                        loc$3,
                        /* Break */Block.__(4, [/* record */[/* label */label]])
                      ];
            case 35 : 
                var env$10 = env;
                var start_loc$8 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$10);
                Parser_env$Jeason.Expect[/* token */0](env$10, /* T_CONTINUE */35);
                var label$2;
                if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env$10) === /* T_SEMICOLON */9 || Parser_env$Jeason.Peek[/* is_implicit_semicolon */6](env$10)) {
                  label$2 = /* None */0;
                } else {
                  var label$3 = Curry._2(Parse[/* identifier */12], /* None */0, env$10);
                  var name$1 = label$3[1];
                  if (!Curry._2(SSet[/* mem */2], name$1, Parser_env$Jeason.labels(env$10))) {
                    Parser_env$Jeason.error(env$10, /* UnknownLabel */Block.__(4, [name$1]));
                  }
                  label$2 = /* Some */[label$3];
                }
                var match$7 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$10);
                var end_loc$5 = match$7 ? match$7[0] : (
                    label$2 ? label$2[0][0] : start_loc$8
                  );
                var loc$4 = Loc$Jeason.btwn(start_loc$8, end_loc$5);
                if (!Parser_env$Jeason.in_loop(env$10)) {
                  Parser_env$Jeason.error_at(env$10, /* tuple */[
                        loc$4,
                        /* IllegalContinue */22
                      ]);
                }
                Parser_env$Jeason.Eat[/* semicolon */4](env$10);
                return /* tuple */[
                        loc$4,
                        /* Continue */Block.__(5, [/* record */[/* label */label$2]])
                      ];
            case 37 : 
                var env$11 = env;
                var start_loc$9 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$11);
                Parser_env$Jeason.Expect[/* token */0](env$11, /* T_DO */37);
                var body$3 = Curry._1(Parse[/* statement */1], Parser_env$Jeason.with_in_loop(/* true */1, env$11));
                Parser_env$Jeason.Expect[/* token */0](env$11, /* T_WHILE */25);
                Parser_env$Jeason.Expect[/* token */0](env$11, /* T_LPAREN */5);
                var test$1 = Curry._1(Parse[/* expression */6], env$11);
                var end_loc$6 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$11);
                Parser_env$Jeason.Expect[/* token */0](env$11, /* T_RPAREN */6);
                var match$8 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$11);
                var end_loc$7 = match$8 ? match$8[0] : end_loc$6;
                if (Parser_env$Jeason.Peek[/* token */0](/* None */0, env$11) === /* T_SEMICOLON */9) {
                  Parser_env$Jeason.Eat[/* semicolon */4](env$11);
                }
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$9, end_loc$7),
                        /* DoWhile */Block.__(13, [/* record */[
                              /* body */body$3,
                              /* test */test$1
                            ]])
                      ];
            case 39 : 
                var env$12 = env;
                var start_loc$10 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$12);
                Parser_env$Jeason.Expect[/* token */0](env$12, /* T_FOR */39);
                var async = Parser_env$Jeason.allow_await(env$12) && Parser_env$Jeason.Expect[/* maybe */1](env$12, /* T_AWAIT */64);
                Parser_env$Jeason.Expect[/* token */0](env$12, /* T_LPAREN */5);
                var match$9 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$12);
                var match$10;
                var exit$2 = 0;
                if (typeof match$9 === "number") {
                  if (match$9 >= 24) {
                    if (match$9 >= 29) {
                      exit$2 = 1;
                    } else {
                      switch (match$9 - 24 | 0) {
                        case 0 : 
                            var match$11 = declarations(/* T_VAR */24, /* Var */0, Parser_env$Jeason.with_no_in(/* true */1, env$12));
                            match$10 = /* tuple */[
                              /* Some */[/* InitDeclaration */Block.__(0, [match$11[0]])],
                              match$11[1]
                            ];
                            break;
                        case 1 : 
                        case 2 : 
                            exit$2 = 1;
                            break;
                        case 3 : 
                            var match$12 = $$const(Parser_env$Jeason.with_no_in(/* true */1, env$12));
                            match$10 = /* tuple */[
                              /* Some */[/* InitDeclaration */Block.__(0, [match$12[0]])],
                              match$12[1]
                            ];
                            break;
                        case 4 : 
                            var match$13 = _let(Parser_env$Jeason.with_no_in(/* true */1, env$12));
                            match$10 = /* tuple */[
                              /* Some */[/* InitDeclaration */Block.__(0, [match$13[0]])],
                              match$13[1]
                            ];
                            break;
                        
                      }
                    }
                  } else if (match$9 !== 9) {
                    exit$2 = 1;
                  } else {
                    match$10 = /* tuple */[
                      /* None */0,
                      /* [] */0
                    ];
                  }
                } else {
                  exit$2 = 1;
                }
                if (exit$2 === 1) {
                  var expr = Curry._1(Parse[/* expression */6], Parser_env$Jeason.with_no_let(/* true */1, Parser_env$Jeason.with_no_in(/* true */1, env$12)));
                  match$10 = /* tuple */[
                    /* Some */[/* InitExpression */Block.__(1, [expr])],
                    /* [] */0
                  ];
                }
                var init = match$10[0];
                var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$12);
                var exit$3 = 0;
                if (t === /* T_OF */62 || async) {
                  assert_can_be_forin_or_forof(env$12, /* InvalidLHSInForOf */18, init);
                  var left;
                  if (init) {
                    var match$14 = init[0];
                    left = match$14.tag ? /* LeftExpression */Block.__(1, [match$14[0]]) : /* LeftDeclaration */Block.__(0, [match$14[0]]);
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "parser_flow.ml",
                            2696,
                            22
                          ]
                        ];
                  }
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_OF */62);
                  var right = Curry._1(Parse[/* assignment */8], env$12);
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_RPAREN */6);
                  var body$4 = Curry._1(Parse[/* statement */1], Parser_env$Jeason.with_in_loop(/* true */1, env$12));
                  return /* tuple */[
                          Loc$Jeason.btwn(start_loc$10, body$4[0]),
                          /* ForOf */Block.__(16, [/* record */[
                                /* left */left,
                                /* right */right,
                                /* body */body$4,
                                /* async */async
                              ]])
                        ];
                } else if (typeof t === "number" && t === 17) {
                  assert_can_be_forin_or_forof(env$12, /* InvalidLHSInForIn */17, init);
                  var left$1;
                  if (init) {
                    var match$15 = init[0];
                    left$1 = match$15.tag ? /* LeftExpression */Block.__(1, [match$15[0]]) : /* LeftDeclaration */Block.__(0, [match$15[0]]);
                  } else {
                    throw [
                          Caml_builtin_exceptions.assert_failure,
                          [
                            "parser_flow.ml",
                            2713,
                            22
                          ]
                        ];
                  }
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_IN */17);
                  var right$1 = Curry._1(Parse[/* expression */6], env$12);
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_RPAREN */6);
                  var body$5 = Curry._1(Parse[/* statement */1], Parser_env$Jeason.with_in_loop(/* true */1, env$12));
                  return /* tuple */[
                          Loc$Jeason.btwn(start_loc$10, body$5[0]),
                          /* ForIn */Block.__(15, [/* record */[
                                /* left */left$1,
                                /* right */right$1,
                                /* body */body$5,
                                /* each : false */0
                              ]])
                        ];
                } else {
                  exit$3 = 1;
                }
                if (exit$3 === 1) {
                  List.iter((function(env$12){
                      return function (param) {
                        return Parser_env$Jeason.error_at(env$12, param);
                      }
                      }(env$12)), match$10[1]);
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_SEMICOLON */9);
                  var match$16 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$12);
                  var test$2 = typeof match$16 === "number" ? (
                      match$16 !== 9 ? /* Some */[Curry._1(Parse[/* expression */6], env$12)] : /* None */0
                    ) : /* Some */[Curry._1(Parse[/* expression */6], env$12)];
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_SEMICOLON */9);
                  var match$17 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$12);
                  var update = typeof match$17 === "number" ? (
                      match$17 !== 6 ? /* Some */[Curry._1(Parse[/* expression */6], env$12)] : /* None */0
                    ) : /* Some */[Curry._1(Parse[/* expression */6], env$12)];
                  Parser_env$Jeason.Expect[/* token */0](env$12, /* T_RPAREN */6);
                  var body$6 = Curry._1(Parse[/* statement */1], Parser_env$Jeason.with_in_loop(/* true */1, env$12));
                  return /* tuple */[
                          Loc$Jeason.btwn(start_loc$10, body$6[0]),
                          /* For */Block.__(14, [/* record */[
                                /* init */init,
                                /* test */test$2,
                                /* update */update,
                                /* body */body$6
                              ]])
                        ];
                }
                case 0 : 
            case 2 : 
            case 3 : 
            case 4 : 
            case 5 : 
            case 6 : 
            case 7 : 
            case 8 : 
            case 10 : 
            case 11 : 
            case 12 : 
            case 13 : 
            case 14 : 
            case 15 : 
            case 17 : 
            case 18 : 
            case 21 : 
            case 27 : 
            case 28 : 
            case 29 : 
            case 30 : 
            case 31 : 
            case 33 : 
            case 34 : 
            case 36 : 
            case 38 : 
            case 40 : 
            case 41 : 
            case 42 : 
            case 43 : 
            case 44 : 
            case 45 : 
            case 46 : 
            case 47 : 
            case 48 : 
            case 49 : 
            case 50 : 
            case 51 : 
            case 52 : 
            case 53 : 
            case 54 : 
            case 55 : 
            case 56 : 
            case 57 : 
            case 58 : 
                exit$1 = 2;
                break;
            case 59 : 
                var env$13 = env;
                var start_loc$11 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$13);
                Parser_env$Jeason.Expect[/* token */0](env$13, /* T_DEBUGGER */59);
                var match$18 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$13);
                var end_loc$8 = match$18 ? match$18[0] : start_loc$11;
                Parser_env$Jeason.Eat[/* semicolon */4](env$13);
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$11, end_loc$8),
                        /* Debugger */1
                      ];
            
          }
        }
      } else {
        Parser_env$Jeason.error_unexpected(env);
        return /* tuple */[
                Parser_env$Jeason.Peek[/* loc */2](/* None */0, env),
                /* Empty */0
              ];
      }
    } else {
      exit$1 = 2;
    }
    if (exit$1 === 2) {
      if (Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, env)) {
        var env$14 = env;
        var expr$1 = Curry._1(Parse[/* expression */6], env$14);
        var match$19 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$14);
        var match$20 = expr$1[1];
        var loc$5 = expr$1[0];
        var exit$4 = 0;
        if (typeof match$20 === "number" || !(match$20.tag === 17 && typeof match$19 === "number" && match$19 === 80)) {
          exit$4 = 1;
        } else {
          var label$4 = match$20[0];
          var name$2 = label$4[1];
          Parser_env$Jeason.Expect[/* token */0](env$14, /* T_COLON */80);
          if (Curry._2(SSet[/* mem */2], name$2, Parser_env$Jeason.labels(env$14))) {
            Parser_env$Jeason.error_at(env$14, /* tuple */[
                  loc$5,
                  /* Redeclaration */Block.__(5, [
                      "Label",
                      name$2
                    ])
                ]);
          }
          var env$15 = Parser_env$Jeason.add_label(env$14, name$2);
          var labeled_stmt = Curry._1(Parse[/* statement */1], env$15);
          return /* tuple */[
                  Loc$Jeason.btwn(loc$5, labeled_stmt[0]),
                  /* Labeled */Block.__(3, [/* record */[
                        /* label */label$4,
                        /* body */labeled_stmt
                      ]])
                ];
        }
        if (exit$4 === 1) {
          var match$21 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$14);
          var end_loc$9 = match$21 ? match$21[0] : expr$1[0];
          Parser_env$Jeason.Eat[/* semicolon */4](env$14);
          return /* tuple */[
                  Loc$Jeason.btwn(expr$1[0], end_loc$9),
                  /* Expression */Block.__(1, [/* record */[/* expression */expr$1]])
                ];
        }
        
      } else if (typeof match === "number") {
        if (match >= 33) {
          if (match >= 51) {
            if (match !== 80) {
              return expression(env);
            } else {
              exit = 1;
            }
          } else if (match >= 40) {
            switch (match - 40 | 0) {
              case 3 : 
                  return _if(env);
              case 0 : 
              case 4 : 
              case 5 : 
              case 6 : 
              case 7 : 
              case 8 : 
                  return expression(env);
              case 1 : 
              case 2 : 
              case 9 : 
              case 10 : 
                  exit = 1;
                  break;
              
            }
          } else {
            exit = 1;
          }
        } else if (match >= 21) {
          return expression(env);
        } else {
          switch (match) {
            case 0 : 
            case 1 : 
            case 3 : 
            case 4 : 
            case 5 : 
            case 7 : 
            case 14 : 
            case 15 : 
            case 16 : 
                return expression(env);
            case 2 : 
            case 6 : 
            case 8 : 
            case 9 : 
            case 10 : 
            case 11 : 
            case 12 : 
            case 13 : 
            case 17 : 
            case 18 : 
                exit = 1;
                break;
            
          }
        }
      } else {
        return expression(env);
      }
    }
    if (exit === 1) {
      Parser_env$Jeason.error_unexpected(env);
      Parser_env$Jeason.Eat[/* token */0](env);
      continue ;
      
    }
    
  };
}

function module_item(env) {
  var decorators = decorator_list(env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number") {
    var switcher = match - 49 | 0;
    if (switcher > 11 || switcher < 0) {
      return statement_list_item(/* Some */[decorators], env);
    } else {
      switch (switcher) {
        case 0 : 
            var env$1 = env;
            var decorators$1 = decorators;
            var env$2 = Parser_env$Jeason.with_in_export(/* true */1, Parser_env$Jeason.with_strict(/* true */1, env$1));
            var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2);
            Parser_env$Jeason.Expect[/* token */0](env$2, /* T_EXPORT */49);
            var match$1 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$2);
            var exit = 0;
            if (typeof match$1 === "number") {
              if (match$1 >= 53) {
                if (match$1 !== 100) {
                  if (match$1 >= 64) {
                    exit = 1;
                  } else {
                    switch (match$1 - 53 | 0) {
                      case 0 : 
                          if (!Parser_env$Jeason.should_parse_types(env$2)) {
                            Parser_env$Jeason.error(env$2, /* UnexpectedTypeExport */10);
                          }
                          var $$interface$1 = $$interface(env$2);
                          var match$2 = $$interface$1[1];
                          if (typeof match$2 === "number" || match$2.tag !== 20) {
                            Pervasives.failwith("Internal Flow Error! Parsed `export interface` into something other than an interface declaration!");
                          } else {
                            Parser_env$Jeason.record_export(env$2, /* tuple */[
                                  $$interface$1[0],
                                  extract_ident_name(match$2[0][/* id */0])
                                ]);
                          }
                          var end_loc = $$interface$1[0];
                          return /* tuple */[
                                  Loc$Jeason.btwn(start_loc, end_loc),
                                  /* ExportNamedDeclaration */Block.__(27, [/* record */[
                                        /* declaration : Some */[$$interface$1],
                                        /* specifiers : None */0,
                                        /* source : None */0,
                                        /* exportKind : ExportType */0
                                      ]])
                                ];
                      case 8 : 
                          if (Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env$2) !== /* T_LCURLY */1) {
                            if (!Parser_env$Jeason.should_parse_types(env$2)) {
                              Parser_env$Jeason.error(env$2, /* UnexpectedTypeExport */10);
                            }
                            var type_alias$1 = type_alias(env$2);
                            var match$3 = type_alias$1[1];
                            if (typeof match$3 === "number" || match$3.tag !== 7) {
                              Pervasives.failwith("Internal Flow Error! Parsed `export type` into something other than a type alias!");
                            } else {
                              Parser_env$Jeason.record_export(env$2, /* tuple */[
                                    type_alias$1[0],
                                    extract_ident_name(match$3[0][/* id */0])
                                  ]);
                            }
                            var end_loc$1 = type_alias$1[0];
                            return /* tuple */[
                                    Loc$Jeason.btwn(start_loc, end_loc$1),
                                    /* ExportNamedDeclaration */Block.__(27, [/* record */[
                                          /* declaration : Some */[type_alias$1],
                                          /* specifiers : None */0,
                                          /* source : None */0,
                                          /* exportKind : ExportType */0
                                        ]])
                                  ];
                          } else {
                            exit = 1;
                          }
                          break;
                      case 1 : 
                      case 2 : 
                      case 3 : 
                      case 4 : 
                      case 5 : 
                      case 6 : 
                      case 7 : 
                      case 9 : 
                          exit = 1;
                          break;
                      case 10 : 
                          exit = 2;
                          break;
                      
                    }
                  }
                } else {
                  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2);
                  Parser_env$Jeason.Expect[/* token */0](env$2, /* T_MULT */100);
                  var parse_export_star_as = Parser_env$Jeason.parse_options(env$2)[/* esproposal_export_star_as */3];
                  var local_name = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$2) === "as" ? (Parser_env$Jeason.Expect[/* contextual */2](env$2, "as"), parse_export_star_as ? /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, env$2)] : (Parser_env$Jeason.error(env$2, /* UnexpectedTypeDeclaration */8), /* None */0)) : /* None */0;
                  var specifiers = /* Some */[/* ExportBatchSpecifier */Block.__(1, [
                        loc,
                        local_name
                      ])];
                  var source$1 = export_source(env$2);
                  var match$4 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$2);
                  var end_loc$2 = match$4 ? match$4[0] : source$1[0];
                  var source$2 = /* Some */[source$1];
                  Parser_env$Jeason.Eat[/* semicolon */4](env$2);
                  return /* tuple */[
                          Loc$Jeason.btwn(start_loc, end_loc$2),
                          /* ExportNamedDeclaration */Block.__(27, [/* record */[
                                /* declaration : None */0,
                                /* specifiers */specifiers,
                                /* source */source$2,
                                /* exportKind : ExportValue */1
                              ]])
                        ];
                }
              } else {
                var switcher$1 = match$1 - 14 | 0;
                if (switcher$1 > 26 || switcher$1 < 0) {
                  exit = 1;
                } else {
                  switch (switcher$1) {
                    case 22 : 
                        Parser_env$Jeason.Expect[/* token */0](env$2, /* T_DEFAULT */36);
                        Parser_env$Jeason.record_export(env$2, /* tuple */[
                              Loc$Jeason.btwn(start_loc, Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2)),
                              "default"
                            ]);
                        var match$5 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$2);
                        var match$6;
                        var exit$1 = 0;
                        if (typeof match$5 === "number" && match$5 === 15) {
                          var fn = _function(env$2);
                          match$6 = /* tuple */[
                            fn[0],
                            /* Declaration */Block.__(0, [fn])
                          ];
                        } else {
                          exit$1 = 3;
                        }
                        if (exit$1 === 3) {
                          if (Parser_env$Jeason.Peek[/* is_class */11](/* None */0, env$2)) {
                            var _class = class_declaration(env$2, decorators$1);
                            match$6 = /* tuple */[
                              _class[0],
                              /* Declaration */Block.__(0, [_class])
                            ];
                          } else {
                            var expr = Curry._1(Parse[/* assignment */8], env$2);
                            var match$7 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$2);
                            var end_loc$3 = match$7 ? match$7[0] : expr[0];
                            Parser_env$Jeason.Eat[/* semicolon */4](env$2);
                            match$6 = /* tuple */[
                              end_loc$3,
                              /* Expression */Block.__(1, [expr])
                            ];
                          }
                        }
                        return /* tuple */[
                                Loc$Jeason.btwn(start_loc, match$6[0]),
                                /* ExportDefaultDeclaration */Block.__(28, [/* record */[
                                      /* declaration */match$6[1],
                                      /* exportKind : ExportValue */1
                                    ]])
                              ];
                    case 2 : 
                    case 3 : 
                    case 4 : 
                    case 5 : 
                    case 6 : 
                    case 7 : 
                    case 8 : 
                    case 9 : 
                    case 11 : 
                    case 12 : 
                    case 15 : 
                    case 16 : 
                    case 17 : 
                    case 18 : 
                    case 19 : 
                    case 20 : 
                    case 21 : 
                    case 23 : 
                    case 24 : 
                    case 25 : 
                        exit = 1;
                        break;
                    case 0 : 
                    case 1 : 
                    case 10 : 
                    case 13 : 
                    case 14 : 
                    case 26 : 
                        exit = 2;
                        break;
                    
                  }
                }
              }
            } else {
              exit = 1;
            }
            switch (exit) {
              case 1 : 
                  var match$8 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$2);
                  var exportKind = typeof match$8 === "number" && match$8 === 61 ? (Parser_env$Jeason.Eat[/* token */0](env$2), /* ExportType */0) : /* ExportValue */1;
                  Parser_env$Jeason.Expect[/* token */0](env$2, /* T_LCURLY */1);
                  var match$9 = export_specifiers_and_errs(env$2, /* [] */0, /* [] */0);
                  var specifiers$1 = /* Some */[/* ExportSpecifiers */Block.__(0, [match$9[0]])];
                  var end_loc$4 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$2);
                  Parser_env$Jeason.Expect[/* token */0](env$2, /* T_RCURLY */2);
                  var source$3 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$2) === "from" ? /* Some */[export_source(env$2)] : (List.iter((function (param) {
                              return Parser_env$Jeason.error_at(env$2, param);
                            }), match$9[1]), /* None */0);
                  var match$10 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$2);
                  var end_loc$5 = match$10 ? match$10[0] : (
                      source$3 ? source$3[0][0] : end_loc$4
                    );
                  Parser_env$Jeason.Eat[/* semicolon */4](env$2);
                  return /* tuple */[
                          Loc$Jeason.btwn(start_loc, end_loc$5),
                          /* ExportNamedDeclaration */Block.__(27, [/* record */[
                                /* declaration : None */0,
                                /* specifiers */specifiers$1,
                                /* source */source$3,
                                /* exportKind */exportKind
                              ]])
                        ];
              case 2 : 
                  var stmt = Curry._2(Parse[/* statement_list_item */2], /* Some */[decorators$1], env$2);
                  var match$11 = stmt[1];
                  var loc$1 = stmt[0];
                  var names;
                  if (typeof match$11 === "number") {
                    names = Pervasives.failwith("Internal Flow Error! Unexpected export statement declaration!");
                  } else {
                    switch (match$11.tag | 0) {
                      case 17 : 
                          var match$12 = match$11[0][/* id */0];
                          if (match$12) {
                            names = /* :: */[
                              /* tuple */[
                                loc$1,
                                extract_ident_name(match$12[0])
                              ],
                              /* [] */0
                            ];
                          } else {
                            Parser_env$Jeason.error_at(env$2, /* tuple */[
                                  loc$1,
                                  /* ExportNamelessFunction */56
                                ]);
                            names = /* [] */0;
                          }
                          break;
                      case 18 : 
                          names = List.fold_left((function (names, param) {
                                  var id = param[1][/* id */0];
                                  var param$1 = names;
                                  var param$2 = /* :: */[
                                    id,
                                    /* [] */0
                                  ];
                                  return List.fold_left(fold, param$1, param$2);
                                }), /* [] */0, match$11[0][/* declarations */0]);
                          break;
                      case 19 : 
                          var match$13 = match$11[0][/* id */0];
                          if (match$13) {
                            names = /* :: */[
                              /* tuple */[
                                loc$1,
                                extract_ident_name(match$13[0])
                              ],
                              /* [] */0
                            ];
                          } else {
                            Parser_env$Jeason.error_at(env$2, /* tuple */[
                                  loc$1,
                                  /* ExportNamelessClass */55
                                ]);
                            names = /* [] */0;
                          }
                          break;
                      default:
                        names = Pervasives.failwith("Internal Flow Error! Unexpected export statement declaration!");
                    }
                  }
                  List.iter((function (param) {
                          return Parser_env$Jeason.record_export(env$2, param);
                        }), names);
                  return /* tuple */[
                          Loc$Jeason.btwn(start_loc, stmt[0]),
                          /* ExportNamedDeclaration */Block.__(27, [/* record */[
                                /* declaration : Some */[stmt],
                                /* specifiers : None */0,
                                /* source : None */0,
                                /* exportKind : ExportValue */1
                              ]])
                        ];
              
            }
        case 1 : 
            Parser_env$Jeason.error_on_decorators(env)(decorators);
            var env$3 = env;
            var env$4 = Parser_env$Jeason.with_strict(/* true */1, env$3);
            var start_loc$1 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env$4);
            Parser_env$Jeason.Expect[/* token */0](env$4, /* T_IMPORT */50);
            var match$14 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$4);
            var match$15;
            if (typeof match$14 === "number") {
              if (match$14 !== 46) {
                if (match$14 !== 61) {
                  match$15 = /* tuple */[
                    /* ImportValue */2,
                    /* None */0
                  ];
                } else {
                  if (!Parser_env$Jeason.should_parse_types(env$4)) {
                    Parser_env$Jeason.error(env$4, /* UnexpectedTypeImport */9);
                  }
                  match$15 = /* tuple */[
                    /* ImportType */0,
                    /* Some */[Curry._2(Parse[/* identifier */12], /* None */0, env$4)]
                  ];
                }
              } else {
                if (!Parser_env$Jeason.should_parse_types(env$4)) {
                  Parser_env$Jeason.error(env$4, /* UnexpectedTypeImport */9);
                }
                Parser_env$Jeason.Expect[/* token */0](env$4, /* T_TYPEOF */46);
                match$15 = /* tuple */[
                  /* ImportTypeof */1,
                  /* None */0
                ];
              }
            } else {
              match$15 = /* tuple */[
                /* ImportValue */2,
                /* None */0
              ];
            }
            var type_ident = match$15[1];
            var importKind = match$15[0];
            var match$16 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$4);
            var match$17 = Parser_env$Jeason.Peek[/* is_identifier */8](/* None */0, env$4);
            var exit$2 = 0;
            var exit$3 = 0;
            if (typeof match$16 === "number") {
              if (match$16 === 10) {
                exit$2 = 1;
              } else {
                exit$3 = 2;
              }
            } else if (match$16.tag === 1 && importKind === /* ImportValue */2) {
              var match$18 = match$16[0];
              var octal = match$18[3];
              var raw = match$18[2];
              var value = match$18[1];
              var str_loc = match$18[0];
              if (octal) {
                Parser_env$Jeason.strict_error(env$4, /* StrictOctalLiteral */32);
              }
              Parser_env$Jeason.Expect[/* token */0](env$4, /* T_STRING */Block.__(1, [/* tuple */[
                        str_loc,
                        value,
                        raw,
                        octal
                      ]]));
              var value$1 = /* String */Block.__(0, [value]);
              var source_001 = /* record */[
                /* value */value$1,
                /* raw */raw
              ];
              var source$4 = /* tuple */[
                str_loc,
                source_001
              ];
              var match$19 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$4);
              var end_loc$6 = match$19 ? match$19[0] : str_loc;
              Parser_env$Jeason.Eat[/* semicolon */4](env$4);
              return /* tuple */[
                      Loc$Jeason.btwn(start_loc$1, end_loc$6),
                      /* ImportDeclaration */Block.__(29, [/* record */[
                            /* importKind */importKind,
                            /* source */source$4,
                            /* specifiers : [] */0
                          ]])
                    ];
            } else {
              exit$3 = 2;
            }
            if (exit$3 === 2) {
              if (match$17 !== 0) {
                exit$2 = 1;
              } else {
                var specifiers$2 = named_or_namespace_specifier(env$4);
                var source$5 = source(env$4);
                var match$20 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$4);
                var end_loc$7 = match$20 ? match$20[0] : source$5[0];
                Parser_env$Jeason.Eat[/* semicolon */4](env$4);
                return /* tuple */[
                        Loc$Jeason.btwn(start_loc$1, end_loc$7),
                        /* ImportDeclaration */Block.__(29, [/* record */[
                              /* importKind */importKind,
                              /* source */source$5,
                              /* specifiers */specifiers$2
                            ]])
                      ];
              }
            }
            if (exit$2 === 1) {
              var match$21 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$4);
              var match$22 = Parser_env$Jeason.Peek[/* value */1](/* None */0, env$4);
              var match$23;
              var exit$4 = 0;
              if (type_ident && typeof match$21 === "number") {
                var type_ident$1 = type_ident[0];
                if (match$21 !== 10) {
                  if (match$21 !== 0 || match$22 !== "from") {
                    exit$4 = 2;
                  } else {
                    match$23 = /* tuple */[
                      /* ImportValue */2,
                      /* ImportDefaultSpecifier */Block.__(1, [type_ident$1])
                    ];
                  }
                } else {
                  match$23 = /* tuple */[
                    /* ImportValue */2,
                    /* ImportDefaultSpecifier */Block.__(1, [type_ident$1])
                  ];
                }
              } else {
                exit$4 = 2;
              }
              if (exit$4 === 2) {
                match$23 = /* tuple */[
                  importKind,
                  /* ImportDefaultSpecifier */Block.__(1, [Curry._2(Parse[/* identifier */12], /* None */0, env$4)])
                ];
              }
              var match$24 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$4);
              var additional_specifiers = typeof match$24 === "number" && match$24 === 10 ? (Parser_env$Jeason.Expect[/* token */0](env$4, /* T_COMMA */10), named_or_namespace_specifier(env$4)) : /* [] */0;
              var source$6 = source(env$4);
              var match$25 = Parser_env$Jeason.Peek[/* semicolon_loc */7](/* None */0, env$4);
              var end_loc$8 = match$25 ? match$25[0] : source$6[0];
              Parser_env$Jeason.Eat[/* semicolon */4](env$4);
              return /* tuple */[
                      Loc$Jeason.btwn(start_loc$1, end_loc$8),
                      /* ImportDeclaration */Block.__(29, [/* record */[
                            /* importKind */match$23[0],
                            /* source */source$6,
                            /* specifiers : :: */[
                              match$23[1],
                              additional_specifiers
                            ]
                          ]])
                    ];
            }
            case 2 : 
        case 3 : 
        case 4 : 
        case 5 : 
        case 6 : 
        case 7 : 
        case 8 : 
        case 9 : 
        case 10 : 
            return statement_list_item(/* Some */[decorators], env);
        case 11 : 
            if (Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env) === /* T_EXPORT */49) {
              Parser_env$Jeason.error_on_decorators(env)(decorators);
              return declare_export_declaration(/* None */0, env);
            } else {
              return statement_list_item(/* Some */[decorators], env);
            }
        
      }
    }
  } else {
    return statement_list_item(/* Some */[decorators], env);
  }
}

var class_declaration$1 = class_declaration;

function statement_list(_env, term_fn, item_fn, _param) {
  while(true) {
    var param = _param;
    var env = _env;
    var stmts = param[1];
    var string_tokens = param[0];
    var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
    var exit = 0;
    if (typeof t === "number" && t === 108) {
      return /* tuple */[
              env,
              string_tokens,
              stmts
            ];
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (Curry._1(term_fn, t)) {
        return /* tuple */[
                env,
                string_tokens,
                stmts
              ];
      } else {
        var string_token_000 = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
        var string_token_001 = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
        var string_token = /* tuple */[
          string_token_000,
          string_token_001
        ];
        var possible_directive = Curry._1(item_fn, env);
        var stmts$1 = /* :: */[
          possible_directive,
          stmts
        ];
        var match = possible_directive[1];
        if (typeof match === "number") {
          return /* tuple */[
                  env,
                  string_tokens,
                  stmts$1
                ];
        } else if (match.tag === 1) {
          var match$1 = match[0][/* expression */0];
          var match$2 = match$1[1];
          if (typeof match$2 === "number") {
            return /* tuple */[
                    env,
                    string_tokens,
                    stmts$1
                  ];
          } else if (match$2.tag === 18) {
            var match$3 = match$2[0][/* value */0];
            if (typeof match$3 === "number") {
              return /* tuple */[
                      env,
                      string_tokens,
                      stmts$1
                    ];
            } else if (match$3.tag) {
              return /* tuple */[
                      env,
                      string_tokens,
                      stmts$1
                    ];
            } else {
              var loc = match$1[0];
              var len = loc[/* _end */2][/* column */1] - loc[/* start */1][/* column */1] | 0;
              var strict = Parser_env$Jeason.in_strict_mode(env) || +(match$3[0] === "use strict" && len === 12);
              var string_tokens$1 = /* :: */[
                string_token,
                string_tokens
              ];
              _param = /* tuple */[
                string_tokens$1,
                stmts$1
              ];
              _env = Parser_env$Jeason.with_strict(strict, env);
              continue ;
              
            }
          } else {
            return /* tuple */[
                    env,
                    string_tokens,
                    stmts$1
                  ];
          }
        } else {
          return /* tuple */[
                  env,
                  string_tokens,
                  stmts$1
                ];
        }
      }
    }
    
  };
}

function directives(env, term_fn, item_fn) {
  var match = statement_list(env, term_fn, item_fn, /* tuple */[
        /* [] */0,
        /* [] */0
      ]);
  var env$1 = match[0];
  List.iter((function (param) {
          var env$2 = env$1;
          var param$1 = param;
          var token = param$1[1];
          var exit = 0;
          if (typeof token === "number" || token.tag !== 1) {
            exit = 1;
          } else if (token[0][3]) {
            return Parser_env$Jeason.strict_error_at(env$2, /* tuple */[
                        param$1[0],
                        /* StrictOctalLiteral */32
                      ]);
          } else {
            return 0;
          }
          if (exit === 1) {
            return Pervasives.failwith("Nooo: " + (Lexer_flow$Jeason.Token[/* token_to_string */0](token) + "\n"));
          }
          
        }), List.rev(match[1]));
  return /* tuple */[
          env$1,
          match[2]
        ];
}

function statement_list$1(term_fn, env) {
  var env$1 = env;
  var term_fn$1 = term_fn;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
    var exit = 0;
    if (typeof t === "number" && t === 108) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (Curry._1(term_fn$1, t)) {
        return List.rev(acc);
      } else {
        _acc = /* :: */[
          statement_list_item(/* None */0, env$1),
          acc
        ];
        continue ;
        
      }
    }
    
  };
}

function module_body(term_fn, env) {
  var env$1 = env;
  var term_fn$1 = term_fn;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env$1);
    var exit = 0;
    if (typeof t === "number" && t === 108) {
      return List.rev(acc);
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (Curry._1(term_fn$1, t)) {
        return List.rev(acc);
      } else {
        _acc = /* :: */[
          module_item(env$1),
          acc
        ];
        continue ;
        
      }
    }
    
  };
}

function statement_list_with_directives(term_fn, env) {
  var match = Curry._3(directives, env, term_fn, (function (eta) {
          return statement_list_item(/* None */0, eta);
        }));
  var env$1 = match[0];
  var stmts = Curry._2(statement_list$1, term_fn, env$1);
  var stmts$1 = List.fold_left((function (acc, stmt) {
          return /* :: */[
                  stmt,
                  acc
                ];
        }), stmts, match[1]);
  return /* tuple */[
          stmts$1,
          Parser_env$Jeason.in_strict_mode(env$1)
        ];
}

function identifier$2(restricted_error, env) {
  var loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  var name = Parser_env$Jeason.Peek[/* value */1](/* None */0, env);
  var t = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof t === "number" && t === 28) {
    if (Parser_env$Jeason.in_strict_mode(env)) {
      Parser_env$Jeason.strict_error(env, /* StrictReservedWord */40);
    } else if (Parser_env$Jeason.no_let(env)) {
      Parser_env$Jeason.error(env, /* UnexpectedToken */Block.__(1, [name]));
    }
    Parser_env$Jeason.Eat[/* token */0](env);
  } else {
    exit = 1;
  }
  if (exit === 1) {
    if (Parser_env$Jeason.is_strict_reserved(name)) {
      Parser_env$Jeason.strict_error(env, /* StrictReservedWord */40);
      Parser_env$Jeason.Eat[/* token */0](env);
    } else if (typeof t === "number" && !(t > 64 || t < 60)) {
      Parser_env$Jeason.Expect[/* token */0](env, t);
    } else {
      Parser_env$Jeason.Expect[/* token */0](env, /* T_IDENTIFIER */0);
    }
  }
  if (restricted_error) {
    if (Parser_env$Jeason.is_restricted(name)) {
      Parser_env$Jeason.strict_error_at(env, /* tuple */[
            loc,
            restricted_error[0]
          ]);
    }
    
  }
  return /* tuple */[
          loc,
          name
        ];
}

function module_body_with_directives(env, term_fn) {
  var match = Curry._3(directives, env, term_fn, module_item);
  var stmts = Curry._2(module_body, term_fn, match[0]);
  return List.fold_left((function (acc, stmt) {
                return /* :: */[
                        stmt,
                        acc
                      ];
              }), stmts, match[1]);
}

function program(env) {
  var stmts = module_body_with_directives(env, (function () {
          return /* false */0;
        }));
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_EOF */108);
  var loc = stmts ? Loc$Jeason.btwn(List.hd(stmts)[0], List.hd(List.rev(stmts))[0]) : end_loc;
  var comments = List.rev(Parser_env$Jeason.comments(env));
  return /* tuple */[
          loc,
          stmts,
          comments
        ];
}

function expression$1(env) {
  var expr = Curry._1(assignment, env);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  if (typeof match === "number" && match === 10) {
    return sequence(env, /* :: */[
                expr,
                /* [] */0
              ]);
  } else {
    return expr;
  }
}

function identifier_with_type(env, $staropt$star, restricted_error) {
  var no_optional = $staropt$star ? $staropt$star[0] : /* false */0;
  return with_loc((function (param) {
                var no_optional$1 = no_optional;
                var restricted_error$1 = restricted_error;
                var env = param;
                var name = identifier$2(/* Some */[restricted_error$1], env);
                var optional = 1 - no_optional$1 && +(Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_PLING */79);
                if (optional) {
                  if (!Parser_env$Jeason.should_parse_types(env)) {
                    Parser_env$Jeason.error(env, /* UnexpectedTypeAnnotation */7);
                  }
                  Parser_env$Jeason.Expect[/* token */0](env, /* T_PLING */79);
                }
                var typeAnnotation = Parser_env$Jeason.Peek[/* token */0](/* None */0, env) === /* T_COLON */80 ? /* Some */[wrap(annotation, env)] : /* None */0;
                return /* record */[
                        /* name */name,
                        /* typeAnnotation */typeAnnotation,
                        /* optional */optional
                      ];
              }), env);
}

function block_body(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
  var term_fn = function (t) {
    return +(t === /* T_RCURLY */2);
  };
  var body = Curry._2(statement_list$1, term_fn, env);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* body */body]
        ];
}

function function_block_body(env) {
  var start_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_LCURLY */1);
  var term_fn = function (t) {
    return +(t === /* T_RCURLY */2);
  };
  var match = statement_list_with_directives(term_fn, env);
  var end_loc = Parser_env$Jeason.Peek[/* loc */2](/* None */0, env);
  Parser_env$Jeason.Expect[/* token */0](env, /* T_RCURLY */2);
  return /* tuple */[
          Loc$Jeason.btwn(start_loc, end_loc),
          /* record */[/* body */match[0]],
          match[1]
        ];
}

Caml_module.update_mod([[
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]], Parse, /* module */[
      /* program */program,
      /* statement */statement,
      /* statement_list_item */statement_list_item,
      /* statement_list */statement_list$1,
      /* statement_list_with_directives */statement_list_with_directives,
      /* module_body */module_body,
      /* expression */expression$1,
      /* conditional */conditional,
      /* assignment */assignment,
      /* left_hand_side */left_hand_side,
      /* object_initializer */_initializer,
      /* array_initializer */array_initializer,
      /* identifier */identifier$2,
      /* identifier_or_reserved_keyword */identifier_or_reserved_keyword,
      /* identifier_with_type */identifier_with_type,
      /* block_body */block_body,
      /* function_block_body */function_block_body,
      /* jsx_element */element,
      /* pattern */pattern$1,
      /* pattern_from_expr */from_expr,
      /* object_key */key,
      /* class_declaration */class_declaration$1,
      /* class_expression */class_expression,
      /* is_assignable_lhs */is_assignable_lhs
    ]);

function do_parse(env, parser, fail) {
  var ast = Curry._1(parser, env);
  var error_list = filter_duplicate_errors(Parser_env$Jeason.errors(env));
  if (fail && error_list !== /* [] */0) {
    throw [
          Parse_error$Jeason.$$Error,
          error_list
        ];
  }
  return /* tuple */[
          ast,
          error_list
        ];
}

function parse_program(fail, $staropt$star, $staropt$star$1, filename, content) {
  var token_sink = $staropt$star ? $staropt$star[0] : /* None */0;
  var parse_options = $staropt$star$1 ? $staropt$star$1[0] : /* None */0;
  var env = Parser_env$Jeason.init_env(/* Some */[token_sink], /* Some */[parse_options], filename, content);
  return do_parse(env, Parse[/* program */0], fail);
}

function program$1($staropt$star, $staropt$star$1, $staropt$star$2, content) {
  var fail = $staropt$star ? $staropt$star[0] : /* true */1;
  var token_sink = $staropt$star$1 ? $staropt$star$1[0] : /* None */0;
  var parse_options = $staropt$star$2 ? $staropt$star$2[0] : /* None */0;
  return parse_program(fail, /* Some */[token_sink], /* Some */[parse_options], /* None */0, content);
}

function program_file($staropt$star, $staropt$star$1, $staropt$star$2, content, filename) {
  var fail = $staropt$star ? $staropt$star[0] : /* true */1;
  var token_sink = $staropt$star$1 ? $staropt$star$1[0] : /* None */0;
  var parse_options = $staropt$star$2 ? $staropt$star$2[0] : /* None */0;
  return parse_program(fail, /* Some */[token_sink], /* Some */[parse_options], filename, content);
}

function json_file($staropt$star, $staropt$star$1, $staropt$star$2, content, filename) {
  var fail = $staropt$star ? $staropt$star[0] : /* true */1;
  var token_sink = $staropt$star$1 ? $staropt$star$1[0] : /* None */0;
  var parse_options = $staropt$star$2 ? $staropt$star$2[0] : /* None */0;
  var env = Parser_env$Jeason.init_env(/* Some */[token_sink], /* Some */[parse_options], filename, content);
  var match = Parser_env$Jeason.Peek[/* token */0](/* None */0, env);
  var exit = 0;
  if (typeof match === "number") {
    switch (match) {
      case 1 : 
      case 7 : 
      case 29 : 
      case 30 : 
      case 31 : 
          exit = 1;
          break;
      case 98 : 
          var match$1 = Parser_env$Jeason.Peek[/* token */0](/* Some */[1], env);
          if (typeof match$1 === "number") {
            Parser_env$Jeason.error_unexpected(env);
            throw [
                  Parse_error$Jeason.$$Error,
                  Parser_env$Jeason.errors(env)
                ];
          } else if (match$1.tag) {
            Parser_env$Jeason.error_unexpected(env);
            throw [
                  Parse_error$Jeason.$$Error,
                  Parser_env$Jeason.errors(env)
                ];
          } else {
            return do_parse(env, Parse[/* expression */6], fail);
          }
      default:
        Parser_env$Jeason.error_unexpected(env);
        throw [
              Parse_error$Jeason.$$Error,
              Parser_env$Jeason.errors(env)
            ];
    }
  } else {
    switch (match.tag | 0) {
      case 0 : 
      case 1 : 
          exit = 1;
          break;
      default:
        Parser_env$Jeason.error_unexpected(env);
        throw [
              Parse_error$Jeason.$$Error,
              Parser_env$Jeason.errors(env)
            ];
    }
  }
  if (exit === 1) {
    return do_parse(env, Parse[/* expression */6], fail);
  }
  
}

function left_hand_side$1(env) {
  var ast = Curry._1(Parse[/* left_hand_side */9], Parser_env$Jeason.with_no_new(/* true */1, env));
  Parser_env$Jeason.Expect[/* token */0](env, /* T_EOF */108);
  return ast;
}

function jsx_pragma_expression(content, filename) {
  var env = Parser_env$Jeason.init_env(/* Some */[/* None */0], /* Some */[/* None */0], filename, content);
  return do_parse(env, left_hand_side$1, /* true */1);
}

var Token = 0;

var Ast = 0;

var $$Error = 0;

exports.Token = Token;
exports.Ast = Ast;
exports.$$Error = $$Error;
exports.SSet = SSet;
exports.SMap = SMap;
exports.filter_duplicate_errors = filter_duplicate_errors;
exports.with_loc = with_loc;
exports.string_starts_with = string_starts_with;
exports.Parse = Parse;
exports.do_parse = do_parse;
exports.parse_program = parse_program;
exports.program = program$1;
exports.program_file = program_file;
exports.json_file = json_file;
exports.jsx_pragma_expression = jsx_pragma_expression;
/* SSet Not a pure module */
