// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var $$Set = require("bs-platform/lib/js/set.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Queue = require("bs-platform/lib/js/queue.js");
var Lexing = require("bs-platform/lib/js/lexing.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Lexer_flow$Jeason = require("./lexer_flow.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var SSet = $$Set.Make([$$String.compare]);

$$Map.Make([$$String.compare]);

function debug_string_of_lex_mode(mode) {
  switch (mode) {
    case 0 : 
        return "NORMAL";
    case 1 : 
        return "TYPE";
    case 2 : 
        return "JSX_TAG";
    case 3 : 
        return "JSX_CHILD";
    case 4 : 
        return "TEMPLATE";
    case 5 : 
        return "REGEXP";
    
  }
}

var Lex_mode = /* module */[/* debug_string_of_lex_mode */debug_string_of_lex_mode];

function create(lex_env, mode) {
  var lexbuf = Lexer_flow$Jeason.Lex_env[/* lexbuf */3](lex_env);
  var lexbuf$1 = /* record */[
    /* refill_buff */lexbuf[/* refill_buff */0],
    /* lex_buffer */lexbuf[/* lex_buffer */1],
    /* lex_buffer_len */lexbuf[/* lex_buffer_len */2],
    /* lex_abs_pos */lexbuf[/* lex_abs_pos */3],
    /* lex_start_pos */lexbuf[/* lex_start_pos */4],
    /* lex_curr_pos */lexbuf[/* lex_curr_pos */5],
    /* lex_last_pos */lexbuf[/* lex_last_pos */6],
    /* lex_last_action */lexbuf[/* lex_last_action */7],
    /* lex_eof_reached */lexbuf[/* lex_eof_reached */8],
    /* lex_mem */lexbuf[/* lex_mem */9],
    /* lex_start_p */lexbuf[/* lex_start_p */10],
    /* lex_curr_p */lexbuf[/* lex_curr_p */11]
  ];
  var lex_env$1 = Lexer_flow$Jeason.Lex_env[/* with_lexbuf */4](lexbuf$1, lex_env);
  return /* record */[
          /* la_results : array */[],
          /* la_num_lexed */0,
          /* la_lex_mode */mode,
          /* la_lex_env */lex_env$1
        ];
}

function next_power_of_two(n) {
  var _i = 1;
  while(true) {
    var i = _i;
    if (i >= n) {
      return i;
    } else {
      _i = (i << 1);
      continue ;
    }
  };
}

function grow(t, n) {
  if (t[/* la_results */0].length < n) {
    var new_size = next_power_of_two(n);
    var filler = function (i) {
      if (i < t[/* la_results */0].length) {
        return Caml_array.caml_array_get(t[/* la_results */0], i);
      } else {
        return /* None */0;
      }
    };
    var new_arr = $$Array.init(new_size, filler);
    t[/* la_results */0] = new_arr;
    return /* () */0;
  } else {
    return 0;
  }
}

function lex(t) {
  var lex_env = t[/* la_lex_env */3];
  var match = t[/* la_lex_mode */2];
  var match$1;
  switch (match) {
    case 0 : 
        match$1 = Lexer_flow$Jeason.token(lex_env);
        break;
    case 1 : 
        match$1 = Lexer_flow$Jeason.type_token(lex_env);
        break;
    case 2 : 
        match$1 = Lexer_flow$Jeason.jsx_tag(lex_env);
        break;
    case 3 : 
        match$1 = Lexer_flow$Jeason.jsx_child(lex_env);
        break;
    case 4 : 
        match$1 = Lexer_flow$Jeason.template_tail(lex_env);
        break;
    case 5 : 
        match$1 = Lexer_flow$Jeason.regexp(lex_env);
        break;
    
  }
  var lex_env$1 = match$1[0];
  var lexbuf = Lexer_flow$Jeason.Lex_env[/* lexbuf */3](lex_env$1);
  var lexbuf$1 = /* record */[
    /* refill_buff */lexbuf[/* refill_buff */0],
    /* lex_buffer */lexbuf[/* lex_buffer */1],
    /* lex_buffer_len */lexbuf[/* lex_buffer_len */2],
    /* lex_abs_pos */lexbuf[/* lex_abs_pos */3],
    /* lex_start_pos */lexbuf[/* lex_start_pos */4],
    /* lex_curr_pos */lexbuf[/* lex_curr_pos */5],
    /* lex_last_pos */lexbuf[/* lex_last_pos */6],
    /* lex_last_action */lexbuf[/* lex_last_action */7],
    /* lex_eof_reached */lexbuf[/* lex_eof_reached */8],
    /* lex_mem */lexbuf[/* lex_mem */9],
    /* lex_start_p */lexbuf[/* lex_start_p */10],
    /* lex_curr_p */lexbuf[/* lex_curr_p */11]
  ];
  var cloned_env = Lexer_flow$Jeason.Lex_env[/* with_lexbuf */4](lexbuf$1, lex_env$1);
  t[/* la_lex_env */3] = lex_env$1;
  Caml_array.caml_array_set(t[/* la_results */0], t[/* la_num_lexed */1], /* Some */[/* tuple */[
          cloned_env,
          match$1[1]
        ]]);
  t[/* la_num_lexed */1] = t[/* la_num_lexed */1] + 1 | 0;
  return /* () */0;
}

function lex_until(t, i) {
  grow(t, i + 1 | 0);
  while(t[/* la_num_lexed */1] <= i) {
    lex(t);
  };
  return /* () */0;
}

var default_parse_options = /* record */[
  /* esproposal_class_instance_fields */false,
  /* esproposal_class_static_fields */false,
  /* esproposal_decorators */false,
  /* esproposal_export_star_as */false,
  /* types */true,
  /* use_strict */false
];

function init_env($staropt$star, $staropt$star$1, source, content) {
  var token_sink = $staropt$star ? $staropt$star[0] : /* None */0;
  var parse_options = $staropt$star$1 ? $staropt$star$1[0] : /* None */0;
  var lb = Lexing.from_string(content);
  if (source) {
    var match = source[0];
    if (typeof match !== "number") {
      var init = lb[/* lex_curr_p */11];
      lb[/* lex_curr_p */11] = /* record */[
        /* pos_fname */match[0],
        /* pos_lnum */init[/* pos_lnum */1],
        /* pos_bol */init[/* pos_bol */2],
        /* pos_cnum */init[/* pos_cnum */3]
      ];
    }
    
  }
  var parse_options$1 = parse_options ? parse_options[0] : default_parse_options;
  var enable_types_in_comments = parse_options$1[/* types */4];
  var lex_env = Lexer_flow$Jeason.Lex_env[/* new_lex_env */1](source, lb, enable_types_in_comments);
  return /* record */[
          /* errors */[/* [] */0],
          /* comments */[/* [] */0],
          /* labels */SSet[/* empty */0],
          /* exports */[SSet[/* empty */0]],
          /* last_loc */[/* None */0],
          /* in_strict_mode */parse_options$1[/* use_strict */5],
          /* in_export */false,
          /* in_loop */false,
          /* in_switch */false,
          /* in_function */false,
          /* no_in */false,
          /* no_call */false,
          /* no_let */false,
          /* no_anon_function_type */false,
          /* no_new */false,
          /* allow_yield */true,
          /* allow_await */false,
          /* error_callback : None */0,
          /* lex_mode_stack */[/* :: */[
              /* NORMAL */0,
              /* [] */0
            ]],
          /* lex_env */[lex_env],
          /* lookahead */[create(lex_env, /* NORMAL */0)],
          /* token_sink */[token_sink],
          /* parse_options */parse_options$1,
          /* source */source
        ];
}

function in_strict_mode(env) {
  return env[/* in_strict_mode */5];
}

function in_export(env) {
  return env[/* in_export */6];
}

function comments(env) {
  return env[/* comments */1][0];
}

function labels(env) {
  return env[/* labels */2];
}

function in_loop(env) {
  return env[/* in_loop */7];
}

function in_switch(env) {
  return env[/* in_switch */8];
}

function in_function(env) {
  return env[/* in_function */9];
}

function allow_yield(env) {
  return env[/* allow_yield */15];
}

function allow_await(env) {
  return env[/* allow_await */16];
}

function no_in(env) {
  return env[/* no_in */10];
}

function no_call(env) {
  return env[/* no_call */11];
}

function no_let(env) {
  return env[/* no_let */12];
}

function no_anon_function_type(env) {
  return env[/* no_anon_function_type */13];
}

function no_new(env) {
  return env[/* no_new */14];
}

function errors(env) {
  return env[/* errors */0][0];
}

function parse_options(env) {
  return env[/* parse_options */22];
}

function source(env) {
  return env[/* source */23];
}

function should_parse_types(env) {
  return env[/* parse_options */22][/* types */4];
}

function error_at(env, param) {
  var e = param[1];
  env[/* errors */0][0] = /* :: */[
    /* tuple */[
      param[0],
      e
    ],
    env[/* errors */0][0]
  ];
  var match = env[/* error_callback */17];
  if (match) {
    return Curry._2(match[0], env, e);
  } else {
    return /* () */0;
  }
}

function comment_list(env) {
  return (function (param) {
      return List.iter((function (c) {
                    env[/* comments */1][0] = /* :: */[
                      c,
                      env[/* comments */1][0]
                    ];
                    return /* () */0;
                  }), param);
    });
}

function record_export(env, param) {
  var export_name = param[1];
  var $$exports = env[/* exports */3][0];
  if (Curry._2(SSet[/* mem */2], export_name, $$exports)) {
    return error_at(env, /* tuple */[
                param[0],
                /* DuplicateExport */Block.__(7, [export_name])
              ]);
  } else {
    env[/* exports */3][0] = Curry._2(SSet[/* add */3], export_name, env[/* exports */3][0]);
    return /* () */0;
  }
}

function lookahead($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  if (i >= 2) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "parser_env.ml",
            292,
            2
          ]
        ];
  }
  var t = env[/* lookahead */20][0];
  var i$1 = i;
  lex_until(t, i$1);
  var match = Caml_array.caml_array_get(t[/* la_results */0], i$1);
  if (match) {
    return match[0][1];
  } else {
    return Pervasives.failwith("Lookahead.peek failed");
  }
}

function with_strict(in_strict_mode, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* in_strict_mode */5] = in_strict_mode;
  return newrecord;
}

function with_in_function(in_function, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* in_function */9] = in_function;
  return newrecord;
}

function with_allow_yield(allow_yield, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* allow_yield */15] = allow_yield;
  return newrecord;
}

function with_allow_await(allow_await, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* allow_await */16] = allow_await;
  return newrecord;
}

function with_no_let(no_let, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* no_let */12] = no_let;
  return newrecord;
}

function with_in_loop(in_loop, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* in_loop */7] = in_loop;
  return newrecord;
}

function with_no_in(no_in, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* no_in */10] = no_in;
  return newrecord;
}

function with_no_anon_function_type(no_anon_function_type, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* no_anon_function_type */13] = no_anon_function_type;
  return newrecord;
}

function with_no_new(no_new, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* no_new */14] = no_new;
  return newrecord;
}

function with_in_switch(in_switch, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* in_switch */8] = in_switch;
  return newrecord;
}

function with_in_export(in_export, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* in_export */6] = in_export;
  return newrecord;
}

function with_no_call(no_call, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* no_call */11] = no_call;
  return newrecord;
}

function with_error_callback(error_callback, env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* error_callback */17] = /* Some */[error_callback];
  return newrecord;
}

function error_list(env) {
  return (function (param) {
      return List.iter((function (param) {
                    return error_at(env, param);
                  }), param);
    });
}

function last_loc(env) {
  return env[/* last_loc */4][0];
}

function without_error_callback(env) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* error_callback */17] = /* None */0;
  return newrecord;
}

function add_label(env, label) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* labels */2] = Curry._2(SSet[/* add */3], label, env[/* labels */2]);
  return newrecord;
}

function enter_function(env, async, generator) {
  var newrecord = Caml_array.caml_array_dup(env);
  newrecord[/* labels */2] = SSet[/* empty */0];
  newrecord[/* in_loop */7] = false;
  newrecord[/* in_switch */8] = false;
  newrecord[/* in_function */9] = true;
  newrecord[/* allow_yield */15] = generator;
  newrecord[/* allow_await */16] = async;
  return newrecord;
}

function is_future_reserved(param) {
  if (param === "enum") {
    return true;
  } else {
    return false;
  }
}

function is_strict_reserved(param) {
  switch (param) {
    case "implements" : 
    case "interface" : 
    case "package" : 
    case "private" : 
    case "protected" : 
    case "public" : 
    case "static" : 
    case "yield" : 
        return true;
    default:
      return false;
  }
}

function is_restricted(param) {
  switch (param) {
    case "arguments" : 
    case "eval" : 
        return true;
    default:
      return false;
  }
}

function token($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  return Lexer_flow$Jeason.Lex_result[/* token */0](lookahead(/* Some */[i], env));
}

function value($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  return Lexer_flow$Jeason.Lex_result[/* value */2](lookahead(/* Some */[i], env));
}

function loc($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  return Lexer_flow$Jeason.Lex_result[/* loc */1](lookahead(/* Some */[i], env));
}

function errors$1($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  return Lexer_flow$Jeason.Lex_result[/* errors */4](lookahead(/* Some */[i], env));
}

function comments$1($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  return Lexer_flow$Jeason.Lex_result[/* comments */3](lookahead(/* Some */[i], env));
}

function lex_env($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  var t = env[/* lookahead */20][0];
  var i$1 = i;
  lex_until(t, i$1);
  var match = Caml_array.caml_array_get(t[/* la_results */0], i$1);
  if (match) {
    return match[0][0];
  } else {
    return Pervasives.failwith("Lookahead.peek failed");
  }
}

function is_line_terminator(env) {
  var match = env[/* last_loc */4][0];
  if (match) {
    return loc(/* None */0, env)[/* start */1][/* line */0] > match[0][/* start */1][/* line */0];
  } else {
    return false;
  }
}

function is_implicit_semicolon(env) {
  var match = token(/* None */0, env);
  if (typeof match === "number") {
    var switcher = match - 3 | 0;
    if (switcher > 104 || switcher < 0) {
      if ((switcher + 1 >>> 0) > 106) {
        return is_line_terminator(env);
      } else {
        return true;
      }
    } else if (switcher !== 6) {
      return is_line_terminator(env);
    } else {
      return false;
    }
  } else {
    return is_line_terminator(env);
  }
}

function semicolon_loc($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  if (token(/* Some */[i], env) === /* T_SEMICOLON */9) {
    return /* Some */[loc(/* Some */[i], env)];
  } else {
    return /* None */0;
  }
}

function is_identifier($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  var name = value(/* Some */[i], env);
  var match = token(/* Some */[i], env);
  if (is_strict_reserved(name) || is_restricted(name) || is_future_reserved(name)) {
    return true;
  } else if (typeof match === "number") {
    var switcher = match - 1 | 0;
    if (switcher > 58 || switcher < 0) {
      if (switcher >= 64) {
        return false;
      } else {
        return true;
      }
    } else if (switcher !== 27) {
      return false;
    } else {
      return true;
    }
  } else {
    return false;
  }
}

function is_literal_property_name($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  if (is_identifier(/* Some */[i], env)) {
    return true;
  } else {
    var match = token(/* Some */[i], env);
    if (typeof match === "number") {
      return false;
    } else {
      switch (match.tag | 0) {
        case 0 : 
        case 1 : 
            return true;
        default:
          return false;
      }
    }
  }
}

function is_function($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  if (token(/* Some */[i], env) === /* T_FUNCTION */15) {
    return true;
  } else if (token(/* Some */[i], env) === /* T_ASYNC */63) {
    return token(/* Some */[i + 1 | 0], env) === /* T_FUNCTION */15;
  } else {
    return false;
  }
}

function is_class($staropt$star, env) {
  var i = $staropt$star ? $staropt$star[0] : 0;
  var match = token(/* Some */[i], env);
  if (typeof match === "number" && !(match !== 14 && match !== 40)) {
    return true;
  } else {
    return false;
  }
}

function error(env, e) {
  var loc$1 = loc(/* None */0, env);
  return error_at(env, /* tuple */[
              loc$1,
              e
            ]);
}

function get_unexpected_error(param) {
  var exit = 0;
  var tmp = param[0];
  if (typeof tmp === "number") {
    switch (tmp) {
      case 0 : 
          return /* UnexpectedIdentifier */2;
      case 108 : 
          return /* UnexpectedEOS */4;
      default:
        exit = 1;
    }
  } else {
    switch (tmp.tag | 0) {
      case 0 : 
          return /* UnexpectedNumber */0;
      case 1 : 
      case 4 : 
          return /* UnexpectedString */1;
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    var word = param[1];
    if (is_future_reserved(word)) {
      return /* UnexpectedReserved */3;
    } else if (is_strict_reserved(word)) {
      return /* StrictReservedWord */40;
    } else {
      return /* UnexpectedToken */Block.__(1, [word]);
    }
  }
  
}

function error_unexpected(env) {
  var param = errors$1(/* None */0, env);
  List.iter((function (param) {
          return error_at(env, param);
        }), param);
  return error(env, get_unexpected_error(/* tuple */[
                  token(/* None */0, env),
                  value(/* None */0, env)
                ]));
}

function error_on_decorators(env) {
  return (function (param) {
      return List.iter((function (decorator) {
                    return error_at(env, /* tuple */[
                                decorator[0],
                                /* UnsupportedDecorator */57
                              ]);
                  }), param);
    });
}

function strict_error(env, e) {
  if (env[/* in_strict_mode */5]) {
    return error(env, e);
  } else {
    return 0;
  }
}

function strict_error_at(env, param) {
  if (env[/* in_strict_mode */5]) {
    return error_at(env, /* tuple */[
                param[0],
                param[1]
              ]);
  } else {
    return 0;
  }
}

function token$1(env) {
  var match = env[/* token_sink */21][0];
  if (match) {
    var token_loc = loc(/* None */0, env);
    var token$2 = token(/* None */0, env);
    var token_value = value(/* None */0, env);
    Curry._1(match[0], /* record */[
          /* token_loc */token_loc,
          /* token */token$2,
          /* token_context */List.hd(env[/* lex_mode_stack */18][0]),
          /* token_value */token_value
        ]);
  }
  env[/* lex_env */19][0] = lex_env(/* None */0, env);
  var param = errors$1(/* None */0, env);
  List.iter((function (param) {
          return error_at(env, param);
        }), param);
  comment_list(env)(comments$1(/* None */0, env));
  env[/* last_loc */4][0] = /* Some */[loc(/* None */0, env)];
  var t = env[/* lookahead */20][0];
  lex_until(t, 0);
  if (t[/* la_num_lexed */1] > 1) {
    $$Array.blit(t[/* la_results */0], 1, t[/* la_results */0], 0, t[/* la_num_lexed */1] - 1 | 0);
  }
  Caml_array.caml_array_set(t[/* la_results */0], t[/* la_num_lexed */1] - 1 | 0, /* None */0);
  t[/* la_num_lexed */1] = t[/* la_num_lexed */1] - 1 | 0;
  return /* () */0;
}

function push_lex_mode(env, mode) {
  env[/* lex_mode_stack */18][0] = /* :: */[
    mode,
    env[/* lex_mode_stack */18][0]
  ];
  env[/* lookahead */20][0] = create(env[/* lex_env */19][0], List.hd(env[/* lex_mode_stack */18][0]));
  return /* () */0;
}

function pop_lex_mode(env) {
  var match = env[/* lex_mode_stack */18][0];
  var new_stack = match ? match[1] : Pervasives.failwith("Popping lex mode from empty stack");
  env[/* lex_mode_stack */18][0] = new_stack;
  env[/* lookahead */20][0] = create(env[/* lex_env */19][0], List.hd(env[/* lex_mode_stack */18][0]));
  return /* () */0;
}

function double_pop_lex_mode(env) {
  var match = env[/* lex_mode_stack */18][0];
  var new_stack;
  if (match) {
    var match$1 = match[1];
    new_stack = match$1 ? match$1[1] : Pervasives.failwith("Popping lex mode from empty stack");
  } else {
    new_stack = Pervasives.failwith("Popping lex mode from empty stack");
  }
  env[/* lex_mode_stack */18][0] = new_stack;
  env[/* lookahead */20][0] = create(env[/* lex_env */19][0], List.hd(env[/* lex_mode_stack */18][0]));
  return /* () */0;
}

function semicolon(env) {
  if (is_implicit_semicolon(env)) {
    return 0;
  } else if (token(/* None */0, env) === /* T_SEMICOLON */9) {
    return token$1(env);
  } else {
    return error_unexpected(env);
  }
}

var Eat = /* module */[
  /* token */token$1,
  /* push_lex_mode */push_lex_mode,
  /* pop_lex_mode */pop_lex_mode,
  /* double_pop_lex_mode */double_pop_lex_mode,
  /* semicolon */semicolon
];

function token$2(env, t) {
  if (Caml_obj.caml_notequal(token(/* None */0, env), t)) {
    error_unexpected(env);
  }
  return token$1(env);
}

function maybe(env, t) {
  if (Caml_obj.caml_equal(token(/* None */0, env), t)) {
    token$1(env);
    return true;
  } else {
    return false;
  }
}

function contextual(env, str) {
  if (value(/* None */0, env) !== str) {
    error_unexpected(env);
  }
  return token$1(env);
}

var Expect = /* module */[
  /* token */token$2,
  /* maybe */maybe,
  /* contextual */contextual
];

var Rollback = Caml_exceptions.create("Parser_env-Jeason.Try.Rollback");

function save_state(env) {
  var match = env[/* token_sink */21][0];
  var token_buffer;
  if (match) {
    var buffer = Queue.create(/* () */0);
    env[/* token_sink */21][0] = /* Some */[(function (token_data) {
          return Queue.add(token_data, buffer);
        })];
    token_buffer = /* Some */[/* tuple */[
        match[0],
        buffer
      ]];
  } else {
    token_buffer = /* None */0;
  }
  return /* record */[
          /* saved_errors */env[/* errors */0][0],
          /* saved_comments */env[/* comments */1][0],
          /* saved_last_loc */env[/* last_loc */4][0],
          /* saved_lex_mode_stack */env[/* lex_mode_stack */18][0],
          /* saved_lex_env */env[/* lex_env */19][0],
          /* token_buffer */token_buffer
        ];
}

function reset_token_sink(flush, env, token_buffer_info) {
  if (token_buffer_info) {
    var match = token_buffer_info[0];
    var orig_token_sink = match[0];
    env[/* token_sink */21][0] = /* Some */[orig_token_sink];
    if (flush) {
      return Queue.iter(orig_token_sink, match[1]);
    } else {
      return 0;
    }
  } else {
    return /* () */0;
  }
}

function to_parse(env, parse) {
  var saved_state = save_state(env);
  try {
    var env$1 = env;
    var saved_state$1 = saved_state;
    var result = Curry._1(parse, env);
    reset_token_sink(true, env$1, saved_state$1[/* token_buffer */5]);
    return /* ParsedSuccessfully */[result];
  }
  catch (exn){
    if (exn === Rollback) {
      var env$2 = env;
      var saved_state$2 = saved_state;
      reset_token_sink(false, env$2, saved_state$2[/* token_buffer */5]);
      env$2[/* errors */0][0] = saved_state$2[/* saved_errors */0];
      env$2[/* comments */1][0] = saved_state$2[/* saved_comments */1];
      env$2[/* last_loc */4][0] = saved_state$2[/* saved_last_loc */2];
      env$2[/* lex_mode_stack */18][0] = saved_state$2[/* saved_lex_mode_stack */3];
      env$2[/* lex_env */19][0] = saved_state$2[/* saved_lex_env */4];
      env$2[/* lookahead */20][0] = create(env$2[/* lex_env */19][0], List.hd(env$2[/* lex_mode_stack */18][0]));
      return /* FailedToParse */0;
    } else {
      throw exn;
    }
  }
}

var Peek = [
  token,
  value,
  loc,
  errors$1,
  comments$1,
  is_line_terminator,
  is_implicit_semicolon,
  semicolon_loc,
  is_identifier,
  is_literal_property_name,
  is_function,
  is_class
];

var Try = [
  Rollback,
  to_parse
];

exports.SSet = SSet;
exports.Lex_mode = Lex_mode;
exports.default_parse_options = default_parse_options;
exports.init_env = init_env;
exports.in_strict_mode = in_strict_mode;
exports.last_loc = last_loc;
exports.in_export = in_export;
exports.labels = labels;
exports.comments = comments;
exports.in_loop = in_loop;
exports.in_switch = in_switch;
exports.in_function = in_function;
exports.allow_yield = allow_yield;
exports.allow_await = allow_await;
exports.no_in = no_in;
exports.no_call = no_call;
exports.no_let = no_let;
exports.no_anon_function_type = no_anon_function_type;
exports.no_new = no_new;
exports.errors = errors;
exports.parse_options = parse_options;
exports.source = source;
exports.should_parse_types = should_parse_types;
exports.error_at = error_at;
exports.error = error;
exports.error_unexpected = error_unexpected;
exports.error_on_decorators = error_on_decorators;
exports.strict_error = strict_error;
exports.strict_error_at = strict_error_at;
exports.get_unexpected_error = get_unexpected_error;
exports.comment_list = comment_list;
exports.error_list = error_list;
exports.record_export = record_export;
exports.with_strict = with_strict;
exports.with_in_function = with_in_function;
exports.with_allow_yield = with_allow_yield;
exports.with_allow_await = with_allow_await;
exports.with_no_let = with_no_let;
exports.with_in_loop = with_in_loop;
exports.with_no_in = with_no_in;
exports.with_no_anon_function_type = with_no_anon_function_type;
exports.with_no_new = with_no_new;
exports.with_in_switch = with_in_switch;
exports.with_in_export = with_in_export;
exports.with_no_call = with_no_call;
exports.with_error_callback = with_error_callback;
exports.without_error_callback = without_error_callback;
exports.add_label = add_label;
exports.enter_function = enter_function;
exports.is_future_reserved = is_future_reserved;
exports.is_strict_reserved = is_strict_reserved;
exports.is_restricted = is_restricted;
exports.Peek = Peek;
exports.Eat = Eat;
exports.Expect = Expect;
exports.Try = Try;
/* SSet Not a pure module */
