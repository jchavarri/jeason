// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Arg = require("bs-platform/lib/js/arg.js");
var Char = require("bs-platform/lib/js/char.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function number(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return 1;
      case 1 : 
          return 2;
      case 2 : 
          return 5;
      case 3 : 
          return 6;
      case 4 : 
          return 10;
      case 5 : 
          return 11;
      case 6 : 
          return 12;
      case 7 : 
          return 14;
      case 8 : 
          return 16;
      case 9 : 
          return 20;
      case 10 : 
          return 21;
      case 11 : 
          return 23;
      case 12 : 
          return 25;
      case 13 : 
          return 28;
      case 14 : 
          return 29;
      case 15 : 
          return 39;
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return 3;
      case 1 : 
          return 4;
      case 2 : 
          return 7;
      case 3 : 
          return 8;
      case 4 : 
          return 9;
      case 5 : 
          return 13;
      case 6 : 
          return 15;
      case 7 : 
          return 17;
      case 8 : 
          return 18;
      case 9 : 
          return 19;
      case 10 : 
          return 22;
      case 11 : 
          return 24;
      case 12 : 
          return 26;
      case 13 : 
          return 27;
      case 14 : 
          return 30;
      case 15 : 
          return 31;
      case 16 : 
          return 32;
      case 17 : 
          return 33;
      case 18 : 
          return 34;
      case 19 : 
          return 35;
      case 20 : 
          return 36;
      case 21 : 
          return 37;
      case 22 : 
          return 38;
      case 23 : 
          return 40;
      case 24 : 
          return 41;
      case 25 : 
          return 42;
      case 26 : 
          return 43;
      case 27 : 
          return 44;
      case 28 : 
          return 45;
      case 29 : 
          return 46;
      case 30 : 
          return 47;
      case 31 : 
          return 48;
      case 32 : 
          return 49;
      case 33 : 
          return 50;
      
    }
  }
}

function letter(param) {
  var switcher = param - 97 | 0;
  if (switcher > 25 || switcher < 0) {
    throw [
          Caml_builtin_exceptions.assert_failure,
          [
            "warnings.ml",
            164,
            9
          ]
        ];
  } else {
    switch (switcher) {
      case 0 : 
          var loop = function (i) {
            if (i === 0) {
              return /* [] */0;
            } else {
              return /* :: */[
                      i,
                      loop(i - 1 | 0)
                    ];
            }
          };
          return loop(50);
      case 2 : 
          return /* :: */[
                  1,
                  /* :: */[
                    2,
                    /* [] */0
                  ]
                ];
      case 3 : 
          return /* :: */[
                  3,
                  /* [] */0
                ];
      case 4 : 
          return /* :: */[
                  4,
                  /* [] */0
                ];
      case 5 : 
          return /* :: */[
                  5,
                  /* [] */0
                ];
      case 10 : 
          return /* :: */[
                  32,
                  /* :: */[
                    33,
                    /* :: */[
                      34,
                      /* :: */[
                        35,
                        /* :: */[
                          36,
                          /* :: */[
                            37,
                            /* :: */[
                              38,
                              /* :: */[
                                39,
                                /* [] */0
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ];
      case 11 : 
          return /* :: */[
                  6,
                  /* [] */0
                ];
      case 12 : 
          return /* :: */[
                  7,
                  /* [] */0
                ];
      case 15 : 
          return /* :: */[
                  8,
                  /* [] */0
                ];
      case 17 : 
          return /* :: */[
                  9,
                  /* [] */0
                ];
      case 18 : 
          return /* :: */[
                  10,
                  /* [] */0
                ];
      case 20 : 
          return /* :: */[
                  11,
                  /* :: */[
                    12,
                    /* [] */0
                  ]
                ];
      case 21 : 
          return /* :: */[
                  13,
                  /* [] */0
                ];
      case 1 : 
      case 6 : 
      case 7 : 
      case 8 : 
      case 9 : 
      case 13 : 
      case 14 : 
      case 16 : 
      case 19 : 
      case 22 : 
          return /* [] */0;
      case 23 : 
          return /* :: */[
                  14,
                  /* :: */[
                    15,
                    /* :: */[
                      16,
                      /* :: */[
                        17,
                        /* :: */[
                          18,
                          /* :: */[
                            19,
                            /* :: */[
                              20,
                              /* :: */[
                                21,
                                /* :: */[
                                  22,
                                  /* :: */[
                                    23,
                                    /* :: */[
                                      24,
                                      /* :: */[
                                        25,
                                        /* :: */[
                                          30,
                                          /* [] */0
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ];
      case 24 : 
          return /* :: */[
                  26,
                  /* [] */0
                ];
      case 25 : 
          return /* :: */[
                  27,
                  /* [] */0
                ];
      
    }
  }
}

var current = [/* record */[
    /* active */Caml_array.caml_make_vect(51, /* true */1),
    /* error */Caml_array.caml_make_vect(51, /* false */0)
  ]];

function backup() {
  return current[0];
}

function restore(x) {
  current[0] = x;
  return /* () */0;
}

function is_active(x) {
  return Caml_array.caml_array_get(current[0][/* active */0], number(x));
}

function is_error(x) {
  return Caml_array.caml_array_get(current[0][/* error */1], number(x));
}

function parse_opt(error, active, flags, s) {
  var set = function (i) {
    return Caml_array.caml_array_set(flags, i, /* true */1);
  };
  var clear = function (i) {
    return Caml_array.caml_array_set(flags, i, /* false */0);
  };
  var set_all = function (i) {
    Caml_array.caml_array_set(active, i, /* true */1);
    return Caml_array.caml_array_set(error, i, /* true */1);
  };
  var get_num = function (_n, _i) {
    while(true) {
      var i = _i;
      var n = _n;
      if (i >= s.length) {
        return /* tuple */[
                i,
                n
              ];
      } else {
        var match = Caml_string.get(s, i);
        if (match > 57 || match < 48) {
          return /* tuple */[
                  i,
                  n
                ];
        } else {
          _i = i + 1 | 0;
          _n = (Caml_int32.imul(10, n) + Caml_string.get(s, i) | 0) - /* "0" */48 | 0;
          continue ;
          
        }
      }
    };
  };
  var get_range = function (i) {
    var match = get_num(0, i);
    var n1 = match[1];
    var i$1 = match[0];
    if ((i$1 + 2 | 0) < s.length && Caml_string.get(s, i$1) === /* "." */46 && Caml_string.get(s, i$1 + 1 | 0) === /* "." */46) {
      var match$1 = get_num(0, i$1 + 2 | 0);
      var n2 = match$1[1];
      if (n2 < n1) {
        throw [
              Arg.Bad,
              "Ill-formed list of warnings"
            ];
      }
      return /* tuple */[
              match$1[0],
              n1,
              n2
            ];
    } else {
      return /* tuple */[
              i$1,
              n1,
              n1
            ];
    }
  };
  var loop = function (_i) {
    while(true) {
      var i = _i;
      if (i >= s.length) {
        return /* () */0;
      } else {
        var c = Caml_string.get(s, i);
        if (c >= 65) {
          if (c >= 97) {
            if (c >= 123) {
              throw [
                    Arg.Bad,
                    "Ill-formed list of warnings"
                  ];
            } else {
              List.iter(clear, letter(Caml_string.get(s, i)));
              _i = i + 1 | 0;
              continue ;
              
            }
          } else if (c >= 91) {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          } else {
            List.iter(set, letter(Char.lowercase(Caml_string.get(s, i))));
            _i = i + 1 | 0;
            continue ;
            
          }
        } else if (c >= 46) {
          if (c >= 64) {
            return loop_letter_num(set_all, i + 1 | 0);
          } else {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          }
        } else if (c >= 43) {
          switch (c - 43 | 0) {
            case 0 : 
                return loop_letter_num(set, i + 1 | 0);
            case 1 : 
                throw [
                      Arg.Bad,
                      "Ill-formed list of warnings"
                    ];
            case 2 : 
                return loop_letter_num(clear, i + 1 | 0);
            
          }
        } else {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        }
      }
    };
  };
  var loop_letter_num = function (myset, i) {
    if (i >= s.length) {
      throw [
            Arg.Bad,
            "Ill-formed list of warnings"
          ];
    } else {
      var match = Caml_string.get(s, i);
      if (match >= 65) {
        if (match >= 97) {
          if (match >= 123) {
            throw [
                  Arg.Bad,
                  "Ill-formed list of warnings"
                ];
          } else {
            List.iter(myset, letter(Caml_string.get(s, i)));
            return loop(i + 1 | 0);
          }
        } else if (match >= 91) {
          throw [
                Arg.Bad,
                "Ill-formed list of warnings"
              ];
        } else {
          List.iter(myset, letter(Char.lowercase(Caml_string.get(s, i))));
          return loop(i + 1 | 0);
        }
      } else if (match > 57 || match < 48) {
        throw [
              Arg.Bad,
              "Ill-formed list of warnings"
            ];
      } else {
        var match$1 = get_range(i);
        for(var n = match$1[1] ,n_finish = Caml_primitive.caml_int_min(match$1[2], 50); n <= n_finish; ++n){
          Curry._1(myset, n);
        }
        return loop(match$1[0]);
      }
    }
  };
  return loop(0);
}

function parse_options(errflag, s) {
  var error = $$Array.copy(current[0][/* error */1]);
  var active = $$Array.copy(current[0][/* active */0]);
  parse_opt(error, active, errflag ? error : active, s);
  current[0] = /* record */[
    /* active */active,
    /* error */error
  ];
  return /* () */0;
}

var defaults_w = "+a-4-6-7-9-27-29-32..39-41..42-44-45-48-50";

var defaults_warn_error = "-a";

parse_options(/* false */0, defaults_w);

parse_options(/* true */1, defaults_warn_error);

function message(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return "this is the start of a comment.";
      case 1 : 
          return "this is not the end of a comment.";
      case 2 : 
          return "this function application is partial,\nmaybe some arguments are missing.";
      case 3 : 
          return "labels were omitted in the application of this function.";
      case 4 : 
          return "this expression should have type unit.";
      case 5 : 
          return "this match case is unused.";
      case 6 : 
          return "this sub-pattern is unused.";
      case 7 : 
          return "illegal backslash escape in string.";
      case 8 : 
          return "this optional argument cannot be erased.";
      case 9 : 
          return "this argument will not be used by the function.";
      case 10 : 
          return "this statement never returns (or has an unsound type.)";
      case 11 : 
          return "all the fields are explicitly listed in this record:\nthe 'with' clause is useless.";
      case 12 : 
          return "bad style, all clauses in this pattern-matching are guarded.";
      case 13 : 
          return "wildcard pattern given as argument to a constant constructor";
      case 14 : 
          return "unescaped end-of-line in a string constant (non-portable code)";
      case 15 : 
          return "unused rec flag.";
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return "deprecated: " + param[0];
      case 1 : 
          var s = param[0];
          if (s === "") {
            return "this pattern-matching is fragile.";
          } else {
            return "this pattern-matching is fragile.\nIt will remain exhaustive when constructors are added to type " + (s + ".");
          }
      case 2 : 
          var match = param[0];
          if (match) {
            var slist = match[1];
            var lab = match[0];
            if (slist) {
              return $$String.concat(" ", /* :: */[
                          "the following methods are overridden by the class",
                          /* :: */[
                            lab,
                            /* :: */[
                              ":\n ",
                              slist
                            ]
                          ]
                        ]);
            } else {
              return "the method " + (lab + " is overridden.");
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "warnings.ml",
                    271,
                    26
                  ]
                ];
          }
      case 3 : 
          var s$1 = param[0];
          if (s$1 === "") {
            return "this pattern-matching is not exhaustive.";
          } else {
            return "this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\n" + s$1;
          }
      case 4 : 
          return "the following labels are not bound in this record pattern:\n" + (param[0] + "\nEither bind these labels explicitly or add '; _' to the pattern.");
      case 5 : 
          var match$1 = param[0];
          if (match$1) {
            var slist$1 = match$1[1];
            var lab$1 = match$1[0];
            if (slist$1) {
              return $$String.concat(" ", /* :: */[
                          "the following instance variables are overridden by the class",
                          /* :: */[
                            lab$1,
                            /* :: */[
                              ":\n ",
                              slist$1
                            ]
                          ]
                        ]) + "\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)";
            } else {
              return "the instance variable " + (lab$1 + " is overridden.\nThe behaviour changed in ocaml 3.10 (previous behaviour was hiding.)");
            }
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  [
                    "warnings.ml",
                    291,
                    37
                  ]
                ];
          }
      case 6 : 
          return "the following private methods were made public implicitly:\n " + ($$String.concat(" ", param[0]) + ".");
      case 7 : 
          return "the virtual method " + (param[0] + " is not declared.");
      case 8 : 
          return param[0] + " is not principal.";
      case 9 : 
          return param[0] + " without principality.";
      case 10 : 
          return param[0];
      case 11 : 
          return "bad source file name: \"" + (param[0] + "\" is not a valid module name.");
      case 12 : 
      case 13 : 
          return "unused variable " + (param[0] + ".");
      case 14 : 
          return Curry._4(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " is defined in both types ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* String_literal */Block.__(11, [
                                                      " and ",
                                                      /* String */Block.__(2, [
                                                          /* No_padding */0,
                                                          /* Char_literal */Block.__(12, [
                                                              /* "." */46,
                                                              /* End_of_format */0
                                                            ])
                                                        ])
                                                    ])
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "the %s %s is defined in both types %s and %s."
                        ]), param[0], param[1], param[2], param[3]);
      case 15 : 
          return Curry._3(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "files ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " and ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " both define a module named ",
                                              /* String */Block.__(2, [
                                                  /* No_padding */0,
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "files %s and %s both define a module named %s"
                        ]), param[1], param[2], param[0]);
      case 16 : 
          return "unused value " + (param[0] + ".");
      case 17 : 
          return "unused open " + (param[0] + ".");
      case 18 : 
          return "unused type " + (param[0] + ".");
      case 19 : 
          return "unused for-loop index " + (param[0] + ".");
      case 20 : 
          return "unused ancestor variable " + (param[0] + ".");
      case 21 : 
          var s$2 = param[0];
          if (param[1] !== 0) {
            return "constructor " + (s$2 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (param[2] !== 0) {
            return "constructor " + (s$2 + " is never used to build values.\nIts type is exported as a private type.");
          } else {
            return "unused constructor " + (s$2 + ".");
          }
      case 22 : 
          var s$3 = param[0];
          if (param[1] !== 0) {
            return "extension constructor " + (s$3 + " is never used to build values.\n(However, this constructor appears in patterns.)");
          } else if (param[2] !== 0) {
            return "extension constructor " + (s$3 + " is never used to build values.\nIt is exported or rebound as a private extension.");
          } else {
            return "unused extension constructor " + (s$3 + ".");
          }
      case 23 : 
          var slist$2 = param[1];
          var ty = param[0];
          var exit = 0;
          if (slist$2 && !(slist$2[1] || param[2] !== 0)) {
            return slist$2[0] + (" was selected from type " + (ty + ".\nIt is not visible in the current scope, and will not \nbe selected if the type becomes unknown."));
          } else {
            exit = 1;
          }
          if (exit === 1) {
            if (param[2] !== 0) {
              return "this record of type " + (ty + (" contains fields that are \nnot visible in the current scope: " + ($$String.concat(" ", slist$2) + ".\nThey will not be selected if the type becomes unknown.")));
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "warnings.ml",
                      353,
                      39
                    ]
                  ];
            }
          }
          break;
      case 24 : 
          var slist$3 = param[0];
          var exit$1 = 0;
          if (slist$3 && !(slist$3[1] || param[2] !== 0)) {
            return slist$3[0] + (" belongs to several types: " + ($$String.concat(" ", param[1]) + "\nThe first one was selected. Please disambiguate if this is wrong."));
          } else {
            exit$1 = 1;
          }
          if (exit$1 === 1) {
            if (param[2] !== 0) {
              return "these field labels belong to several types: " + ($$String.concat(" ", param[1]) + "\nThe first one was selected. Please disambiguate if this is wrong.");
            } else {
              throw [
                    Caml_builtin_exceptions.assert_failure,
                    [
                      "warnings.ml",
                      362,
                      36
                    ]
                  ];
            }
          }
          break;
      case 25 : 
          return "this use of " + (param[0] + " required disambiguation.");
      case 26 : 
          return "the label " + (param[0] + " is not optional.");
      case 27 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "this open statement shadows the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " identifier ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " (which is later used)",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "this open statement shadows the %s identifier %s (which is later used)"
                        ]), param[0], param[1]);
      case 28 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "this open statement shadows the ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* String_literal */Block.__(11, [
                                              " (which is later used)",
                                              /* End_of_format */0
                                            ])
                                        ])
                                    ])
                                ])
                            ]),
                          "this open statement shadows the %s %s (which is later used)"
                        ]), param[0], param[1]);
      case 29 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "illegal environment variable ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      " : ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "illegal environment variable %s : %s"
                        ]), param[0], param[1]);
      case 30 : 
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "illegal payload for attribute '",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "'.\n",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "illegal payload for attribute '%s'.\n%s"
                        ]), param[0], param[1]);
      case 31 : 
          var sl = param[0];
          return Curry._2(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "implicit elimination of optional argument",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Char_literal */Block.__(12, [
                                      /* " " */32,
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "implicit elimination of optional argument%s %s"
                        ]), List.length(sl) === 1 ? "" : "s", $$String.concat(", ", sl));
      case 32 : 
          return "no cmi file was found in path for module " + param[0];
      case 33 : 
          if (param[0]) {
            return "unattached documentation comment (ignored)";
          } else {
            return "ambiguous documentation comment";
          }
      
    }
  }
}

var nerrors = [0];

function print(ppf, w) {
  var msg = message(w);
  var num = number(w);
  Curry._2(Format.fprintf(ppf, /* Format */[
            /* Int */Block.__(4, [
                /* Int_d */0,
                /* No_padding */0,
                /* No_precision */0,
                /* String_literal */Block.__(11, [
                    ": ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ])
                  ])
              ]),
            "%d: %s"
          ]), num, msg);
  Format.pp_print_flush(ppf, /* () */0);
  if (Caml_array.caml_array_get(current[0][/* error */1], num)) {
    nerrors[0] = nerrors[0] + 1 | 0;
    return /* () */0;
  } else {
    return 0;
  }
}

var Errors = Caml_exceptions.create("Warnings-Jeason.Errors");

function check_fatal() {
  if (nerrors[0] > 0) {
    var e_001 = nerrors[0];
    var e = [
      Errors,
      e_001
    ];
    nerrors[0] = 0;
    throw e;
  } else {
    return 0;
  }
}

function help_warnings() {
  List.iter((function (param) {
          return Curry._2(Printf.printf(/* Format */[
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* Lit_padding */Block.__(0, [
                                  /* Right */1,
                                  3
                                ]),
                              /* No_precision */0,
                              /* Char_literal */Block.__(12, [
                                  /* " " */32,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* Char_literal */Block.__(12, [
                                          /* "\n" */10,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ]),
                          "%3i %s\n"
                        ]), param[0], param[1]);
        }), /* :: */[
        /* tuple */[
          1,
          "Suspicious-looking start-of-comment mark."
        ],
        /* :: */[
          /* tuple */[
            2,
            "Suspicious-looking end-of-comment mark."
          ],
          /* :: */[
            /* tuple */[
              3,
              "Deprecated feature."
            ],
            /* :: */[
              /* tuple */[
                4,
                "Fragile pattern matching: matching that will remain complete even\n    if additional constructors are added to one of the variant types\n    matched."
              ],
              /* :: */[
                /* tuple */[
                  5,
                  "Partially applied function: expression whose result has function\n    type and is ignored."
                ],
                /* :: */[
                  /* tuple */[
                    6,
                    "Label omitted in function application."
                  ],
                  /* :: */[
                    /* tuple */[
                      7,
                      "Method overridden."
                    ],
                    /* :: */[
                      /* tuple */[
                        8,
                        "Partial match: missing cases in pattern-matching."
                      ],
                      /* :: */[
                        /* tuple */[
                          9,
                          "Missing fields in a record pattern."
                        ],
                        /* :: */[
                          /* tuple */[
                            10,
                            "Expression on the left-hand side of a sequence that doesn't have type\n    \"unit\" (and that is not a function, see warning number 5)."
                          ],
                          /* :: */[
                            /* tuple */[
                              11,
                              "Redundant case in a pattern matching (unused match case)."
                            ],
                            /* :: */[
                              /* tuple */[
                                12,
                                "Redundant sub-pattern in a pattern-matching."
                              ],
                              /* :: */[
                                /* tuple */[
                                  13,
                                  "Instance variable overridden."
                                ],
                                /* :: */[
                                  /* tuple */[
                                    14,
                                    "Illegal backslash escape in a string constant."
                                  ],
                                  /* :: */[
                                    /* tuple */[
                                      15,
                                      "Private method made public implicitly."
                                    ],
                                    /* :: */[
                                      /* tuple */[
                                        16,
                                        "Unerasable optional argument."
                                      ],
                                      /* :: */[
                                        /* tuple */[
                                          17,
                                          "Undeclared virtual method."
                                        ],
                                        /* :: */[
                                          /* tuple */[
                                            18,
                                            "Non-principal type."
                                          ],
                                          /* :: */[
                                            /* tuple */[
                                              19,
                                              "Type without principality."
                                            ],
                                            /* :: */[
                                              /* tuple */[
                                                20,
                                                "Unused function argument."
                                              ],
                                              /* :: */[
                                                /* tuple */[
                                                  21,
                                                  "Non-returning statement."
                                                ],
                                                /* :: */[
                                                  /* tuple */[
                                                    22,
                                                    "Proprocessor warning."
                                                  ],
                                                  /* :: */[
                                                    /* tuple */[
                                                      23,
                                                      "Useless record \"with\" clause."
                                                    ],
                                                    /* :: */[
                                                      /* tuple */[
                                                        24,
                                                        "Bad module name: the source file name is not a valid OCaml module name."
                                                      ],
                                                      /* :: */[
                                                        /* tuple */[
                                                          25,
                                                          "Pattern-matching with all clauses guarded.  Exhaustiveness cannot be\n    checked."
                                                        ],
                                                        /* :: */[
                                                          /* tuple */[
                                                            26,
                                                            "Suspicious unused variable: unused variable that is bound\n    with \"let\" or \"as\", and doesn't start with an underscore (\"_\")\n    character."
                                                          ],
                                                          /* :: */[
                                                            /* tuple */[
                                                              27,
                                                              "Innocuous unused variable: unused variable that is not bound with\n    \"let\" nor \"as\", and doesn't start with an underscore (\"_\")\n    character."
                                                            ],
                                                            /* :: */[
                                                              /* tuple */[
                                                                28,
                                                                "Wildcard pattern given as argument to a constant constructor."
                                                              ],
                                                              /* :: */[
                                                                /* tuple */[
                                                                  29,
                                                                  "Unescaped end-of-line in a string constant (non-portable code)."
                                                                ],
                                                                /* :: */[
                                                                  /* tuple */[
                                                                    30,
                                                                    "Two labels or constructors of the same name are defined in two\n    mutually recursive types."
                                                                  ],
                                                                  /* :: */[
                                                                    /* tuple */[
                                                                      31,
                                                                      "A module is linked twice in the same executable."
                                                                    ],
                                                                    /* :: */[
                                                                      /* tuple */[
                                                                        32,
                                                                        "Unused value declaration."
                                                                      ],
                                                                      /* :: */[
                                                                        /* tuple */[
                                                                          33,
                                                                          "Unused open statement."
                                                                        ],
                                                                        /* :: */[
                                                                          /* tuple */[
                                                                            34,
                                                                            "Unused type declaration."
                                                                          ],
                                                                          /* :: */[
                                                                            /* tuple */[
                                                                              35,
                                                                              "Unused for-loop index."
                                                                            ],
                                                                            /* :: */[
                                                                              /* tuple */[
                                                                                36,
                                                                                "Unused ancestor variable."
                                                                              ],
                                                                              /* :: */[
                                                                                /* tuple */[
                                                                                  37,
                                                                                  "Unused constructor."
                                                                                ],
                                                                                /* :: */[
                                                                                  /* tuple */[
                                                                                    38,
                                                                                    "Unused extension constructor."
                                                                                  ],
                                                                                  /* :: */[
                                                                                    /* tuple */[
                                                                                      39,
                                                                                      "Unused rec flag."
                                                                                    ],
                                                                                    /* :: */[
                                                                                      /* tuple */[
                                                                                        40,
                                                                                        "Constructor or label name used out of scope."
                                                                                      ],
                                                                                      /* :: */[
                                                                                        /* tuple */[
                                                                                          41,
                                                                                          "Ambiguous constructor or label name."
                                                                                        ],
                                                                                        /* :: */[
                                                                                          /* tuple */[
                                                                                            42,
                                                                                            "Disambiguated constructor or label name."
                                                                                          ],
                                                                                          /* :: */[
                                                                                            /* tuple */[
                                                                                              43,
                                                                                              "Nonoptional label applied as optional."
                                                                                            ],
                                                                                            /* :: */[
                                                                                              /* tuple */[
                                                                                                44,
                                                                                                "Open statement shadows an already defined identifier."
                                                                                              ],
                                                                                              /* :: */[
                                                                                                /* tuple */[
                                                                                                  45,
                                                                                                  "Open statement shadows an already defined label or constructor."
                                                                                                ],
                                                                                                /* :: */[
                                                                                                  /* tuple */[
                                                                                                    46,
                                                                                                    "Error in environment variable."
                                                                                                  ],
                                                                                                  /* :: */[
                                                                                                    /* tuple */[
                                                                                                      47,
                                                                                                      "Illegal attribute payload."
                                                                                                    ],
                                                                                                    /* :: */[
                                                                                                      /* tuple */[
                                                                                                        48,
                                                                                                        "Implicit elimination of optional arguments."
                                                                                                      ],
                                                                                                      /* :: */[
                                                                                                        /* tuple */[
                                                                                                          49,
                                                                                                          "Missing cmi file when looking up module alias."
                                                                                                        ],
                                                                                                        /* :: */[
                                                                                                          /* tuple */[
                                                                                                            50,
                                                                                                            "Unexpected documentation comment."
                                                                                                          ],
                                                                                                          /* [] */0
                                                                                                        ]
                                                                                                      ]
                                                                                                    ]
                                                                                                  ]
                                                                                                ]
                                                                                              ]
                                                                                            ]
                                                                                          ]
                                                                                        ]
                                                                                      ]
                                                                                    ]
                                                                                  ]
                                                                                ]
                                                                              ]
                                                                            ]
                                                                          ]
                                                                        ]
                                                                      ]
                                                                    ]
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]
                                                        ]
                                                      ]
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ]
      ]);
  console.log("  A all warnings");
  for(var i = /* "b" */98; i <= /* "z" */122; ++i){
    var c = Char.chr(i);
    var l = letter(c);
    if (l) {
      if (l[1]) {
        Curry._2(Printf.printf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "  ",
                      /* Char */Block.__(0, [/* String_literal */Block.__(11, [
                              " warnings ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      ".\n",
                                      /* End_of_format */0
                                    ])
                                ])
                            ])])
                    ]),
                  "  %c warnings %s.\n"
                ]), Char.uppercase(c), $$String.concat(", ", List.map((function (prim) {
                        return String(prim);
                      }), l)));
      } else {
        Curry._2(Printf.printf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "  ",
                      /* Char */Block.__(0, [/* String_literal */Block.__(11, [
                              " warning ",
                              /* Int */Block.__(4, [
                                  /* Int_i */3,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* Char_literal */Block.__(12, [
                                      /* "\n" */10,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])])
                    ]),
                  "  %c warning %i\n"
                ]), Char.uppercase(c), l[0]);
      }
    }
    
  }
  return Pervasives.exit(0);
}

exports.parse_options = parse_options;
exports.is_active = is_active;
exports.is_error = is_error;
exports.defaults_w = defaults_w;
exports.defaults_warn_error = defaults_warn_error;
exports.print = print;
exports.Errors = Errors;
exports.check_fatal = check_fatal;
exports.help_warnings = help_warnings;
exports.backup = backup;
exports.restore = restore;
/*  Not a pure module */
