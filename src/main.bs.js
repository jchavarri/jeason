// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Buffer = require("bs-platform/lib/js/buffer.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Ast_helper$Jeason = require("./ast_helper.bs.js");
var Parser_flow$Jeason = require("./parser_flow.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function correctIdentifier(ident) {
  var stripLeadingUnderscores = function (_s) {
    while(true) {
      var s = _s;
      if (s.length === 0 || Caml_string.get(s, 0) !== /* "_" */95) {
        return s;
      } else {
        _s = $$String.sub(s, 1, s.length - 1 | 0);
        continue ;
        
      }
    };
  };
  if (ident === "") {
    return ident;
  } else {
    var correctedName = stripLeadingUnderscores(ident);
    var match = $$String.contains(correctedName, /* "_" */95);
    var correctedName$1 = match !== 0 ? correctedName + "_" : correctedName;
    var correctedName$2 = $$String.uncapitalize(correctedName$1);
    switch (correctedName$2) {
      case "object" : 
          return "object_";
      case "type" : 
          return "type_";
      default:
        return correctedName$2;
    }
  }
}

function objectContainsKeyName(key, properties) {
  return List.exists((function (property) {
                if (property.tag) {
                  return /* false */0;
                } else {
                  var match = property[0][1][/* key */0];
                  switch (match.tag | 0) {
                    case 1 : 
                        if (match[0][1] === key) {
                          return /* true */1;
                        } else {
                          return /* false */0;
                        }
                    case 0 : 
                    case 2 : 
                        return /* false */0;
                    
                  }
                }
              }), properties);
}

function astHelperStrLidStr($staropt$star, a) {
  var correct = $staropt$star ? $staropt$star[0] : /* true */1;
  return /* record */[
          /* txt */correct !== 0 ? correctIdentifier(a) : a,
          /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
        ];
}

function astHelperStrLidIdent($staropt$star, a) {
  var correct = $staropt$star ? $staropt$star[0] : /* true */1;
  if (a) {
    var inner = /* Lident */Block.__(0, [correct !== 0 ? correctIdentifier(List.hd(a)) : List.hd(a)]);
    var res = List.fold_left((function (acc, curr) {
            return /* Ldot */Block.__(1, [
                      acc,
                      correct !== 0 ? correctIdentifier(curr) : curr
                    ]);
          }), inner, List.tl(a));
    return /* record */[
            /* txt */res,
            /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
          ];
  } else {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "identifier is empty."
        ];
  }
}

var expUnit = Ast_helper$Jeason.Exp[/* construct */11](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
          "()",
          /* [] */0
        ]), /* None */0);

function placeholder(s) {
  return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                  s,
                  /* [] */0
                ]));
}

var expMarker = placeholder("marker");

function parseTreeValueBinding(pat, expr) {
  return /* record */[
          /* pvb_pat */pat,
          /* pvb_expr */expr,
          /* pvb_attributes : [] */0,
          /* pvb_loc */Ast_helper$Jeason.default_loc[/* contents */0]
        ];
}

function keepSome(lst) {
  return List.map((function (a) {
                if (a) {
                  return a[0];
                } else {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "main.re",
                          100,
                          19
                        ]
                      ];
                }
              }), List.filter((function (a) {
                      if (a) {
                        return /* true */1;
                      } else {
                        return /* false */0;
                      }
                    }))(lst));
}

function listToListAst(lst) {
  var nullList = Ast_helper$Jeason.Exp[/* construct */11](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
            "[]",
            /* [] */0
          ]), /* None */0);
  if (lst) {
    return List.fold_left((function (accumExp, expr) {
                  return Ast_helper$Jeason.Exp[/* construct */11](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  "::",
                                  /* [] */0
                                ]), /* Some */[Ast_helper$Jeason.Exp[/* tuple */10](/* None */0, /* None */0, /* :: */[
                                    expr,
                                    /* :: */[
                                      accumExp,
                                      /* [] */0
                                    ]
                                  ])]);
                }), nullList, List.rev(lst));
  } else {
    return nullList;
  }
}

function convertPropTypeType(_isTopLevel, isForFunctionLabel, _wrappedByRequired, _param) {
  while(true) {
    var param = _param;
    var wrappedByRequired = _wrappedByRequired;
    var isTopLevel = _isTopLevel;
    var pexp_desc = param[/* pexp_desc */0];
    var wrapIfNotRequired = (function(isTopLevel,wrappedByRequired){
    return function wrapIfNotRequired($staropt$star, ident) {
      var attrs = $staropt$star ? $staropt$star[0] : /* [] */0;
      var partialResult_001 = /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0];
      var partialResult = /* record */[
        /* ptyp_desc */ident,
        partialResult_001,
        /* ptyp_attributes */attrs
      ];
      if (wrappedByRequired) {
        return partialResult;
      } else if (isTopLevel && isForFunctionLabel) {
        return /* record */[
                /* ptyp_desc : Ptyp_constr */Block.__(3, [
                    astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                          "*predef*",
                          /* :: */[
                            "option",
                            /* [] */0
                          ]
                        ]),
                    /* :: */[
                      /* record */[
                        /* ptyp_desc : Ptyp_constr */Block.__(3, [
                            /* record */[
                              /* txt : Ldot */Block.__(1, [
                                  /* Lident */Block.__(0, ["Js"]),
                                  "null_undefined"
                                ]),
                              /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
                            ],
                            /* :: */[
                              partialResult,
                              /* [] */0
                            ]
                          ]),
                        /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                        /* ptyp_attributes : [] */0
                      ],
                      /* [] */0
                    ]
                  ]),
                /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                /* ptyp_attributes : [] */0
              ];
      } else {
        return /* record */[
                /* ptyp_desc : Ptyp_constr */Block.__(3, [
                    /* record */[
                      /* txt : Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["Js"]),
                          "null_undefined"
                        ]),
                      /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
                    ],
                    /* :: */[
                      partialResult,
                      /* [] */0
                    ]
                  ]),
                /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                /* ptyp_attributes : [] */0
              ];
      }
    }
    }(isTopLevel,wrappedByRequired));
    var unsupported = function (str) {
      return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                    astHelperStrLidIdent(/* None */0, /* :: */[
                          str,
                          /* [] */0
                        ]),
                    /* [] */0
                  ]));
    };
    switch (pexp_desc.tag | 0) {
      case 0 : 
          var match = pexp_desc[0][/* txt */0];
          switch (match.tag | 0) {
            case 1 : 
                var match$1 = match[0];
                switch (match$1.tag | 0) {
                  case 1 : 
                      var match$2 = match$1[0];
                      switch (match$2.tag | 0) {
                        case 0 : 
                            if (match$2[0] === "ReactRe" && match$1[1] === "PropTypes") {
                              switch (match[1]) {
                                case "any" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                        "Obj",
                                                        /* :: */[
                                                          "t",
                                                          /* [] */0
                                                        ]
                                                      ]),
                                                  /* [] */0
                                                ]));
                                case "bool" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                        "Js",
                                                        /* :: */[
                                                          "boolean",
                                                          /* [] */0
                                                        ]
                                                      ]),
                                                  /* [] */0
                                                ]));
                                case "element" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                        "ReactRe",
                                                        /* :: */[
                                                          "reactElement",
                                                          /* [] */0
                                                        ]
                                                      ]),
                                                  /* [] */0
                                                ]));
                                case "func" : 
                                    return wrapIfNotRequired(/* Some */[/* :: */[
                                                  /* tuple */[
                                                    astHelperStrLidStr(/* None */0, "bs.meth"),
                                                    /* PStr */Block.__(0, [/* [] */0])
                                                  ],
                                                  /* [] */0
                                                ]], /* Ptyp_arrow */Block.__(1, [
                                                  "",
                                                  /* record */[
                                                    /* ptyp_desc : Ptyp_constr */Block.__(3, [
                                                        astHelperStrLidIdent(/* None */0, /* :: */[
                                                              "unit",
                                                              /* [] */0
                                                            ]),
                                                        /* [] */0
                                                      ]),
                                                    /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                                    /* ptyp_attributes : [] */0
                                                  ],
                                                  /* record */[
                                                    /* ptyp_desc : Ptyp_constr */Block.__(3, [
                                                        astHelperStrLidIdent(/* None */0, /* :: */[
                                                              "unit",
                                                              /* [] */0
                                                            ]),
                                                        /* [] */0
                                                      ]),
                                                    /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                                    /* ptyp_attributes : [] */0
                                                  ]
                                                ]));
                                case "node" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* None */0, /* :: */[
                                                        "nodeTypeNotSupported",
                                                        /* [] */0
                                                      ]),
                                                  /* [] */0
                                                ]));
                                case "number" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* None */0, /* :: */[
                                                        "int",
                                                        /* [] */0
                                                      ]),
                                                  /* [] */0
                                                ]));
                                case "object_" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                        "Js",
                                                        /* :: */[
                                                          "t",
                                                          /* [] */0
                                                        ]
                                                      ]),
                                                  /* :: */[
                                                    /* record */[
                                                      /* ptyp_desc : Ptyp_constr */Block.__(3, [
                                                          astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                                "Obj",
                                                                /* :: */[
                                                                  "t",
                                                                  /* [] */0
                                                                ]
                                                              ]),
                                                          /* [] */0
                                                        ]),
                                                      /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                                      /* ptyp_attributes : [] */0
                                                    ],
                                                    /* [] */0
                                                  ]
                                                ]));
                                case "string" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* None */0, /* :: */[
                                                        "string",
                                                        /* [] */0
                                                      ]),
                                                  /* [] */0
                                                ]));
                                case "symbol" : 
                                    return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                  astHelperStrLidIdent(/* None */0, /* :: */[
                                                        "symbolTypeNotSupportedHere",
                                                        /* [] */0
                                                      ]),
                                                  /* [] */0
                                                ]));
                                default:
                                  return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                astHelperStrLidIdent(/* None */0, /* :: */[
                                                      "cannotUnderstandPropTypeHere",
                                                      /* [] */0
                                                    ]),
                                                /* [] */0
                                              ]));
                              }
                            } else {
                              return unsupported("unrecognizedPropType");
                            }
                        case 1 : 
                        case 2 : 
                            return unsupported("unrecognizedPropType");
                        
                      }
                  case 0 : 
                  case 2 : 
                      return unsupported("unrecognizedPropType");
                  
                }
            case 0 : 
            case 2 : 
                return unsupported("unrecognizedPropType");
            
          }
      case 5 : 
          var match$3 = pexp_desc[0][/* pexp_desc */0];
          if (match$3.tag) {
            return unsupported("unrecognizedPropType");
          } else {
            var match$4 = match$3[0][/* txt */0];
            switch (match$4.tag | 0) {
              case 1 : 
                  var match$5 = match$4[0];
                  switch (match$5.tag | 0) {
                    case 1 : 
                        var match$6 = match$5[0];
                        switch (match$6.tag | 0) {
                          case 0 : 
                              if (match$6[0] === "ReactRe" && match$5[1] === "PropTypes") {
                                var match$7 = pexp_desc[1];
                                if (match$7 && !match$7[1]) {
                                  var expr = match$7[0][1];
                                  switch (match$4[1]) {
                                    case "arrayOf" : 
                                        return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                      astHelperStrLidIdent(/* None */0, /* :: */[
                                                            "array",
                                                            /* [] */0
                                                          ]),
                                                      /* :: */[
                                                        convertPropTypeType(/* false */0, isForFunctionLabel, /* false */0, expr),
                                                        /* [] */0
                                                      ]
                                                    ]));
                                    case "instanceOf" : 
                                        return unsupported("instanceOfUnSupported");
                                    case "isRequired" : 
                                        _param = expr;
                                        _wrappedByRequired = /* true */1;
                                        _isTopLevel = /* false */0;
                                        continue ;
                                        case "objectOf" : 
                                        return unsupported("objectOfUnSupported");
                                    case "oneOf" : 
                                        return unsupported("oneOfUnSupported");
                                    case "oneOfType" : 
                                        return unsupported("oneOfTypeUnSupported");
                                    case "shape" : 
                                        var match$8 = expr[/* pexp_desc */0];
                                        var convertedFields;
                                        if (match$8.tag === 33) {
                                          var match$9 = match$8[0][1];
                                          switch (match$9.tag | 0) {
                                            case 0 : 
                                                var match$10 = match$9[0];
                                                if (match$10) {
                                                  var match$11 = match$10[0][/* pstr_desc */0];
                                                  if (match$11.tag) {
                                                    convertedFields = /* [] */0;
                                                  } else {
                                                    var match$12 = match$11[0][/* pexp_desc */0];
                                                    convertedFields = match$12.tag === 11 && !match$10[1] ? List.map((function (param) {
                                                              var txt = param[0][/* txt */0];
                                                              var exit = 0;
                                                              switch (txt.tag | 0) {
                                                                case 0 : 
                                                                    return /* tuple */[
                                                                            txt[0],
                                                                            /* [] */0,
                                                                            convertPropTypeType(/* false */0, isForFunctionLabel, /* false */0, param[1])
                                                                          ];
                                                                case 1 : 
                                                                case 2 : 
                                                                    exit = 1;
                                                                    break;
                                                                
                                                              }
                                                              if (exit === 1) {
                                                                return /* tuple */[
                                                                        "cannotGenerateType",
                                                                        /* [] */0,
                                                                        /* record */[
                                                                          /* ptyp_desc : Ptyp_constr */Block.__(3, [
                                                                              astHelperStrLidIdent(/* None */0, /* :: */[
                                                                                    "forComplexPropTypesObjectKey",
                                                                                    /* [] */0
                                                                                  ]),
                                                                              /* [] */0
                                                                            ]),
                                                                          /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                                                          /* ptyp_attributes : [] */0
                                                                        ]
                                                                      ];
                                                              }
                                                              
                                                            }), match$12[0]) : /* [] */0;
                                                  }
                                                } else {
                                                  convertedFields = /* [] */0;
                                                }
                                                break;
                                            case 1 : 
                                            case 2 : 
                                                convertedFields = /* [] */0;
                                                break;
                                            
                                          }
                                        } else {
                                          convertedFields = /* [] */0;
                                        }
                                        return wrapIfNotRequired(/* None */0, /* Ptyp_constr */Block.__(3, [
                                                      astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                            "Js",
                                                            /* :: */[
                                                              "t",
                                                              /* [] */0
                                                            ]
                                                          ]),
                                                      /* :: */[
                                                        /* record */[
                                                          /* ptyp_desc : Ptyp_object */Block.__(4, [
                                                              convertedFields,
                                                              /* Closed */0
                                                            ]),
                                                          /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                                          /* ptyp_attributes : [] */0
                                                        ],
                                                        /* [] */0
                                                      ]
                                                    ]));
                                    default:
                                      return unsupported("unrecognizedPropType");
                                  }
                                } else {
                                  return unsupported("unrecognizedPropType");
                                }
                              } else {
                                return unsupported("unrecognizedPropType");
                              }
                          case 1 : 
                          case 2 : 
                              return unsupported("unrecognizedPropType");
                          
                        }
                    case 0 : 
                    case 2 : 
                        return unsupported("unrecognizedPropType");
                    
                  }
              case 0 : 
              case 2 : 
                  return unsupported("unrecognizedPropType");
              
            }
          }
      default:
        return unsupported("unrecognizedPropType");
    }
  };
}

function propTypesToActualTypes(fields) {
  var convertedFieldsForProps = List.map((function (param) {
          var txt = param[0][/* txt */0];
          var exit = 0;
          switch (txt.tag | 0) {
            case 0 : 
                return /* tuple */[
                        txt[0],
                        /* [] */0,
                        convertPropTypeType(/* true */1, /* false */0, /* false */0, param[1])
                      ];
            case 1 : 
            case 2 : 
                exit = 1;
                break;
            
          }
          if (exit === 1) {
            return /* tuple */[
                    "cannotGenerateType",
                    /* [] */0,
                    /* record */[
                      /* ptyp_desc : Ptyp_constr */Block.__(3, [
                          /* record */[
                            /* txt : Lident */Block.__(0, ["forComplexPropTypesObjectKey"]),
                            /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
                          ],
                          /* [] */0
                        ]),
                      /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                      /* ptyp_attributes : [] */0
                    ]
                  ];
          }
          
        }), fields);
  var propsObjType = Ast_helper$Jeason.Str[/* type_ */4](/* None */0, /* :: */[
        Ast_helper$Jeason.Type[/* mk */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* Ptype_abstract */0], /* Some */[/* Public */1], /* Some */[/* record */[
                /* ptyp_desc : Ptyp_constr */Block.__(3, [
                    /* record */[
                      /* txt : Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["Js"]),
                          "t"
                        ]),
                      /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
                    ],
                    /* :: */[
                      /* record */[
                        /* ptyp_desc : Ptyp_object */Block.__(4, [
                            convertedFieldsForProps,
                            /* Closed */0
                          ]),
                        /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                        /* ptyp_attributes : [] */0
                      ],
                      /* [] */0
                    ]
                  ]),
                /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                /* ptyp_attributes : [] */0
              ]], astHelperStrLidStr(/* None */0, "props")),
        /* [] */0
      ]);
  var inner_000 = /* ptyp_desc : Ptyp_arrow */Block.__(1, [
      "",
      /* record */[
        /* ptyp_desc : Ptyp_constr */Block.__(3, [
            astHelperStrLidIdent(/* None */0, /* :: */[
                  "unit",
                  /* [] */0
                ]),
            /* [] */0
          ]),
        /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
        /* ptyp_attributes : [] */0
      ],
      /* record */[
        /* ptyp_desc : Ptyp_var */Block.__(0, ["reactJsProps"]),
        /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
        /* ptyp_attributes : [] */0
      ]
    ]);
  var inner_001 = /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0];
  var inner = /* record */[
    inner_000,
    inner_001,
    /* ptyp_attributes : [] */0
  ];
  var externalTypeInner = List.fold_left((function (acc, param) {
          var expr = param[1];
          var pexp_desc = expr[/* pexp_desc */0];
          var txt = param[0][/* txt */0];
          var topLevelIsRequired;
          if (pexp_desc.tag === 5) {
            var match = pexp_desc[0][/* pexp_desc */0];
            if (match.tag) {
              topLevelIsRequired = /* false */0;
            } else {
              var match$1 = match[0][/* txt */0];
              switch (match$1.tag | 0) {
                case 1 : 
                    var match$2 = match$1[0];
                    switch (match$2.tag | 0) {
                      case 1 : 
                          var match$3 = match$2[0];
                          switch (match$3.tag | 0) {
                            case 0 : 
                                if (match$3[0] === "ReactRe" && match$2[1] === "PropTypes" && match$1[1] === "isRequired") {
                                  var match$4 = pexp_desc[1];
                                  topLevelIsRequired = match$4 && !match$4[1] ? /* true */1 : /* false */0;
                                } else {
                                  topLevelIsRequired = /* false */0;
                                }
                                break;
                            case 1 : 
                            case 2 : 
                                topLevelIsRequired = /* false */0;
                                break;
                            
                          }
                          break;
                      case 0 : 
                      case 2 : 
                          topLevelIsRequired = /* false */0;
                          break;
                      
                    }
                    break;
                case 0 : 
                case 2 : 
                    topLevelIsRequired = /* false */0;
                    break;
                
              }
            }
          } else {
            topLevelIsRequired = /* false */0;
          }
          var label;
          switch (txt.tag | 0) {
            case 0 : 
                var propName = txt[0];
                label = topLevelIsRequired !== 0 ? propName : "?" + propName;
                break;
            case 1 : 
            case 2 : 
                label = "complexPropTypesObjectKey";
                break;
            
          }
          return /* record */[
                  /* ptyp_desc : Ptyp_arrow */Block.__(1, [
                      label,
                      convertPropTypeType(/* true */1, /* true */1, /* false */0, expr),
                      acc
                    ]),
                  /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                  /* ptyp_attributes : [] */0
                ];
        }), inner, List.rev(fields));
  var externalType = Ast_helper$Jeason.Str[/* primitive */3](/* None */0, /* record */[
        /* pval_name : record */[
          /* txt */"props",
          /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
        ],
        /* pval_type */externalTypeInner,
        /* pval_prim : :: */[
          "",
          /* [] */0
        ],
        /* pval_attributes : :: */[
          /* tuple */[
            /* record */[
              /* txt */"bs.obj",
              /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
            ],
            /* PStr */Block.__(0, [/* [] */0])
          ],
          /* [] */0
        ],
        /* pval_loc */Ast_helper$Jeason.default_loc[/* contents */0]
      ]);
  return /* tuple */[
          propsObjType,
          externalType
        ];
}

function attemptToGenerateStateRecord(initialStateDeclaration) {
  var innerMostExpr = function (_pexp_desc) {
    while(true) {
      var pexp_desc = _pexp_desc;
      switch (pexp_desc.tag | 0) {
        case 2 : 
            _pexp_desc = pexp_desc[2][/* pexp_desc */0];
            continue ;
            case 16 : 
            _pexp_desc = pexp_desc[1][/* pexp_desc */0];
            continue ;
            case 19 : 
            _pexp_desc = pexp_desc[0][/* pexp_desc */0];
            continue ;
            case 33 : 
            var match = pexp_desc[0];
            if (match[0][/* txt */0] === "bs.obj") {
              var match$1 = match[1];
              switch (match$1.tag | 0) {
                case 0 : 
                    var match$2 = match$1[0];
                    if (match$2) {
                      var match$3 = match$2[0][/* pstr_desc */0];
                      if (match$3.tag) {
                        return /* None */0;
                      } else {
                        var match$4 = match$3[0][/* pexp_desc */0];
                        if (match$4.tag === 11 && !match$2[1]) {
                          return /* Some */[match$4[0]];
                        } else {
                          return /* None */0;
                        }
                      }
                    } else {
                      return /* None */0;
                    }
                case 1 : 
                case 2 : 
                    return /* None */0;
                
              }
            } else {
              return /* None */0;
            }
        default:
          return /* None */0;
      }
    };
  };
  var bailType = Ast_helper$Jeason.Str[/* type_ */4](/* None */0, /* :: */[
        Ast_helper$Jeason.Type[/* mk */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* Ptype_abstract */0], /* Some */[/* Public */1], /* Some */[/* record */[
                /* ptyp_desc : Ptyp_constr */Block.__(3, [
                    /* record */[
                      /* txt : Ldot */Block.__(1, [
                          /* Lident */Block.__(0, ["Js"]),
                          "t"
                        ]),
                      /* loc */Ast_helper$Jeason.default_loc[/* contents */0]
                    ],
                    /* :: */[
                      /* record */[
                        /* ptyp_desc : Ptyp_object */Block.__(4, [
                            /* :: */[
                              /* tuple */[
                                "cantAnalyzeComplexStateType",
                                /* [] */0,
                                /* record */[
                                  /* ptyp_desc : Ptyp_constr */Block.__(3, [
                                      astHelperStrLidIdent(/* None */0, /* :: */[
                                            "pleaseProvideTheShapeOfStateManually",
                                            /* [] */0
                                          ]),
                                      /* [] */0
                                    ]),
                                  /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                  /* ptyp_attributes : [] */0
                                ]
                              ],
                              /* [] */0
                            ],
                            /* Closed */0
                          ]),
                        /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                        /* ptyp_attributes : [] */0
                      ],
                      /* [] */0
                    ]
                  ]),
                /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                /* ptyp_attributes : [] */0
              ]], astHelperStrLidStr(/* None */0, "state")),
        /* [] */0
      ]);
  var match = initialStateDeclaration[/* pcf_desc */0];
  if (match.tag === 2) {
    var match$1 = match[0][2];
    if (match$1.tag) {
      var match$2 = match$1[1][/* pexp_desc */0];
      if (match$2.tag === 28) {
        var match$3 = match$2[0][/* pexp_desc */0];
        if (match$3.tag === 4) {
          var match$4 = match$3[3][/* pexp_desc */0];
          if (match$4.tag === 19 && !match$2[1]) {
            var match$5 = innerMostExpr(match$4[0][/* pexp_desc */0]);
            if (match$5) {
              var fields = List.map((function (param) {
                      var txt = param[0][/* txt */0];
                      var label;
                      switch (txt.tag | 0) {
                        case 0 : 
                            label = txt[0];
                            break;
                        case 1 : 
                        case 2 : 
                            label = "cannotConvertStateKeyOver";
                            break;
                        
                      }
                      return Ast_helper$Jeason.Type[/* field */2](/* None */0, /* None */0, /* None */0, /* None */0, astHelperStrLidStr(/* None */0, label), /* record */[
                                  /* ptyp_desc : Ptyp_constr */Block.__(3, [
                                      astHelperStrLidIdent(/* None */0, /* :: */[
                                            "pleaseFillTheTypeForThisKeyManually",
                                            /* [] */0
                                          ]),
                                      /* [] */0
                                    ]),
                                  /* ptyp_loc */Ast_helper$Jeason.default_loc[/* contents */0],
                                  /* ptyp_attributes : [] */0
                                ]);
                    }), match$5[0]);
              return Ast_helper$Jeason.Str[/* type_ */4](/* None */0, /* :: */[
                          Ast_helper$Jeason.Type[/* mk */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[/* Ptype_record */Block.__(1, [fields])], /* None */0, /* None */0, astHelperStrLidStr(/* None */0, "state")),
                          /* [] */0
                        ]);
            } else {
              return bailType;
            }
          } else {
            return bailType;
          }
        } else {
          return bailType;
        }
      } else {
        return bailType;
      }
    } else {
      return bailType;
    }
  } else {
    return bailType;
  }
}

function statementBlockMapper(context, param) {
  var body = param[/* body */0];
  if (body) {
    var bodyNotEmptyFlipped = List.rev(body);
    var lastItemReason = statementMapper(/* record */[
          /* terminalExpr : None */0,
          /* insideReactClass */context[/* insideReactClass */1],
          /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2]
        ], List.hd(bodyNotEmptyFlipped));
    return List.fold_left((function (accumExp, statement) {
                  return statementMapper(/* record */[
                              /* terminalExpr : Some */[accumExp],
                              /* insideReactClass */context[/* insideReactClass */1],
                              /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2]
                            ], statement);
                }), lastItemReason, List.tl(bodyNotEmptyFlipped));
  } else {
    return expUnit;
  }
}

function functionMapper(context, returnType, param) {
  var body = param[/* body */2];
  var params = param[/* params */1][0];
  var bodyReason;
  bodyReason = body.tag ? expressionMapper(context, body[0]) : statementBlockMapper(context, body[0][1]);
  var wrapBodyInReturnType = function (body) {
    if (returnType) {
      return Ast_helper$Jeason.Exp[/* constraint_ */22](/* None */0, /* None */0, body, Ast_helper$Jeason.Typ[/* constr */6](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                          returnType[0],
                          /* [] */0
                        ]), /* [] */0));
    } else {
      return body;
    }
  };
  if (params) {
    var first = params[0][1];
    var partialResult = List.fold_left((function (expr$prime, param) {
            var param$1 = param[1];
            if (param$1.tag === 3) {
              return Ast_helper$Jeason.Exp[/* fun_ */5](/* None */0, /* None */0, "", /* None */0, Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                  param$1[0][/* name */0][1],
                                  /* [] */0
                                ]), /* None */0), expr$prime);
            } else {
              return Ast_helper$Jeason.Exp[/* fun_ */5](/* None */0, /* None */0, "", /* None */0, Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "fixme")), expr$prime);
            }
          }), bodyReason, List.rev(params[1]));
    if (first.tag === 3) {
      return Ast_helper$Jeason.Exp[/* fun_ */5](/* None */0, /* None */0, "", /* None */0, Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                          first[0][/* name */0][1],
                          /* [] */0
                        ]), /* None */0), wrapBodyInReturnType(partialResult));
    } else {
      return Ast_helper$Jeason.Exp[/* fun_ */5](/* None */0, /* None */0, "", /* None */0, Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "fixme")), wrapBodyInReturnType(partialResult));
    }
  } else {
    return Ast_helper$Jeason.Exp[/* fun_ */5](/* None */0, /* None */0, "", /* None */0, Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                        "()",
                        /* [] */0
                      ]), /* None */0), wrapBodyInReturnType(bodyReason));
  }
}

function literalMapper($staropt$star, param) {
  var value = param[/* value */0];
  var isNegativeNumber = $staropt$star ? $staropt$star[0] : /* false */0;
  if (typeof value === "number") {
    return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                    "Js",
                    /* :: */[
                      "null",
                      /* [] */0
                    ]
                  ]));
  } else {
    switch (value.tag | 0) {
      case 0 : 
          return Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                        value[0],
                        /* None */0
                      ]));
      case 1 : 
          return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                          "Js",
                          /* :: */[
                            value[0] !== 0 ? "true_" : "false_",
                            /* [] */0
                          ]
                        ]));
      case 2 : 
          var n = value[0];
          var intN = n | 0;
          if (intN === n) {
            return Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_int */Block.__(0, [isNegativeNumber !== 0 ? -intN | 0 : intN]));
          } else {
            return Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_float */Block.__(3, [Pervasives.string_of_float(isNegativeNumber !== 0 ? -n : n)]));
          }
      case 3 : 
          return placeholder("regexPlaceholder");
      
    }
  }
}

function jsxElementMapper(context, param) {
  var match = param[/* openingElement */0][1];
  var attributes = match[/* attributes */2];
  var name = match[/* name */0];
  switch (name.tag | 0) {
    case 0 : 
        var name$1 = name[0][1][/* name */0];
        var jsxPropHasHyphen = List.exists((function (attr) {
                if (attr.tag) {
                  return /* false */0;
                } else {
                  var match = attr[0][1][/* name */0];
                  if (match.tag) {
                    return /* false */0;
                  } else {
                    return $$String.contains(match[0][1][/* name */0], /* "-" */45);
                  }
                }
              }), attributes);
        var childrenReact = keepSome(List.map((function (child) {
                    return jsxChildMapper(context, child);
                  }), param[/* children */2]));
        var constructRecordOrLabels = function (f) {
          return List.map((function (attr) {
                        if (attr.tag) {
                          return /* tuple */[
                                  Curry._1(f, "spreadAttrbute"),
                                  placeholder("notImplementedYet")
                                ];
                        } else {
                          var match = attr[0][1];
                          var value = match[/* value */1];
                          var name = match[/* name */0];
                          var valueReason;
                          if (value) {
                            var match$1 = value[0];
                            if (match$1.tag) {
                              var expression = match$1[1][/* expression */0];
                              valueReason = expression.tag ? expUnit : expressionMapper(context, expression[0]);
                            } else {
                              valueReason = literalMapper(/* None */0, match$1[1]);
                            }
                          } else {
                            valueReason = Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                      "Js",
                                      /* :: */[
                                        "true_",
                                        /* [] */0
                                      ]
                                    ]));
                          }
                          if (name.tag) {
                            return /* tuple */[
                                    Curry._1(f, "NamespacedName"),
                                    placeholder("notImplementedYet")
                                  ];
                          } else {
                            return /* tuple */[
                                    Curry._1(f, name[0][1][/* name */0]),
                                    valueReason
                                  ];
                          }
                        }
                      }), attributes);
        };
        if (jsxPropHasHyphen) {
          var jsObj = Ast_helper$Jeason.Exp[/* extension */35](/* None */0, /* None */0, /* tuple */[
                astHelperStrLidStr(/* None */0, "bs.obj"),
                /* PStr */Block.__(0, [/* :: */[
                      Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* record */13](/* None */0, /* None */0, constructRecordOrLabels((function (name) {
                                      return astHelperStrLidIdent(/* None */0, /* :: */[
                                                  name,
                                                  /* [] */0
                                                ]);
                                    })), /* None */0)),
                      /* [] */0
                    ]])
              ]);
          return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                              "ReactRe",
                              /* :: */[
                                "createElement",
                                /* [] */0
                              ]
                            ])), /* :: */[
                      /* tuple */[
                        "",
                        Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  name$1,
                                  /* [] */0
                                ]))
                      ],
                      /* :: */[
                        /* tuple */[
                          "",
                          jsObj
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            Ast_helper$Jeason.Exp[/* array */16](/* None */0, /* None */0, childrenReact)
                          ],
                          /* [] */0
                        ]
                      ]
                    ]);
        } else {
          var partialArguments = constructRecordOrLabels(correctIdentifier);
          var $$arguments = Pervasives.$at(partialArguments, /* :: */[
                /* tuple */[
                  "",
                  listToListAst(childrenReact)
                ],
                /* [] */0
              ]);
          return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* Some */[/* :: */[
                        /* tuple */[
                          astHelperStrLidStr(/* Some */[/* false */0], "JSX"),
                          /* PStr */Block.__(0, [/* [] */0])
                        ],
                        /* [] */0
                      ]], Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                              name$1,
                              /* [] */0
                            ])), $$arguments);
        }
    case 1 : 
        return placeholder("noNameSpaceJSXYet");
    case 2 : 
        return placeholder("complexJSXYet");
    
  }
}

function jsxChildMapper(context, param) {
  var child = param[1];
  switch (child.tag | 0) {
    case 0 : 
        return /* Some */[jsxElementMapper(context, child[0])];
    case 1 : 
        var expression = child[0][/* expression */0];
        if (expression.tag) {
          return /* Some */[expUnit];
        } else {
          return /* Some */[expressionMapper(context, expression[0])];
        }
    case 2 : 
        var trimmedValue = $$String.trim(child[0][/* value */0]);
        if (trimmedValue === "") {
          return /* None */0;
        } else {
          return /* Some */[Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                          trimmedValue,
                          /* None */0
                        ]))];
        }
    
  }
}

function objectMapper(context, param) {
  var properties = param[/* properties */0];
  if (properties) {
    return Ast_helper$Jeason.Exp[/* extension */35](/* None */0, /* None */0, /* tuple */[
                astHelperStrLidStr(/* None */0, "bs.obj"),
                /* PStr */Block.__(0, [/* :: */[
                      Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* record */13](/* None */0, /* None */0, List.map((function (property) {
                                      if (property.tag) {
                                        return /* tuple */[
                                                astHelperStrLidIdent(/* None */0, /* :: */[
                                                      "objectSpreadNotImplementedYet",
                                                      /* [] */0
                                                    ]),
                                                placeholder("objectSpreadNotImplementedYet")
                                              ];
                                      } else {
                                        var match = property[0][1];
                                        var key = match[/* key */0];
                                        var keyReason;
                                        switch (key.tag | 0) {
                                          case 0 : 
                                              var name = key[0][1][/* value */0];
                                              if (typeof name === "number") {
                                                keyReason = /* :: */[
                                                  "null",
                                                  /* [] */0
                                                ];
                                              } else {
                                                switch (name.tag | 0) {
                                                  case 0 : 
                                                      keyReason = /* :: */[
                                                        name[0],
                                                        /* [] */0
                                                      ];
                                                      break;
                                                  case 1 : 
                                                      keyReason = /* :: */[
                                                        Pervasives.string_of_bool(name[0]),
                                                        /* [] */0
                                                      ];
                                                      break;
                                                  case 2 : 
                                                      keyReason = /* :: */[
                                                        Pervasives.string_of_float(name[0]),
                                                        /* [] */0
                                                      ];
                                                      break;
                                                  case 3 : 
                                                      keyReason = /* :: */[
                                                        "regexAsKeyNotImplementedYet",
                                                        /* [] */0
                                                      ];
                                                      break;
                                                  
                                                }
                                              }
                                              break;
                                          case 1 : 
                                              keyReason = /* :: */[
                                                key[0][1],
                                                /* [] */0
                                              ];
                                              break;
                                          case 2 : 
                                              keyReason = /* :: */[
                                                "notThereYet",
                                                /* [] */0
                                              ];
                                              break;
                                          
                                        }
                                        return /* tuple */[
                                                astHelperStrLidIdent(/* None */0, keyReason),
                                                expressionMapper(context, match[/* value */1])
                                              ];
                                      }
                                    }), properties), /* None */0)),
                      /* [] */0
                    ]])
              ]);
  } else {
    return Ast_helper$Jeason.Exp[/* extension */35](/* None */0, /* None */0, /* tuple */[
                astHelperStrLidStr(/* None */0, "bs.raw"),
                /* PStr */Block.__(0, [/* :: */[
                      Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                                  "{}",
                                  /* None */0
                                ]))),
                      /* [] */0
                    ]])
              ]);
  }
}

function memberMapper(context, param) {
  var computed = param[/* computed */2];
  var property = param[/* property */1];
  var objectWrap = param[/* _object */0];
  var _object = objectWrap[1];
  var defaultCase = function () {
    var left = expressionMapper(context, objectWrap);
    if (property.tag) {
      var expr = property[0];
      var expr$1 = expr[1];
      var exit = 0;
      if (typeof expr$1 === "number" || expr$1.tag !== 18) {
        exit = 1;
      } else {
        var match = expr$1[0][/* value */0];
        if (typeof match === "number" || match.tag !== 2) {
          exit = 1;
        } else {
          var n = match[0];
          var intN = n | 0;
          if (intN === n) {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "Array",
                                /* :: */[
                                  "get",
                                  /* [] */0
                                ]
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          left
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_int */Block.__(0, [intN]))
                          ],
                          /* [] */0
                        ]
                      ]);
          } else {
            return expressionMapper(context, expr);
          }
        }
      }
      if (exit === 1) {
        var exit$1 = 0;
        if (typeof _object === "number" || _object.tag !== 17) {
          exit$1 = 2;
        } else {
          var exit$2 = 0;
          switch (_object[0][1]) {
            case "ReactDOM" : 
            case "reactDOM" : 
                exit$2 = 3;
                break;
            default:
              exit$1 = 2;
          }
          if (exit$2 === 3) {
            var name;
            name = property.tag ? "notSureWhatThisIs" : property[0][1];
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "ReactDOMRe",
                                /* :: */[
                                  name,
                                  /* [] */0
                                ]
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          expressionMapper(context, expr)
                        ],
                        /* [] */0
                      ]);
          }
          
        }
        if (exit$1 === 2) {
          if (computed) {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "Array",
                                /* :: */[
                                  "get",
                                  /* [] */0
                                ]
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          left
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, expr)
                          ],
                          /* [] */0
                        ]
                      ]);
          } else {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "##",
                                /* [] */0
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          left
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, expr)
                          ],
                          /* [] */0
                        ]
                      ]);
          }
        }
        
      }
      
    } else {
      var name$1 = property[0][1];
      var exit$3 = 0;
      if (typeof _object === "number" || _object.tag !== 17) {
        exit$3 = 1;
      } else {
        var exit$4 = 0;
        switch (_object[0][1]) {
          case "ReactDOM" : 
          case "reactDOM" : 
              exit$4 = 2;
              break;
          default:
            exit$3 = 1;
        }
        if (exit$4 === 2) {
          return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                          "ReactDOMRe",
                          /* :: */[
                            name$1,
                            /* [] */0
                          ]
                        ]));
        }
        
      }
      if (exit$3 === 1) {
        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                            "##",
                            /* [] */0
                          ])), /* :: */[
                    /* tuple */[
                      "",
                      left
                    ],
                    /* :: */[
                      /* tuple */[
                        "",
                        Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                  name$1,
                                  /* [] */0
                                ]))
                      ],
                      /* [] */0
                    ]
                  ]);
      }
      
    }
  };
  var match = context[/* insideReactClass */1];
  if (typeof match === "number") {
    if (match !== 0) {
      if (property.tag) {
        return expressionMapper(context, property[0]);
      } else {
        var name = property[0][1];
        var exit = 0;
        switch (name) {
          case "isRequired" : 
              return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  "ReactRe",
                                  /* :: */[
                                    "PropTypes",
                                    /* :: */[
                                      name,
                                      /* [] */0
                                    ]
                                  ]
                                ])), /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, objectWrap)
                          ],
                          /* [] */0
                        ]);
          case "object" : 
              return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                              "ReactRe",
                              /* :: */[
                                "PropTypes",
                                /* :: */[
                                  "object_",
                                  /* [] */0
                                ]
                              ]
                            ]));
          case "any" : 
          case "arrayOf" : 
          case "bool" : 
          case "element" : 
          case "func" : 
          case "instanceOf" : 
          case "node" : 
          case "number" : 
          case "objectOf" : 
          case "oneOf" : 
          case "oneOfType" : 
          case "shape" : 
          case "string" : 
          case "symbol" : 
              exit = 1;
              break;
          default:
            return defaultCase(/* () */0);
        }
        if (exit === 1) {
          return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                          "ReactRe",
                          /* :: */[
                            "PropTypes",
                            /* :: */[
                              name,
                              /* [] */0
                            ]
                          ]
                        ]));
        }
        
      }
    } else {
      return defaultCase(/* () */0);
    }
  } else if (typeof _object === "number" && !(_object !== 0 || property.tag)) {
    var name$1 = property[0][1];
    var exit$1 = 0;
    switch (name$1) {
      case "props" : 
      case "state" : 
          exit$1 = 1;
          break;
      default:
        return defaultCase(/* () */0);
    }
    if (exit$1 === 1) {
      return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                      name$1,
                      /* [] */0
                    ]));
    }
    
  } else {
    return defaultCase(/* () */0);
  }
}

function statementMapper(context, _param) {
  while(true) {
    var param = _param;
    var statement = param[1];
    var exit = 0;
    if (typeof statement === "number") {
      if (statement === 0) {
        var match = context[/* terminalExpr */0];
        if (match) {
          return match[0];
        } else {
          return expUnit;
        }
      } else {
        exit = 1;
      }
    } else {
      switch (statement.tag | 0) {
        case 0 : 
            return statementBlockMapper(context, statement[0]);
        case 1 : 
            var expression = statement[0][/* expression */0];
            var match$1 = context[/* terminalExpr */0];
            if (match$1) {
              return Ast_helper$Jeason.Exp[/* sequence */18](/* None */0, /* None */0, expressionMapper(context, expression), match$1[0]);
            } else {
              return expressionMapper(context, expression);
            }
        case 2 : 
            var match$2 = statement[0];
            var alternate = match$2[/* alternate */2];
            var result = Ast_helper$Jeason.Exp[/* ifthenelse */17](/* None */0, /* None */0, expressionMapper(context, match$2[/* test */0]), statementMapper(/* record */[
                      /* terminalExpr : None */0,
                      /* insideReactClass */context[/* insideReactClass */1],
                      /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2]
                    ], match$2[/* consequent */1]), alternate ? /* Some */[statementMapper(/* record */[
                          /* terminalExpr : None */0,
                          /* insideReactClass */context[/* insideReactClass */1],
                          /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2]
                        ], alternate[0])] : /* None */0);
            var match$3 = context[/* terminalExpr */0];
            if (match$3) {
              return Ast_helper$Jeason.Exp[/* sequence */18](/* None */0, /* None */0, result, match$3[0]);
            } else {
              return result;
            }
        case 9 : 
            var argument = statement[0][/* argument */0];
            var result$1 = argument ? expressionMapper(context, argument[0]) : expUnit;
            var match$4 = context[/* terminalExpr */0];
            if (match$4) {
              return Ast_helper$Jeason.Exp[/* sequence */18](/* None */0, /* None */0, result$1, match$4[0]);
            } else {
              return result$1;
            }
        case 17 : 
            var functionWrap = statement[0];
            var match$5 = functionWrap[/* id */0];
            var funcName = match$5 ? match$5[0][1] : "thisNameShouldntAppearPleaseReport";
            var match$6 = context[/* terminalExpr */0];
            var innerMostExpr = match$6 ? match$6[0] : expUnit;
            return Ast_helper$Jeason.Exp[/* let_ */4](/* None */0, /* None */0, /* Nonrecursive */0, /* :: */[
                        parseTreeValueBinding(Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, funcName)), functionMapper(context, /* None */0, functionWrap)),
                        /* [] */0
                      ], innerMostExpr);
        case 18 : 
            var match$7 = List.hd(statement[0][/* declarations */0]);
            var match$8 = match$7[1];
            var init = match$8[/* init */1];
            var id = match$8[/* id */0][1];
            var match$9;
            if (init) {
              var match$10 = init[0][1];
              if (typeof match$10 === "number") {
                match$9 = /* tuple */[
                  context,
                  /* None */0
                ];
              } else if (match$10.tag === 12) {
                var match$11 = match$10[0];
                var match$12 = match$11[/* callee */0][1];
                if (typeof match$12 === "number") {
                  match$9 = /* tuple */[
                    context,
                    /* None */0
                  ];
                } else if (match$12.tag === 13) {
                  var match$13 = match$12[0];
                  var match$14 = match$13[/* _object */0][1];
                  if (typeof match$14 === "number") {
                    match$9 = /* tuple */[
                      context,
                      /* None */0
                    ];
                  } else if (match$14.tag === 17) {
                    if (match$14[0][1] === "React") {
                      var match$15 = match$13[/* property */1];
                      match$9 = match$15.tag ? /* tuple */[
                          context,
                          /* None */0
                        ] : (
                          match$15[0][1] === "createClass" ? (
                              id.tag === 3 ? /* tuple */[
                                  /* record */[
                                    /* terminalExpr */context[/* terminalExpr */0],
                                    /* insideReactClass : Yes */[id[0][/* name */0][1]],
                                    /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2]
                                  ],
                                  /* Some */[match$11[/* arguments */1]]
                                ] : /* tuple */[
                                  context,
                                  /* None */0
                                ]
                            ) : /* tuple */[
                              context,
                              /* None */0
                            ]
                        );
                    } else {
                      match$9 = /* tuple */[
                        context,
                        /* None */0
                      ];
                    }
                  } else {
                    match$9 = /* tuple */[
                      context,
                      /* None */0
                    ];
                  }
                } else {
                  match$9 = /* tuple */[
                    context,
                    /* None */0
                  ];
                }
              } else {
                match$9 = /* tuple */[
                  context,
                  /* None */0
                ];
              }
            } else {
              match$9 = /* tuple */[
                context,
                /* None */0
              ];
            }
            var context$1 = match$9[0];
            var expr = init ? expressionMapper(context$1, init[0]) : Ast_helper$Jeason.Exp[/* construct */11](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                        "None",
                        /* [] */0
                      ]), /* None */0);
            var match$16 = context$1[/* terminalExpr */0];
            var innerMostExpr$1 = match$16 ? match$16[0] : expUnit;
            switch (id.tag | 0) {
              case 0 : 
                  var properties = id[0][/* properties */0];
                  var exit$1 = 0;
                  if (properties) {
                    var match$17 = properties[0];
                    if (match$17.tag) {
                      exit$1 = 2;
                    } else {
                      var match$18 = match$17[0][1][/* key */0];
                      switch (match$18.tag | 0) {
                        case 1 : 
                            if (match$18[0][1] === "PropTypes" && !(properties[1] || !init)) {
                              var match$19 = init[0][1];
                              if (typeof match$19 === "number" || !(match$19.tag === 17 && match$19[0][1] === "React")) {
                                exit$1 = 2;
                              } else {
                                return innerMostExpr$1;
                              }
                            } else {
                              exit$1 = 2;
                            }
                            break;
                        case 0 : 
                        case 2 : 
                            exit$1 = 2;
                            break;
                        
                      }
                    }
                  } else {
                    exit$1 = 2;
                  }
                  if (exit$1 === 2) {
                    return Ast_helper$Jeason.Exp[/* let_ */4](/* None */0, /* None */0, /* Nonrecursive */0, /* :: */[
                                parseTreeValueBinding(Ast_helper$Jeason.Pat[/* constant */5](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                                            "destructuringNotImplemented",
                                            /* None */0
                                          ])), expr),
                                /* [] */0
                              ], innerMostExpr$1);
                  }
                  break;
              case 3 : 
                  return Ast_helper$Jeason.Exp[/* let_ */4](/* None */0, /* None */0, /* Nonrecursive */0, /* :: */[
                              parseTreeValueBinding(Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, match$9[1] ? "comp" : id[0][/* name */0][1])), expr),
                              /* [] */0
                            ], innerMostExpr$1);
              default:
                return Ast_helper$Jeason.Exp[/* let_ */4](/* None */0, /* None */0, /* Nonrecursive */0, /* :: */[
                            parseTreeValueBinding(Ast_helper$Jeason.Pat[/* constant */5](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                                        "destructuringNotImplemented",
                                        /* None */0
                                      ])), expr),
                            /* [] */0
                          ], innerMostExpr$1);
            }
            break;
        case 19 : 
            var match$20 = statement[0];
            var superClass = match$20[/* superClass */2];
            var id$1 = match$20[/* id */0];
            if (id$1 && superClass) {
              var match$21 = superClass[0][1];
              if (typeof match$21 === "number" || match$21.tag !== 13) {
                return placeholder("GeneralClassTransformNotImplementedYet");
              } else {
                var match$22 = match$21[0][/* _object */0][1];
                if (typeof match$22 === "number" || match$22.tag !== 17) {
                  return placeholder("GeneralClassTransformNotImplementedYet");
                } else {
                  var className = id$1[0][1];
                  if (match$22[0][1] === "React") {
                    var context_000 = /* terminalExpr */context[/* terminalExpr */0];
                    var context_001 = /* insideReactClass : Yes */[className];
                    var context_002 = /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2];
                    var context$2 = /* record */[
                      context_000,
                      context_001,
                      context_002
                    ];
                    var hasDisplayNameAlready = [/* false */0];
                    var createClassSpecForEs6Class = List.map((function(context$2,hasDisplayNameAlready,context_000,context_002){
                        return function (property) {
                          if (property.tag) {
                            var match = property[0][1];
                            var $$static = match[/* static */3];
                            var value = match[/* value */1];
                            var key = match[/* key */0];
                            var exit = 0;
                            switch (key.tag | 0) {
                              case 1 : 
                                  var name = key[0][1];
                                  var exit$1 = 0;
                                  var exit$2 = 0;
                                  switch (name) {
                                    case "displayName" : 
                                        if ($$static !== 0) {
                                          if (value) {
                                            hasDisplayNameAlready[0] = /* true */1;
                                            return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                          /* Fresh */1,
                                                          expressionMapper(context$2, value[0])
                                                        ]));
                                          } else {
                                            exit$2 = 3;
                                          }
                                        } else {
                                          exit$1 = 2;
                                        }
                                        break;
                                    case "propTypes" : 
                                        if ($$static !== 0) {
                                          if (value) {
                                            return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                          /* Fresh */1,
                                                          expressionMapper(/* record */[
                                                                context_000,
                                                                /* insideReactClass : InsidePropTypes */1,
                                                                context_002
                                                              ], value[0])
                                                        ]));
                                          } else {
                                            exit$2 = 3;
                                          }
                                        } else {
                                          exit$1 = 2;
                                        }
                                        break;
                                    default:
                                      exit$2 = 3;
                                  }
                                  if (exit$2 === 3) {
                                    if ($$static !== 0) {
                                      return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "staticPropertyOtherThanPropTypes"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                    /* Fresh */1,
                                                    placeholder("notImplementedYet")
                                                  ]));
                                    } else {
                                      exit$1 = 2;
                                    }
                                  }
                                  if (exit$1 === 2) {
                                    if (value) {
                                      if (name === "state") {
                                        return Ast_helper$Jeason.Cf[/* method_ */4](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "getInitialState"), /* Public */1, /* Cfk_concrete */Block.__(1, [
                                                      /* Fresh */1,
                                                      Ast_helper$Jeason.Exp[/* poly */30](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* fun_ */5](/* None */0, /* None */0, "", /* None */0, Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                                        "()",
                                                                        /* [] */0
                                                                      ]), /* None */0), Ast_helper$Jeason.Exp[/* constraint_ */22](/* None */0, /* None */0, expressionMapper(context$2, value[0]), Ast_helper$Jeason.Typ[/* constr */6](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                                                            "state",
                                                                            /* [] */0
                                                                          ]), /* [] */0))), /* None */0)
                                                    ]));
                                      } else {
                                        var value$1 = value[0];
                                        var match$1 = value$1[1];
                                        var exit$3 = 0;
                                        if (typeof match$1 === "number") {
                                          exit$3 = 4;
                                        } else {
                                          switch (match$1.tag | 0) {
                                            case 2 : 
                                            case 3 : 
                                                exit$3 = 3;
                                                break;
                                            default:
                                              exit$3 = 4;
                                          }
                                        }
                                        switch (exit$3) {
                                          case 3 : 
                                              return Ast_helper$Jeason.Cf[/* method_ */4](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Public */1, /* Cfk_concrete */Block.__(1, [
                                                            /* Fresh */1,
                                                            Ast_helper$Jeason.Exp[/* poly */30](/* None */0, /* None */0, functionMapper(context$2, /* None */0, match$1[0]), /* None */0)
                                                          ]));
                                          case 4 : 
                                              return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Mutable */1, /* Cfk_concrete */Block.__(1, [
                                                            /* Fresh */1,
                                                            expressionMapper(context$2, value$1)
                                                          ]));
                                          
                                        }
                                      }
                                    } else {
                                      return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Mutable */1, /* Cfk_concrete */Block.__(1, [
                                                    /* Fresh */1,
                                                    Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                              "Js",
                                                              /* :: */[
                                                                "null",
                                                                /* [] */0
                                                              ]
                                                            ]))
                                                  ]));
                                    }
                                  }
                                  break;
                              case 0 : 
                              case 2 : 
                                  exit = 1;
                                  break;
                              
                            }
                            if (exit === 1) {
                              return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "complexClassPropKey"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                            /* Fresh */1,
                                            placeholder("notImplementedYet")
                                          ]));
                            }
                            
                          } else {
                            var match$2 = property[0][1];
                            var key$1 = match$2[/* key */1];
                            var exit$4 = 0;
                            switch (key$1.tag | 0) {
                              case 1 : 
                                  if (match$2[/* static */3]) {
                                    return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "staticMethod"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                  /* Fresh */1,
                                                  placeholder("notImplementedYet")
                                                ]));
                                  } else {
                                    return Ast_helper$Jeason.Cf[/* method_ */4](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, key$1[0][1]), /* Public */1, /* Cfk_concrete */Block.__(1, [
                                                  /* Fresh */1,
                                                  Ast_helper$Jeason.Exp[/* poly */30](/* None */0, /* None */0, functionMapper(context$2, /* None */0, match$2[/* value */2][1]), /* None */0)
                                                ]));
                                  }
                              case 0 : 
                              case 2 : 
                                  exit$4 = 1;
                                  break;
                              
                            }
                            if (exit$4 === 1) {
                              return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "complexClassPropKey"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                            /* Fresh */1,
                                            placeholder("notImplementedYet")
                                          ]));
                            }
                            
                          }
                        }
                        }(context$2,hasDisplayNameAlready,context_000,context_002)), List.filter((function (property) {
                                  if (property.tag) {
                                    var match = property[0][1][/* key */0];
                                    switch (match.tag | 0) {
                                      case 1 : 
                                          if (match[0][1] === "props") {
                                            return /* false */0;
                                          } else {
                                            return /* true */1;
                                          }
                                      case 0 : 
                                      case 2 : 
                                          return /* true */1;
                                      
                                    }
                                  } else {
                                    return /* true */1;
                                  }
                                }))(match$20[/* body */1][1][/* body */0]));
                    var match$23 = hasDisplayNameAlready[0];
                    var createClassSpecForEs6Class$1 = match$23 !== 0 ? createClassSpecForEs6Class : /* :: */[
                        Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "displayName"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                /* Fresh */1,
                                Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                                        className,
                                        /* None */0
                                      ]))
                              ])),
                        createClassSpecForEs6Class
                      ];
                    var createClassObj = Ast_helper$Jeason.Exp[/* object_ */31](/* None */0, /* Some */[/* :: */[
                            /* tuple */[
                              astHelperStrLidStr(/* None */0, "bs"),
                              /* PStr */Block.__(0, [/* [] */0])
                            ],
                            /* [] */0
                          ]], Ast_helper$Jeason.Cstr[/* mk */0](Ast_helper$Jeason.Pat[/* mk */0](/* None */0, /* None */0, /* Ppat_var */Block.__(0, [astHelperStrLidStr(/* None */0, "this")])), createClassSpecForEs6Class$1));
                    var expr$1 = Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  "ReactRe",
                                  /* :: */[
                                    "createClass",
                                    /* [] */0
                                  ]
                                ])), /* :: */[
                          /* tuple */[
                            "",
                            createClassObj
                          ],
                          /* [] */0
                        ]);
                    var match$24 = context_000;
                    var terminal = match$24 ? match$24[0] : expUnit;
                    return Ast_helper$Jeason.Exp[/* let_ */4](/* None */0, /* None */0, /* Nonrecursive */0, /* :: */[
                                parseTreeValueBinding(Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "comp")), expr$1),
                                /* [] */0
                              ], terminal);
                  } else {
                    return placeholder("GeneralClassTransformNotImplementedYet");
                  }
                }
              }
            } else {
              return placeholder("GeneralClassTransformNotImplementedYet");
            }
        case 27 : 
            var declaration = statement[0][/* declaration */0];
            if (declaration) {
              _param = declaration[0];
              continue ;
              
            } else {
              return expUnit;
            }
        case 28 : 
            var declaration$1 = statement[0][/* declaration */0];
            if (declaration$1.tag) {
              return expressionMapper(context, declaration$1[0]);
            } else {
              _param = declaration$1[0];
              continue ;
              
            }
        default:
          exit = 1;
      }
    }
    if (exit === 1) {
      var match$25 = context[/* terminalExpr */0];
      if (match$25) {
        return Ast_helper$Jeason.Exp[/* sequence */18](/* None */0, /* None */0, placeholder("statementBail"), match$25[0]);
      } else {
        return placeholder("statementBail");
      }
    }
    
  };
}

function expressionMapper(context, param) {
  var expression = param[1];
  var exit = 0;
  if (typeof expression === "number") {
    if (expression === 0) {
      return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                      "this",
                      /* [] */0
                    ]));
    } else {
      exit = 1;
    }
  } else {
    switch (expression.tag | 0) {
      case 0 : 
          var eta = List.map((function (element) {
                  if (element) {
                    var match = element[0];
                    if (match.tag) {
                      return placeholder("argumentSpreadNotImplementedYet");
                    } else {
                      return expressionMapper(context, match[0]);
                    }
                  } else {
                    return Ast_helper$Jeason.Exp[/* construct */11](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                    "None",
                                    /* [] */0
                                  ]), /* None */0);
                  }
                }), expression[0][/* elements */0]);
          return Ast_helper$Jeason.Exp[/* array */16](/* None */0, /* None */0, eta);
      case 1 : 
          return objectMapper(context, expression[0]);
      case 2 : 
      case 3 : 
          return functionMapper(context, /* None */0, expression[0]);
      case 5 : 
          var match = expression[0];
          var argumentWrap = match[/* argument */2];
          var argument = argumentWrap[1];
          var operator = match[/* operator */0];
          var exit$1 = 0;
          if (operator >= 3) {
            exit$1 = 2;
          } else {
            switch (operator) {
              case 0 : 
                  var exit$2 = 0;
                  if (typeof argument === "number" || argument.tag !== 18) {
                    exit$2 = 3;
                  } else {
                    var lit = argument[0];
                    var tmp = lit[/* value */0];
                    if (typeof tmp === "number" || tmp.tag !== 2) {
                      exit$2 = 3;
                    } else {
                      return literalMapper(/* Some */[/* true */1], lit);
                    }
                  }
                  if (exit$2 === 3) {
                    return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                        "~-",
                                        /* [] */0
                                      ])), /* :: */[
                                /* tuple */[
                                  "",
                                  expressionMapper(context, argumentWrap)
                                ],
                                /* [] */0
                              ]);
                  }
                  break;
              case 1 : 
                  exit$1 = 2;
                  break;
              case 2 : 
                  var exit$3 = 0;
                  if (typeof argument === "number" || argument.tag !== 5) {
                    exit$3 = 3;
                  } else {
                    var match$1 = argument[0];
                    if (match$1[/* operator */0] !== 2) {
                      exit$3 = 3;
                    } else {
                      return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                          "pleaseWriteAIsTruthyFunction",
                                          /* [] */0
                                        ])), /* :: */[
                                  /* tuple */[
                                    "",
                                    expressionMapper(context, match$1[/* argument */2])
                                  ],
                                  /* [] */0
                                ]);
                    }
                  }
                  if (exit$3 === 3) {
                    return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                        "not",
                                        /* [] */0
                                      ])), /* :: */[
                                /* tuple */[
                                  "",
                                  Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                "Js",
                                                /* :: */[
                                                  "to_bool",
                                                  /* [] */0
                                                ]
                                              ])), /* :: */[
                                        /* tuple */[
                                          "",
                                          expressionMapper(context, argumentWrap)
                                        ],
                                        /* [] */0
                                      ])
                                ],
                                /* [] */0
                              ]);
                  }
                  break;
              
            }
          }
          if (exit$1 === 2) {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                "unaryPlaceholder",
                                /* [] */0
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          expressionMapper(context, argumentWrap)
                        ],
                        /* [] */0
                      ]);
          }
          break;
      case 6 : 
          var match$2 = expression[0];
          var right = match$2[/* right */2];
          var left = match$2[/* left */1];
          var operator$1 = match$2[/* operator */0];
          var operatorReason;
          switch (operator$1) {
            case 0 : 
                operatorReason = "=";
                break;
            case 1 : 
                operatorReason = "!=";
                break;
            case 2 : 
                operatorReason = "==";
                break;
            case 3 : 
                operatorReason = "!==";
                break;
            case 4 : 
                operatorReason = "<";
                break;
            case 5 : 
                operatorReason = "<=";
                break;
            case 6 : 
                operatorReason = ">";
                break;
            case 7 : 
                operatorReason = ">=";
                break;
            case 8 : 
                operatorReason = "lsl";
                break;
            case 9 : 
                operatorReason = "lsr";
                break;
            case 10 : 
                operatorReason = "RShift3NotImplemented";
                break;
            case 11 : 
                operatorReason = "+";
                break;
            case 12 : 
                operatorReason = "-";
                break;
            case 13 : 
                operatorReason = "*";
                break;
            case 14 : 
                operatorReason = "**";
                break;
            case 15 : 
                operatorReason = "/";
                break;
            case 16 : 
                operatorReason = "mod";
                break;
            case 17 : 
                operatorReason = "lor";
                break;
            case 18 : 
                operatorReason = "lxor";
                break;
            case 19 : 
                operatorReason = "land";
                break;
            case 20 : 
                operatorReason = "inNotImplemented";
                break;
            case 21 : 
                operatorReason = "instanceOfNotImplemented";
                break;
            
          }
          var exit$4 = 0;
          if (operator$1 !== 0) {
            exit$4 = 2;
          } else {
            var match$3 = left[1];
            var exit$5 = 0;
            if (typeof match$3 === "number" || !(match$3.tag === 18 && typeof match$3[0][/* value */0] === "number")) {
              exit$5 = 3;
            } else {
              return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  "Js",
                                  /* :: */[
                                    "Null_undefined",
                                    /* :: */[
                                      "test",
                                      /* [] */0
                                    ]
                                  ]
                                ])), /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, right)
                          ],
                          /* [] */0
                        ]);
            }
            if (exit$5 === 3) {
              var match$4 = right[1];
              if (typeof match$4 === "number" || !(match$4.tag === 18 && typeof match$4[0][/* value */0] === "number")) {
                exit$4 = 2;
              } else {
                return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                    "Js",
                                    /* :: */[
                                      "Null_undefined",
                                      /* :: */[
                                        "test",
                                        /* [] */0
                                      ]
                                    ]
                                  ])), /* :: */[
                            /* tuple */[
                              "",
                              expressionMapper(context, left)
                            ],
                            /* [] */0
                          ]);
              }
            }
            
          }
          if (exit$4 === 2) {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                operatorReason,
                                /* [] */0
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          expressionMapper(context, left)
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, right)
                          ],
                          /* [] */0
                        ]
                      ]);
          }
          break;
      case 7 : 
          var match$5 = expression[0];
          var left$1 = match$5[/* left */1][1];
          var exit$6 = 0;
          if (left$1.tag === 4) {
            var match$6 = left$1[0][1];
            if (typeof match$6 === "number" || match$6.tag !== 13) {
              exit$6 = 2;
            } else {
              var match$7 = match$6[0];
              var match$8 = match$7[/* _object */0][1];
              if (typeof match$8 === "number" || !(match$8.tag === 17 && match$8[0][1] === "module")) {
                exit$6 = 2;
              } else {
                var match$9 = match$7[/* property */1];
                if (match$9.tag || match$9[0][1] !== "exports") {
                  exit$6 = 2;
                } else {
                  return expUnit;
                }
              }
            }
          } else {
            exit$6 = 2;
          }
          if (exit$6 === 2) {
            var leftReason;
            switch (left$1.tag | 0) {
              case 3 : 
                  leftReason = Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                            left$1[0][/* name */0][1],
                            /* [] */0
                          ]));
                  break;
              case 4 : 
                  leftReason = expressionMapper(context, left$1[0]);
                  break;
              default:
                leftReason = expMarker;
            }
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "#=",
                                /* [] */0
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          leftReason
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, match$5[/* right */2])
                          ],
                          /* [] */0
                        ]
                      ]);
          }
          break;
      case 9 : 
          var match$10 = expression[0];
          var rightWrap = match$10[/* right */2];
          var leftWrap = match$10[/* left */1];
          var toBool = function (expr) {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "Js",
                                /* :: */[
                                  "to_bool",
                                  /* [] */0
                                ]
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          expr
                        ],
                        /* [] */0
                      ]);
          };
          if (match$10[/* operator */0] !== 0) {
            var exit$7 = 0;
            var tmp$1 = rightWrap[1];
            if (typeof tmp$1 === "number" || tmp$1.tag !== 21) {
              exit$7 = 2;
            } else {
              return Ast_helper$Jeason.Exp[/* match_ */8](/* None */0, /* None */0, toBool(expressionMapper(context, leftWrap)), /* :: */[
                          /* record */[
                            /* pc_lhs */Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                      "true",
                                      /* [] */0
                                    ]), /* None */0),
                            /* pc_guard : None */0,
                            /* pc_rhs */expressionMapper(context, rightWrap)
                          ],
                          /* :: */[
                            /* record */[
                              /* pc_lhs */Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                        "false",
                                        /* [] */0
                                      ]), /* None */0),
                              /* pc_guard : None */0,
                              /* pc_rhs */Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                        "Js",
                                        /* :: */[
                                          "null",
                                          /* [] */0
                                        ]
                                      ]))
                            ],
                            /* [] */0
                          ]
                        ]);
            }
            if (exit$7 === 2) {
              return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  "&&",
                                  /* [] */0
                                ])), /* :: */[
                          /* tuple */[
                            "",
                            toBool(expressionMapper(context, leftWrap))
                          ],
                          /* :: */[
                            /* tuple */[
                              "",
                              toBool(expressionMapper(context, rightWrap))
                            ],
                            /* [] */0
                          ]
                        ]);
            }
            
          } else {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                "||",
                                /* [] */0
                              ])), /* :: */[
                        /* tuple */[
                          "",
                          toBool(expressionMapper(context, leftWrap))
                        ],
                        /* :: */[
                          /* tuple */[
                            "",
                            toBool(expressionMapper(context, rightWrap))
                          ],
                          /* [] */0
                        ]
                      ]);
          }
          break;
      case 10 : 
          var match$11 = expression[0];
          return Ast_helper$Jeason.Exp[/* match_ */8](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                  "Js",
                                  /* :: */[
                                    "to_bool",
                                    /* [] */0
                                  ]
                                ])), /* :: */[
                          /* tuple */[
                            "",
                            expressionMapper(context, match$11[/* test */0])
                          ],
                          /* [] */0
                        ]), /* :: */[
                      /* record */[
                        /* pc_lhs */Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                  "true",
                                  /* [] */0
                                ]), /* None */0),
                        /* pc_guard : None */0,
                        /* pc_rhs */expressionMapper(context, match$11[/* consequent */1])
                      ],
                      /* :: */[
                        /* record */[
                          /* pc_lhs */Ast_helper$Jeason.Pat[/* construct */8](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                    "false",
                                    /* [] */0
                                  ]), /* None */0),
                          /* pc_guard : None */0,
                          /* pc_rhs */expressionMapper(context, match$11[/* alternate */2])
                        ],
                        /* [] */0
                      ]
                    ]);
      case 12 : 
          var match$12 = expression[0];
          var $$arguments = match$12[/* arguments */1];
          var calleeWrap = match$12[/* callee */0];
          var callee = calleeWrap[1];
          var argumentsIntoReasonArguments = function ($$arguments) {
            return List.map((function (argument) {
                          if (argument.tag) {
                            return placeholder("argumentSpreadNotImplementedYet");
                          } else {
                            return expressionMapper(context, argument[0]);
                          }
                        }), $$arguments);
          };
          var processArguments = function ($$arguments) {
            var oneArgOrMore = argumentsIntoReasonArguments($$arguments);
            if (oneArgOrMore) {
              return List.map((function (arg) {
                            return /* tuple */[
                                    "",
                                    arg
                                  ];
                          }), oneArgOrMore);
            } else {
              return /* :: */[
                      /* tuple */[
                        "",
                        expUnit
                      ],
                      /* [] */0
                    ];
            }
          };
          var match$13 = context[/* insideReactClass */1];
          var exit$8 = 0;
          if (typeof callee === "number") {
            exit$8 = 2;
          } else {
            switch (callee.tag | 0) {
              case 13 : 
                  var match$14 = callee[0];
                  var match$15 = match$14[/* _object */0][1];
                  if (typeof match$15 === "number") {
                    if (match$15 === 0) {
                      var match$16 = match$14[/* property */1];
                      if (match$16.tag || !(match$16[0][1] === "setState" && typeof match$13 !== "number")) {
                        exit$8 = 2;
                      } else {
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "ReactRe",
                                            /* :: */[
                                              "setState",
                                              /* [] */0
                                            ]
                                          ])), /* :: */[
                                    /* tuple */[
                                      "",
                                      Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                                "this",
                                                /* [] */0
                                              ]))
                                    ],
                                    processArguments($$arguments)
                                  ]);
                      }
                    } else {
                      exit$8 = 2;
                    }
                  } else if (match$15.tag === 17 && match$15[0][1] === "React") {
                    var match$17 = match$14[/* property */1];
                    if (match$17.tag || !(match$17[0][1] === "createClass" && !(typeof match$13 === "number" || !$$arguments))) {
                      exit$8 = 2;
                    } else {
                      var match$18 = $$arguments[0];
                      if (match$18.tag) {
                        exit$8 = 2;
                      } else {
                        var match$19 = match$18[0][1];
                        if (typeof match$19 === "number" || !(match$19.tag === 1 && !$$arguments[1])) {
                          exit$8 = 2;
                        } else {
                          var hasDisplayNameAlready = [/* false */0];
                          var createClassSpecForCreateClassDecl = List.map((function (property) {
                                  var exit = 0;
                                  if (property.tag) {
                                    exit = 1;
                                  } else {
                                    var match = property[0][1];
                                    var match$1 = match[/* key */0];
                                    switch (match$1.tag | 0) {
                                      case 1 : 
                                          if (match[/* kind */2] !== 0) {
                                            exit = 1;
                                          } else {
                                            var valueWrap = match[/* value */1];
                                            var value = valueWrap[1];
                                            var name = match$1[0][1];
                                            var exit$1 = 0;
                                            if (typeof value === "number") {
                                              exit$1 = 3;
                                            } else {
                                              switch (value.tag | 0) {
                                                case 2 : 
                                                case 3 : 
                                                    exit$1 = 2;
                                                    break;
                                                default:
                                                  exit$1 = 3;
                                              }
                                            }
                                            switch (exit$1) {
                                              case 2 : 
                                                  var match$2 = +(name === "getInitialState");
                                                  return Ast_helper$Jeason.Cf[/* method_ */4](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Public */1, /* Cfk_concrete */Block.__(1, [
                                                                /* Fresh */1,
                                                                Ast_helper$Jeason.Exp[/* poly */30](/* None */0, /* None */0, functionMapper(context, match$2 !== 0 ? /* Some */["state"] : /* None */0, value[0]), /* None */0)
                                                              ]));
                                              case 3 : 
                                                  switch (name) {
                                                    case "displayName" : 
                                                        hasDisplayNameAlready[0] = /* true */1;
                                                        return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                                      /* Fresh */1,
                                                                      expressionMapper(context, valueWrap)
                                                                    ]));
                                                    case "mixins" : 
                                                        return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                                      /* Fresh */1,
                                                                      expressionMapper(context, valueWrap)
                                                                    ]));
                                                    case "propTypes" : 
                                                        return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                                      /* Fresh */1,
                                                                      expressionMapper(/* record */[
                                                                            /* terminalExpr */context[/* terminalExpr */0],
                                                                            /* insideReactClass : InsidePropTypes */1,
                                                                            /* reactClassSpecRandomProps */context[/* reactClassSpecRandomProps */2]
                                                                          ], valueWrap)
                                                                    ]));
                                                    default:
                                                      return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, name), /* Mutable */1, /* Cfk_concrete */Block.__(1, [
                                                                    /* Fresh */1,
                                                                    expressionMapper(context, valueWrap)
                                                                  ]));
                                                  }
                                              
                                            }
                                          }
                                          break;
                                      case 0 : 
                                      case 2 : 
                                          exit = 1;
                                          break;
                                      
                                    }
                                  }
                                  if (exit === 1) {
                                    return Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "notSureWhat"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                                  /* Fresh */1,
                                                  Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                                                            "thisIs",
                                                            /* [] */0
                                                          ]))
                                                ]));
                                  }
                                  
                                }), match$19[0][/* properties */0]);
                          var match$20 = hasDisplayNameAlready[0];
                          var createClassSpecForCreateClassDecl$1 = match$20 !== 0 ? createClassSpecForCreateClassDecl : /* :: */[
                              Ast_helper$Jeason.Cf[/* val_ */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "displayName"), /* Immutable */0, /* Cfk_concrete */Block.__(1, [
                                      /* Fresh */1,
                                      Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, /* Const_string */Block.__(2, [
                                              match$13[0],
                                              /* None */0
                                            ]))
                                    ])),
                              createClassSpecForCreateClassDecl
                            ];
                          var createClassObj = Ast_helper$Jeason.Exp[/* object_ */31](/* None */0, /* Some */[/* :: */[
                                  /* tuple */[
                                    astHelperStrLidStr(/* None */0, "bs"),
                                    /* PStr */Block.__(0, [/* [] */0])
                                  ],
                                  /* [] */0
                                ]], Ast_helper$Jeason.Cstr[/* mk */0](Ast_helper$Jeason.Pat[/* mk */0](/* None */0, /* None */0, /* Ppat_var */Block.__(0, [astHelperStrLidStr(/* None */0, "this")])), createClassSpecForCreateClassDecl$1));
                          return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                              "ReactRe",
                                              /* :: */[
                                                "createClass",
                                                /* [] */0
                                              ]
                                            ])), /* :: */[
                                      /* tuple */[
                                        "",
                                        createClassObj
                                      ],
                                      /* [] */0
                                    ]);
                        }
                      }
                    }
                  } else {
                    exit$8 = 2;
                  }
                  break;
              case 17 : 
                  switch (callee[0][1]) {
                    case "cssVar" : 
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "CssVarRe",
                                            /* :: */[
                                              "cssVarRe",
                                              /* [] */0
                                            ]
                                          ])), processArguments($$arguments));
                    case "cx" : 
                        var argumentsIntoReasonArguments2 = function ($$arguments) {
                          return List.map((function (argument) {
                                        if (argument.tag) {
                                          return placeholder("unregonizedSpreadInCx");
                                        } else {
                                          var expr = argument[0];
                                          var exit = 0;
                                          var tmp = expr[1];
                                          if (typeof tmp === "number" || tmp.tag !== 18) {
                                            exit = 1;
                                          } else {
                                            return expressionMapper(context, expr);
                                          }
                                          if (exit === 1) {
                                            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                                                "Obj",
                                                                /* :: */[
                                                                  "magic",
                                                                  /* [] */0
                                                                ]
                                                              ])), /* :: */[
                                                        /* tuple */[
                                                          "",
                                                          expressionMapper(context, expr)
                                                        ],
                                                        /* [] */0
                                                      ]);
                                          }
                                          
                                        }
                                      }), $$arguments);
                        };
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "CxRe",
                                            /* :: */[
                                              "cxRe",
                                              /* [] */0
                                            ]
                                          ])), /* :: */[
                                    /* tuple */[
                                      "",
                                      Ast_helper$Jeason.Exp[/* array */16](/* None */0, /* None */0, argumentsIntoReasonArguments2($$arguments))
                                    ],
                                    /* [] */0
                                  ]);
                    case "fbt" : 
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "FbtRe",
                                            /* :: */[
                                              "fbtRe",
                                              /* [] */0
                                            ]
                                          ])), processArguments($$arguments));
                    case "invariant" : 
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "InvariantRe",
                                            /* :: */[
                                              "invariant",
                                              /* [] */0
                                            ]
                                          ])), processArguments($$arguments));
                    case "ix" : 
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "IxRe",
                                            /* :: */[
                                              "ix",
                                              /* [] */0
                                            ]
                                          ])), processArguments($$arguments));
                    case "joinClasses" : 
                        var argumentsIntoReasonArguments2$1 = function ($$arguments) {
                          return List.map((function (argument) {
                                        if (argument.tag) {
                                          return placeholder("unregonizedSpreadInCx");
                                        } else {
                                          return expressionMapper(context, argument[0]);
                                        }
                                      }), $$arguments);
                        };
                        return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* Some */[/* false */0], /* :: */[
                                            "JoinClassesRe",
                                            /* :: */[
                                              "joinClasses",
                                              /* [] */0
                                            ]
                                          ])), /* :: */[
                                    /* tuple */[
                                      "",
                                      Ast_helper$Jeason.Exp[/* array */16](/* None */0, /* None */0, argumentsIntoReasonArguments2$1($$arguments))
                                    ],
                                    /* [] */0
                                  ]);
                    default:
                      exit$8 = 2;
                  }
              default:
                exit$8 = 2;
            }
          }
          if (exit$8 === 2) {
            return Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, expressionMapper(context, calleeWrap), processArguments($$arguments));
          }
          break;
      case 13 : 
          return memberMapper(context, expression[0]);
      case 17 : 
          return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                          expression[0][1],
                          /* [] */0
                        ]));
      case 18 : 
          return literalMapper(/* None */0, expression[0]);
      case 21 : 
          return jsxElementMapper(context, expression[0]);
      default:
        exit = 1;
    }
  }
  if (exit === 1) {
    return Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, astHelperStrLidIdent(/* None */0, /* :: */[
                    "expressionPlaceholder",
                    /* [] */0
                  ]));
  }
  
}

function topStatementsMapper(statementWrap) {
  var match = statementMapper(/* record */[
        /* terminalExpr : None */0,
        /* insideReactClass : Nope */0,
        /* reactClassSpecRandomProps : [] */0
      ], statementWrap);
  var pexp_desc = match[/* pexp_desc */0];
  switch (pexp_desc.tag | 0) {
    case 0 : 
        return /* :: */[
                Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ident */2](/* None */0, /* None */0, pexp_desc[0])),
                /* [] */0
              ];
    case 1 : 
        var a = pexp_desc[0];
        var exit = 0;
        if (a.tag === 2 && a[0] === "use strict") {
          return /* [] */0;
        } else {
          exit = 1;
        }
        if (exit === 1) {
          return /* :: */[
                  Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* constant */3](/* None */0, /* None */0, a)),
                  /* [] */0
                ];
        }
        break;
    case 2 : 
        var valueBindings = pexp_desc[1];
        var extraDeclarations;
        if (valueBindings) {
          var match$1 = valueBindings[0][/* pvb_expr */1][/* pexp_desc */0];
          if (match$1.tag === 5) {
            var match$2 = match$1[0][/* pexp_desc */0];
            if (match$2.tag) {
              extraDeclarations = /* [] */0;
            } else {
              var match$3 = match$2[0][/* txt */0];
              switch (match$3.tag | 0) {
                case 1 : 
                    var match$4 = match$3[0];
                    switch (match$4.tag | 0) {
                      case 0 : 
                          if (match$4[0] === "ReactRe" && match$3[1] === "createClass") {
                            var match$5 = match$1[1];
                            if (match$5) {
                              var match$6 = match$5[0][1][/* pexp_desc */0];
                              if (match$6.tag === 29 && !(match$5[1] || valueBindings[1])) {
                                var pcstr_fields = match$6[0][/* pcstr_fields */1];
                                var propTypes = List.filter((function (param) {
                                          var pcf_desc = param[/* pcf_desc */0];
                                          if (pcf_desc.tag === 1 && pcf_desc[0][0][/* txt */0] === "propTypes") {
                                            return /* true */1;
                                          } else {
                                            return /* false */0;
                                          }
                                        }))(pcstr_fields);
                                var extraDeclarationsFromProps;
                                if (propTypes) {
                                  var match$7 = propTypes[0][/* pcf_desc */0];
                                  if (match$7.tag === 1) {
                                    var match$8 = match$7[0][2];
                                    if (match$8.tag) {
                                      var match$9 = match$8[1][/* pexp_desc */0];
                                      if (match$9.tag === 33) {
                                        var match$10 = match$9[0][1];
                                        switch (match$10.tag | 0) {
                                          case 0 : 
                                              var match$11 = match$10[0];
                                              if (match$11) {
                                                var match$12 = match$11[0][/* pstr_desc */0];
                                                if (match$12.tag) {
                                                  extraDeclarationsFromProps = /* [] */0;
                                                } else {
                                                  var match$13 = match$12[0][/* pexp_desc */0];
                                                  if (match$13.tag === 11 && !(match$11[1] || propTypes[1])) {
                                                    var fields = match$13[0];
                                                    if (fields) {
                                                      var match$14 = propTypesToActualTypes(fields);
                                                      extraDeclarationsFromProps = /* :: */[
                                                        match$14[0],
                                                        /* :: */[
                                                          match$14[1],
                                                          /* [] */0
                                                        ]
                                                      ];
                                                    } else {
                                                      extraDeclarationsFromProps = /* [] */0;
                                                    }
                                                  } else {
                                                    extraDeclarationsFromProps = /* [] */0;
                                                  }
                                                }
                                              } else {
                                                extraDeclarationsFromProps = /* [] */0;
                                              }
                                              break;
                                          case 1 : 
                                          case 2 : 
                                              extraDeclarationsFromProps = /* [] */0;
                                              break;
                                          
                                        }
                                      } else {
                                        extraDeclarationsFromProps = /* [] */0;
                                      }
                                    } else {
                                      extraDeclarationsFromProps = /* [] */0;
                                    }
                                  } else {
                                    extraDeclarationsFromProps = /* [] */0;
                                  }
                                } else {
                                  extraDeclarationsFromProps = /* [] */0;
                                }
                                var getInitialState = List.filter((function (param) {
                                          var pcf_desc = param[/* pcf_desc */0];
                                          if (pcf_desc.tag === 2 && pcf_desc[0][0][/* txt */0] === "getInitialState") {
                                            return /* true */1;
                                          } else {
                                            return /* false */0;
                                          }
                                        }))(pcstr_fields);
                                var extraDeclarationsFromState = getInitialState && !getInitialState[1] ? /* :: */[
                                    attemptToGenerateStateRecord(getInitialState[0]),
                                    /* [] */0
                                  ] : /* [] */0;
                                extraDeclarations = Pervasives.$at(extraDeclarationsFromProps, extraDeclarationsFromState);
                              } else {
                                extraDeclarations = /* [] */0;
                              }
                            } else {
                              extraDeclarations = /* [] */0;
                            }
                          } else {
                            extraDeclarations = /* [] */0;
                          }
                          break;
                      case 1 : 
                      case 2 : 
                          extraDeclarations = /* [] */0;
                          break;
                      
                    }
                    break;
                case 0 : 
                case 2 : 
                    extraDeclarations = /* [] */0;
                    break;
                
              }
            }
          } else {
            extraDeclarations = /* [] */0;
          }
        } else {
          extraDeclarations = /* :: */[
            Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, expMarker),
            /* [] */0
          ];
        }
        var baseDeclarations;
        var exit$1 = 0;
        if (valueBindings) {
          var match$15 = valueBindings[0][/* pvb_expr */1][/* pexp_desc */0];
          if (match$15.tag === 5) {
            var match$16 = match$15[0][/* pexp_desc */0];
            if (match$16.tag) {
              exit$1 = 1;
            } else {
              var match$17 = match$16[0][/* txt */0];
              switch (match$17.tag | 0) {
                case 0 : 
                    if (match$17[0] === "require" && !valueBindings[1]) {
                      baseDeclarations = /* [] */0;
                    } else {
                      exit$1 = 1;
                    }
                    break;
                case 1 : 
                case 2 : 
                    exit$1 = 1;
                    break;
                
              }
            }
          } else {
            exit$1 = 1;
          }
        } else {
          exit$1 = 1;
        }
        if (exit$1 === 1) {
          baseDeclarations = /* :: */[
            Ast_helper$Jeason.Str[/* value */2](/* None */0, /* Nonrecursive */0, valueBindings),
            /* [] */0
          ];
        }
        return Pervasives.$at(extraDeclarations, baseDeclarations);
    case 3 : 
        return /* :: */[
                Ast_helper$Jeason.Str[/* value */2](/* None */0, /* Nonrecursive */0, /* :: */[
                      /* record */[
                        /* pvb_pat */Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "topPlaceholderMe")),
                        /* pvb_expr */expUnit,
                        /* pvb_attributes : [] */0,
                        /* pvb_loc */Ast_helper$Jeason.default_loc[/* contents */0]
                      ],
                      /* [] */0
                    ]),
                /* [] */0
              ];
    case 4 : 
        return /* :: */[
                Ast_helper$Jeason.Str[/* value */2](/* None */0, /* Nonrecursive */0, /* :: */[
                      parseTreeValueBinding(pexp_desc[2], pexp_desc[3]),
                      /* [] */0
                    ]),
                /* [] */0
              ];
    case 5 : 
        return /* :: */[
                Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* apply */7](/* None */0, /* None */0, pexp_desc[0], pexp_desc[1])),
                /* [] */0
              ];
    case 9 : 
        return /* [] */0;
    case 15 : 
        return /* :: */[
                Ast_helper$Jeason.Str[/* eval */1](/* None */0, /* None */0, Ast_helper$Jeason.Exp[/* ifthenelse */17](/* None */0, /* None */0, pexp_desc[0], pexp_desc[1], pexp_desc[2])),
                /* [] */0
              ];
    case 25 : 
        return /* :: */[
                Ast_helper$Jeason.Str[/* module_ */7](/* None */0, /* record */[
                      /* pmb_name */pexp_desc[0],
                      /* pmb_expr */pexp_desc[1],
                      /* pmb_attributes : [] */0,
                      /* pmb_loc */Ast_helper$Jeason.default_loc[/* contents */0]
                    ]),
                /* [] */0
              ];
    default:
      return /* :: */[
              Ast_helper$Jeason.Str[/* mk */0](/* None */0, /* Pstr_value */Block.__(1, [
                      /* Nonrecursive */0,
                      /* :: */[
                        /* record */[
                          /* pvb_pat */Ast_helper$Jeason.Pat[/* var */3](/* None */0, /* None */0, astHelperStrLidStr(/* None */0, "topPlaceholder")),
                          /* pvb_expr */expUnit,
                          /* pvb_attributes : [] */0,
                          /* pvb_loc */Ast_helper$Jeason.default_loc[/* contents */0]
                        ],
                        /* [] */0
                      ]
                    ])),
              /* [] */0
            ];
  }
}

function cat(filename) {
  var ic = Pervasives.open_in_bin(filename);
  var len = Pervasives.in_channel_length(ic);
  var buf = Buffer.create(len);
  Buffer.add_channel(buf, ic, len);
  var content = Buffer.contents(buf);
  Pervasives.close_in(ic);
  return content;
}

if (Sys.argv.length !== 3) {
  throw [
        Caml_builtin_exceptions.invalid_argument,
        "Please provide as argument the JS file to convert over."
      ];
} else {
  var file = Caml_array.caml_array_get(Sys.argv, 2);
  var content = Fs.readFileSync(file, "utf8");
  var match = Parser_flow$Jeason.program_file(/* Some */[/* false */0], /* None */0, /* Some */[/* Some */[/* record */[
            /* esproposal_class_instance_fields : true */1,
            /* esproposal_class_static_fields : true */1,
            /* esproposal_decorators : true */1,
            /* esproposal_export_star_as : true */1,
            /* types : true */1,
            /* use_strict : false */0
          ]]], content, /* Some */[/* SourceFile */Block.__(1, [file])]);
  Pervasives.output_value(Pervasives.stdout, file);
  var result = List.concat(List.map(topStatementsMapper, match[0][1]));
  Pervasives.output_value(Pervasives.stdout, result);
}

exports.correctIdentifier = correctIdentifier;
exports.objectContainsKeyName = objectContainsKeyName;
exports.astHelperStrLidStr = astHelperStrLidStr;
exports.astHelperStrLidIdent = astHelperStrLidIdent;
exports.expUnit = expUnit;
exports.placeholder = placeholder;
exports.expMarker = expMarker;
exports.parseTreeValueBinding = parseTreeValueBinding;
exports.keepSome = keepSome;
exports.listToListAst = listToListAst;
exports.convertPropTypeType = convertPropTypeType;
exports.propTypesToActualTypes = propTypesToActualTypes;
exports.attemptToGenerateStateRecord = attemptToGenerateStateRecord;
exports.statementBlockMapper = statementBlockMapper;
exports.functionMapper = functionMapper;
exports.literalMapper = literalMapper;
exports.jsxElementMapper = jsxElementMapper;
exports.jsxChildMapper = jsxChildMapper;
exports.objectMapper = objectMapper;
exports.memberMapper = memberMapper;
exports.statementMapper = statementMapper;
exports.expressionMapper = expressionMapper;
exports.topStatementsMapper = topStatementsMapper;
exports.cat = cat;
/* expUnit Not a pure module */
