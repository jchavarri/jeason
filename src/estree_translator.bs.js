// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Loc$Jeason = require("./loc.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Parse_error$Jeason = require("./parse_error.bs.js");

function Translate(Impl) {
  var array_of_list = function (fn, list) {
    return Curry._1(Impl[/* array */3], $$Array.of_list(List.map(fn, list)));
  };
  var option = function (f, param) {
    if (param) {
      return Curry._1(f, param[0]);
    } else {
      return Impl[/* null */5];
    }
  };
  var position = function (p) {
    return Curry._1(Impl[/* obj */2], /* array */[
                /* tuple */[
                  "line",
                  Curry._1(Impl[/* number */4], p[/* line */0])
                ],
                /* tuple */[
                  "column",
                  Curry._1(Impl[/* number */4], p[/* column */1])
                ]
              ]);
  };
  var loc = function ($$location) {
    var match = Loc$Jeason.source($$location);
    var source;
    if (match) {
      var match$1 = match[0];
      source = typeof match$1 === "number" ? Curry._1(Impl[/* string */0], "(global)") : Curry._1(Impl[/* string */0], match$1[0]);
    } else {
      source = Impl[/* null */5];
    }
    return Curry._1(Impl[/* obj */2], /* array */[
                /* tuple */[
                  "source",
                  source
                ],
                /* tuple */[
                  "start",
                  position($$location[/* start */1])
                ],
                /* tuple */[
                  "end",
                  position($$location[/* _end */2])
                ]
              ]);
  };
  var range = function ($$location) {
    return Curry._1(Impl[/* array */3], /* array */[
                Curry._1(Impl[/* number */4], $$location[/* start */1][/* offset */2]),
                Curry._1(Impl[/* number */4], $$location[/* _end */2][/* offset */2])
              ]);
  };
  var node = function (_type, $$location, props) {
    return Curry._1(Impl[/* obj */2], $$Array.append(/* array */[
                    /* tuple */[
                      "type",
                      Curry._1(Impl[/* string */0], _type)
                    ],
                    /* tuple */[
                      "loc",
                      loc($$location)
                    ],
                    /* tuple */[
                      "range",
                      range($$location)
                    ]
                  ], props));
  };
  var errors = function (l) {
    var error = function (param) {
      return Curry._1(Impl[/* obj */2], /* array */[
                  /* tuple */[
                    "loc",
                    loc(param[0])
                  ],
                  /* tuple */[
                    "message",
                    Curry._1(Impl[/* string */0], Parse_error$Jeason.PP[/* error */0](param[1]))
                  ]
                ]);
    };
    return array_of_list(error, l);
  };
  var identifier = function (param) {
    return node("Identifier", param[0], /* array */[
                /* tuple */[
                  "name",
                  Curry._1(Impl[/* string */0], param[1])
                ],
                /* tuple */[
                  "typeAnnotation",
                  Impl[/* null */5]
                ],
                /* tuple */[
                  "optional",
                  Curry._1(Impl[/* bool */1], /* false */0)
                ]
              ]);
  };
  var export_specifier = function (param) {
    var specifier = param[1];
    var match = specifier[/* exported */1];
    var exported = match ? identifier(match[0]) : identifier(specifier[/* local */0]);
    return node("ExportSpecifier", param[0], /* array */[
                /* tuple */[
                  "local",
                  identifier(specifier[/* local */0])
                ],
                /* tuple */[
                  "exported",
                  exported
                ]
              ]);
  };
  var expression = function (param) {
    var match = param[1];
    var loc = param[0];
    if (typeof match === "number") {
      if (match === 0) {
        return node("ThisExpression", loc, /* array */[]);
      } else {
        return node("Super", loc, /* array */[]);
      }
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return node("ArrayExpression", loc, /* array */[/* tuple */[
                          "elements",
                          array_of_list((function (param) {
                                  return option(expression_or_spread, param);
                                }), match[0][/* elements */0])
                        ]]);
        case 1 : 
            return node("ObjectExpression", loc, /* array */[/* tuple */[
                          "properties",
                          array_of_list(object_property, match[0][/* properties */0])
                        ]]);
        case 2 : 
            return function_expression(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 3 : 
            var arrow = match[0];
            var match$1 = arrow[/* body */2];
            var body;
            body = match$1.tag ? expression(match$1[0]) : block(match$1[0]);
            return node("ArrowFunctionExpression", loc, /* array */[
                        /* tuple */[
                          "id",
                          option(identifier, arrow[/* id */0])
                        ],
                        /* tuple */[
                          "params",
                          function_params(arrow[/* params */1])
                        ],
                        /* tuple */[
                          "body",
                          body
                        ],
                        /* tuple */[
                          "async",
                          Curry._1(Impl[/* bool */1], arrow[/* async */3])
                        ],
                        /* tuple */[
                          "generator",
                          Curry._1(Impl[/* bool */1], arrow[/* generator */4])
                        ],
                        /* tuple */[
                          "predicate",
                          option(predicate, arrow[/* predicate */5])
                        ],
                        /* tuple */[
                          "expression",
                          Curry._1(Impl[/* bool */1], arrow[/* expression */6])
                        ],
                        /* tuple */[
                          "returnType",
                          option(type_annotation, arrow[/* returnType */7])
                        ],
                        /* tuple */[
                          "typeParameters",
                          option(type_parameter_declaration, arrow[/* typeParameters */8])
                        ]
                      ]);
        case 4 : 
            return node("SequenceExpression", loc, /* array */[/* tuple */[
                          "expressions",
                          array_of_list(expression, match[0][/* expressions */0])
                        ]]);
        case 5 : 
            var unary = match[0];
            var match$2 = unary[/* operator */0];
            if (match$2 >= 7) {
              return node("AwaitExpression", loc, /* array */[/* tuple */[
                            "argument",
                            expression(unary[/* argument */2])
                          ]]);
            } else {
              var match$3 = unary[/* operator */0];
              var operator;
              switch (match$3) {
                case 0 : 
                    operator = "-";
                    break;
                case 1 : 
                    operator = "+";
                    break;
                case 2 : 
                    operator = "!";
                    break;
                case 3 : 
                    operator = "~";
                    break;
                case 4 : 
                    operator = "typeof";
                    break;
                case 5 : 
                    operator = "void";
                    break;
                case 6 : 
                    operator = "delete";
                    break;
                case 7 : 
                    operator = Pervasives.failwith("matched above");
                    break;
                
              }
              return node("UnaryExpression", loc, /* array */[
                          /* tuple */[
                            "operator",
                            Curry._1(Impl[/* string */0], operator)
                          ],
                          /* tuple */[
                            "prefix",
                            Curry._1(Impl[/* bool */1], unary[/* prefix */1])
                          ],
                          /* tuple */[
                            "argument",
                            expression(unary[/* argument */2])
                          ]
                        ]);
            }
        case 6 : 
            var binary = match[0];
            var match$4 = binary[/* operator */0];
            var operator$1;
            switch (match$4) {
              case 0 : 
                  operator$1 = "==";
                  break;
              case 1 : 
                  operator$1 = "!=";
                  break;
              case 2 : 
                  operator$1 = "===";
                  break;
              case 3 : 
                  operator$1 = "!==";
                  break;
              case 4 : 
                  operator$1 = "<";
                  break;
              case 5 : 
                  operator$1 = "<=";
                  break;
              case 6 : 
                  operator$1 = ">";
                  break;
              case 7 : 
                  operator$1 = ">=";
                  break;
              case 8 : 
                  operator$1 = "<<";
                  break;
              case 9 : 
                  operator$1 = ">>";
                  break;
              case 10 : 
                  operator$1 = ">>>";
                  break;
              case 11 : 
                  operator$1 = "+";
                  break;
              case 12 : 
                  operator$1 = "-";
                  break;
              case 13 : 
                  operator$1 = "*";
                  break;
              case 14 : 
                  operator$1 = "**";
                  break;
              case 15 : 
                  operator$1 = "/";
                  break;
              case 16 : 
                  operator$1 = "%";
                  break;
              case 17 : 
                  operator$1 = "|";
                  break;
              case 18 : 
                  operator$1 = "^";
                  break;
              case 19 : 
                  operator$1 = "&";
                  break;
              case 20 : 
                  operator$1 = "in";
                  break;
              case 21 : 
                  operator$1 = "instanceof";
                  break;
              
            }
            return node("BinaryExpression", loc, /* array */[
                        /* tuple */[
                          "operator",
                          Curry._1(Impl[/* string */0], operator$1)
                        ],
                        /* tuple */[
                          "left",
                          expression(binary[/* left */1])
                        ],
                        /* tuple */[
                          "right",
                          expression(binary[/* right */2])
                        ]
                      ]);
        case 7 : 
            var assignment = match[0];
            var match$5 = assignment[/* operator */0];
            var operator$2;
            switch (match$5) {
              case 0 : 
                  operator$2 = "=";
                  break;
              case 1 : 
                  operator$2 = "+=";
                  break;
              case 2 : 
                  operator$2 = "-=";
                  break;
              case 3 : 
                  operator$2 = "*=";
                  break;
              case 4 : 
                  operator$2 = "**=";
                  break;
              case 5 : 
                  operator$2 = "/=";
                  break;
              case 6 : 
                  operator$2 = "%=";
                  break;
              case 7 : 
                  operator$2 = "<<=";
                  break;
              case 8 : 
                  operator$2 = ">>=";
                  break;
              case 9 : 
                  operator$2 = ">>>=";
                  break;
              case 10 : 
                  operator$2 = "|=";
                  break;
              case 11 : 
                  operator$2 = "^=";
                  break;
              case 12 : 
                  operator$2 = "&=";
                  break;
              
            }
            return node("AssignmentExpression", loc, /* array */[
                        /* tuple */[
                          "operator",
                          Curry._1(Impl[/* string */0], operator$2)
                        ],
                        /* tuple */[
                          "left",
                          pattern(assignment[/* left */1])
                        ],
                        /* tuple */[
                          "right",
                          expression(assignment[/* right */2])
                        ]
                      ]);
        case 8 : 
            var update = match[0];
            var match$6 = update[/* operator */0];
            var operator$3 = match$6 !== 0 ? "--" : "++";
            return node("UpdateExpression", loc, /* array */[
                        /* tuple */[
                          "operator",
                          Curry._1(Impl[/* string */0], operator$3)
                        ],
                        /* tuple */[
                          "argument",
                          expression(update[/* argument */1])
                        ],
                        /* tuple */[
                          "prefix",
                          Curry._1(Impl[/* bool */1], update[/* prefix */2])
                        ]
                      ]);
        case 9 : 
            var logical = match[0];
            var match$7 = logical[/* operator */0];
            var operator$4 = match$7 !== 0 ? "&&" : "||";
            return node("LogicalExpression", loc, /* array */[
                        /* tuple */[
                          "operator",
                          Curry._1(Impl[/* string */0], operator$4)
                        ],
                        /* tuple */[
                          "left",
                          expression(logical[/* left */1])
                        ],
                        /* tuple */[
                          "right",
                          expression(logical[/* right */2])
                        ]
                      ]);
        case 10 : 
            var conditional = match[0];
            return node("ConditionalExpression", loc, /* array */[
                        /* tuple */[
                          "test",
                          expression(conditional[/* test */0])
                        ],
                        /* tuple */[
                          "consequent",
                          expression(conditional[/* consequent */1])
                        ],
                        /* tuple */[
                          "alternate",
                          expression(conditional[/* alternate */2])
                        ]
                      ]);
        case 11 : 
            var _new = match[0];
            return node("NewExpression", loc, /* array */[
                        /* tuple */[
                          "callee",
                          expression(_new[/* callee */0])
                        ],
                        /* tuple */[
                          "arguments",
                          array_of_list(expression_or_spread, _new[/* arguments */1])
                        ]
                      ]);
        case 12 : 
            var call = match[0];
            return node("CallExpression", loc, /* array */[
                        /* tuple */[
                          "callee",
                          expression(call[/* callee */0])
                        ],
                        /* tuple */[
                          "arguments",
                          array_of_list(expression_or_spread, call[/* arguments */1])
                        ]
                      ]);
        case 13 : 
            var member = match[0];
            var match$8 = member[/* property */1];
            var property;
            property = match$8.tag ? expression(match$8[0]) : identifier(match$8[0]);
            return node("MemberExpression", loc, /* array */[
                        /* tuple */[
                          "object",
                          expression(member[/* _object */0])
                        ],
                        /* tuple */[
                          "property",
                          property
                        ],
                        /* tuple */[
                          "computed",
                          Curry._1(Impl[/* bool */1], member[/* computed */2])
                        ]
                      ]);
        case 14 : 
            var $$yield = match[0];
            return node("YieldExpression", loc, /* array */[
                        /* tuple */[
                          "argument",
                          option(expression, $$yield[/* argument */0])
                        ],
                        /* tuple */[
                          "delegate",
                          Curry._1(Impl[/* bool */1], $$yield[/* delegate */1])
                        ]
                      ]);
        case 15 : 
            var comp = match[0];
            return node("ComprehensionExpression", loc, /* array */[
                        /* tuple */[
                          "blocks",
                          array_of_list(comprehension_block, comp[/* blocks */0])
                        ],
                        /* tuple */[
                          "filter",
                          option(expression, comp[/* filter */1])
                        ]
                      ]);
        case 16 : 
            var gen = match[0];
            return node("GeneratorExpression", loc, /* array */[
                        /* tuple */[
                          "blocks",
                          array_of_list(comprehension_block, gen[/* blocks */0])
                        ],
                        /* tuple */[
                          "filter",
                          option(expression, gen[/* filter */1])
                        ]
                      ]);
        case 17 : 
            return identifier(match[0]);
        case 18 : 
            return literal(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 19 : 
            return template_literal(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 20 : 
            var param$1 = /* tuple */[
              loc,
              match[0]
            ];
            var tagged = param$1[1];
            return node("TaggedTemplateExpression", param$1[0], /* array */[
                        /* tuple */[
                          "tag",
                          expression(tagged[/* tag */0])
                        ],
                        /* tuple */[
                          "quasi",
                          template_literal(tagged[/* quasi */1])
                        ]
                      ]);
        case 21 : 
            return jsx_element(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 22 : 
            var param$2 = /* tuple */[
              loc,
              match[0]
            ];
            var c = param$2[1];
            return node("ClassExpression", param$2[0], /* array */[
                        /* tuple */[
                          "id",
                          option(identifier, c[/* id */0])
                        ],
                        /* tuple */[
                          "body",
                          class_body(c[/* body */1])
                        ],
                        /* tuple */[
                          "superClass",
                          option(expression, c[/* superClass */2])
                        ],
                        /* tuple */[
                          "typeParameters",
                          option(type_parameter_declaration, c[/* typeParameters */3])
                        ],
                        /* tuple */[
                          "superTypeParameters",
                          option(type_parameter_instantiation, c[/* superTypeParameters */4])
                        ],
                        /* tuple */[
                          "implements",
                          array_of_list(class_implements, c[/* implements */5])
                        ],
                        /* tuple */[
                          "decorators",
                          array_of_list(expression, c[/* classDecorators */6])
                        ]
                      ]);
        case 23 : 
            var typecast = match[0];
            return node("TypeCastExpression", loc, /* array */[
                        /* tuple */[
                          "expression",
                          expression(typecast[/* expression */0])
                        ],
                        /* tuple */[
                          "typeAnnotation",
                          type_annotation(typecast[/* typeAnnotation */1])
                        ]
                      ]);
        case 24 : 
            var meta_prop = match[0];
            return node("MetaProperty", loc, /* array */[
                        /* tuple */[
                          "meta",
                          identifier(meta_prop[/* meta */0])
                        ],
                        /* tuple */[
                          "property",
                          identifier(meta_prop[/* property */1])
                        ]
                      ]);
        
      }
    }
  };
  var literal = function (param) {
    var lit = param[1];
    var raw = lit[/* raw */1];
    var value = lit[/* value */0];
    var loc = param[0];
    var value_;
    if (typeof value === "number") {
      value_ = Impl[/* null */5];
    } else {
      switch (value.tag | 0) {
        case 0 : 
            value_ = Curry._1(Impl[/* string */0], value[0]);
            break;
        case 1 : 
            value_ = Curry._1(Impl[/* bool */1], value[0]);
            break;
        case 2 : 
            value_ = Curry._1(Impl[/* number */4], value[0]);
            break;
        case 3 : 
            var match = value[0];
            value_ = Curry._3(Impl[/* regexp */6], loc, match[/* pattern */0], match[/* flags */1]);
            break;
        
      }
    }
    var props;
    var exit = 0;
    if (typeof value === "number" || value.tag !== 3) {
      exit = 1;
    } else {
      var match$1 = value[0];
      var regex = Curry._1(Impl[/* obj */2], /* array */[
            /* tuple */[
              "pattern",
              Curry._1(Impl[/* string */0], match$1[/* pattern */0])
            ],
            /* tuple */[
              "flags",
              Curry._1(Impl[/* string */0], match$1[/* flags */1])
            ]
          ]);
      props = /* array */[
        /* tuple */[
          "value",
          value_
        ],
        /* tuple */[
          "raw",
          Curry._1(Impl[/* string */0], raw)
        ],
        /* tuple */[
          "regex",
          regex
        ]
      ];
    }
    if (exit === 1) {
      props = /* array */[
        /* tuple */[
          "value",
          value_
        ],
        /* tuple */[
          "raw",
          Curry._1(Impl[/* string */0], raw)
        ]
      ];
    }
    return node("Literal", loc, props);
  };
  var variable_declarator = function (param) {
    var declarator = param[1];
    return node("VariableDeclarator", param[0], /* array */[
                /* tuple */[
                  "id",
                  pattern(declarator[/* id */0])
                ],
                /* tuple */[
                  "init",
                  option(expression, declarator[/* init */1])
                ]
              ]);
  };
  var function_type_param = function (param) {
    var param$1 = param[1];
    return node("FunctionTypeParam", param[0], /* array */[
                /* tuple */[
                  "name",
                  option(identifier, param$1[/* name */0])
                ],
                /* tuple */[
                  "typeAnnotation",
                  _type(param$1[/* typeAnnotation */1])
                ],
                /* tuple */[
                  "optional",
                  Curry._1(Impl[/* bool */1], param$1[/* optional */2])
                ]
              ]);
  };
  var type_parameter_declaration = function (param) {
    return node("TypeParameterDeclaration", param[0], /* array */[/* tuple */[
                  "params",
                  array_of_list(type_param, param[1][/* params */0])
                ]]);
  };
  var function_type_rest = function (param) {
    return function_type_param(param[1][/* argument */0]);
  };
  var _type = function (param) {
    var t = param[1];
    var loc = param[0];
    if (typeof t === "number") {
      switch (t) {
        case 0 : 
            return node("AnyTypeAnnotation", loc, /* array */[]);
        case 1 : 
            return node("MixedTypeAnnotation", loc, /* array */[]);
        case 2 : 
            return node("EmptyTypeAnnotation", loc, /* array */[]);
        case 3 : 
            return node("VoidTypeAnnotation", loc, /* array */[]);
        case 4 : 
            return node("NullLiteralTypeAnnotation", loc, /* array */[]);
        case 5 : 
            return node("NumberTypeAnnotation", loc, /* array */[]);
        case 6 : 
            return node("StringTypeAnnotation", loc, /* array */[]);
        case 7 : 
            return node("BooleanTypeAnnotation", loc, /* array */[]);
        case 8 : 
            return node("ExistsTypeAnnotation", loc, /* array */[]);
        
      }
    } else {
      switch (t.tag | 0) {
        case 0 : 
            var loc$1 = loc;
            var t$1 = t[0];
            return node("NullableTypeAnnotation", loc$1, /* array */[/* tuple */[
                          "typeAnnotation",
                          _type(t$1)
                        ]]);
        case 1 : 
            return function_type(/* tuple */[
                        loc,
                        t[0]
                      ]);
        case 2 : 
            return object_type(/* tuple */[
                        loc,
                        t[0]
                      ]);
        case 3 : 
            var loc$2 = loc;
            var t$2 = t[0];
            return node("ArrayTypeAnnotation", loc$2, /* array */[/* tuple */[
                          "elementType",
                          _type(t$2)
                        ]]);
        case 4 : 
            var param$1 = /* tuple */[
              loc,
              t[0]
            ];
            var g = param$1[1];
            var match = g[/* id */0];
            var id;
            id = match.tag ? generic_type_qualified_identifier(match[0]) : identifier(match[0]);
            return node("GenericTypeAnnotation", param$1[0], /* array */[
                        /* tuple */[
                          "id",
                          id
                        ],
                        /* tuple */[
                          "typeParameters",
                          option(type_parameter_instantiation, g[/* typeParameters */1])
                        ]
                      ]);
        case 5 : 
            var param$2 = /* tuple */[
              loc,
              /* :: */[
                t[0],
                /* :: */[
                  t[1],
                  t[2]
                ]
              ]
            ];
            return node("UnionTypeAnnotation", param$2[0], /* array */[/* tuple */[
                          "types",
                          array_of_list(_type, param$2[1])
                        ]]);
        case 6 : 
            var param$3 = /* tuple */[
              loc,
              /* :: */[
                t[0],
                /* :: */[
                  t[1],
                  t[2]
                ]
              ]
            ];
            return node("IntersectionTypeAnnotation", param$3[0], /* array */[/* tuple */[
                          "types",
                          array_of_list(_type, param$3[1])
                        ]]);
        case 7 : 
            var param$4 = /* tuple */[
              loc,
              t[0]
            ];
            return node("TypeofTypeAnnotation", param$4[0], /* array */[/* tuple */[
                          "argument",
                          _type(param$4[1])
                        ]]);
        case 8 : 
            var param$5 = /* tuple */[
              loc,
              t[0]
            ];
            return node("TupleTypeAnnotation", param$5[0], /* array */[/* tuple */[
                          "types",
                          array_of_list(_type, param$5[1])
                        ]]);
        case 9 : 
            var param$6 = /* tuple */[
              loc,
              t[0]
            ];
            var s = param$6[1];
            return node("StringLiteralTypeAnnotation", param$6[0], /* array */[
                        /* tuple */[
                          "value",
                          Curry._1(Impl[/* string */0], s[/* value */0])
                        ],
                        /* tuple */[
                          "raw",
                          Curry._1(Impl[/* string */0], s[/* raw */1])
                        ]
                      ]);
        case 10 : 
            var param$7 = /* tuple */[
              loc,
              t[0]
            ];
            var s$1 = param$7[1];
            return node("NumberLiteralTypeAnnotation", param$7[0], /* array */[
                        /* tuple */[
                          "value",
                          Curry._1(Impl[/* number */4], s$1[/* value */0])
                        ],
                        /* tuple */[
                          "raw",
                          Curry._1(Impl[/* string */0], s$1[/* raw */1])
                        ]
                      ]);
        case 11 : 
            var param$8 = /* tuple */[
              loc,
              t[0]
            ];
            var s$2 = param$8[1];
            return node("BooleanLiteralTypeAnnotation", param$8[0], /* array */[
                        /* tuple */[
                          "value",
                          Curry._1(Impl[/* bool */1], s$2[/* value */0])
                        ],
                        /* tuple */[
                          "raw",
                          Curry._1(Impl[/* string */0], s$2[/* raw */1])
                        ]
                      ]);
        
      }
    }
  };
  var type_annotation = function (param) {
    return node("TypeAnnotation", param[0], /* array */[/* tuple */[
                  "typeAnnotation",
                  _type(param[1])
                ]]);
  };
  var variance = function (param) {
    if (param[1] !== 0) {
      return Curry._1(Impl[/* string */0], "minus");
    } else {
      return Curry._1(Impl[/* string */0], "plus");
    }
  };
  var statement = function (param) {
    var match = param[1];
    var loc = param[0];
    if (typeof match === "number") {
      if (match === 0) {
        return node("EmptyStatement", loc, /* array */[]);
      } else {
        return node("DebuggerStatement", loc, /* array */[]);
      }
    } else {
      switch (match.tag | 0) {
        case 0 : 
            return block(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 1 : 
            return node("ExpressionStatement", loc, /* array */[/* tuple */[
                          "expression",
                          expression(match[0][/* expression */0])
                        ]]);
        case 2 : 
            var _if = match[0];
            return node("IfStatement", loc, /* array */[
                        /* tuple */[
                          "test",
                          expression(_if[/* test */0])
                        ],
                        /* tuple */[
                          "consequent",
                          statement(_if[/* consequent */1])
                        ],
                        /* tuple */[
                          "alternate",
                          option(statement, _if[/* alternate */2])
                        ]
                      ]);
        case 3 : 
            var labeled = match[0];
            return node("LabeledStatement", loc, /* array */[
                        /* tuple */[
                          "label",
                          identifier(labeled[/* label */0])
                        ],
                        /* tuple */[
                          "body",
                          statement(labeled[/* body */1])
                        ]
                      ]);
        case 4 : 
            return node("BreakStatement", loc, /* array */[/* tuple */[
                          "label",
                          option(identifier, match[0][/* label */0])
                        ]]);
        case 5 : 
            return node("ContinueStatement", loc, /* array */[/* tuple */[
                          "label",
                          option(identifier, match[0][/* label */0])
                        ]]);
        case 6 : 
            var _with = match[0];
            return node("WithStatement", loc, /* array */[
                        /* tuple */[
                          "object",
                          expression(_with[/* _object */0])
                        ],
                        /* tuple */[
                          "body",
                          statement(_with[/* body */1])
                        ]
                      ]);
        case 7 : 
            return type_alias(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 8 : 
            var $$switch = match[0];
            return node("SwitchStatement", loc, /* array */[
                        /* tuple */[
                          "discriminant",
                          expression($$switch[/* discriminant */0])
                        ],
                        /* tuple */[
                          "cases",
                          array_of_list($$case, $$switch[/* cases */1])
                        ]
                      ]);
        case 9 : 
            return node("ReturnStatement", loc, /* array */[/* tuple */[
                          "argument",
                          option(expression, match[0][/* argument */0])
                        ]]);
        case 10 : 
            return node("ThrowStatement", loc, /* array */[/* tuple */[
                          "argument",
                          expression(match[0][/* argument */0])
                        ]]);
        case 11 : 
            var _try = match[0];
            return node("TryStatement", loc, /* array */[
                        /* tuple */[
                          "block",
                          block(_try[/* block */0])
                        ],
                        /* tuple */[
                          "handler",
                          option($$catch, _try[/* handler */1])
                        ],
                        /* tuple */[
                          "finalizer",
                          option(block, _try[/* finalizer */2])
                        ]
                      ]);
        case 12 : 
            var _while = match[0];
            return node("WhileStatement", loc, /* array */[
                        /* tuple */[
                          "test",
                          expression(_while[/* test */0])
                        ],
                        /* tuple */[
                          "body",
                          statement(_while[/* body */1])
                        ]
                      ]);
        case 13 : 
            var dowhile = match[0];
            return node("DoWhileStatement", loc, /* array */[
                        /* tuple */[
                          "body",
                          statement(dowhile[/* body */0])
                        ],
                        /* tuple */[
                          "test",
                          expression(dowhile[/* test */1])
                        ]
                      ]);
        case 14 : 
            var _for = match[0];
            var init = function (param) {
              if (param.tag) {
                return expression(param[0]);
              } else {
                return variable_declaration(param[0]);
              }
            };
            return node("ForStatement", loc, /* array */[
                        /* tuple */[
                          "init",
                          option(init, _for[/* init */0])
                        ],
                        /* tuple */[
                          "test",
                          option(expression, _for[/* test */1])
                        ],
                        /* tuple */[
                          "update",
                          option(expression, _for[/* update */2])
                        ],
                        /* tuple */[
                          "body",
                          statement(_for[/* body */3])
                        ]
                      ]);
        case 15 : 
            var forin = match[0];
            var match$1 = forin[/* left */0];
            var left;
            left = match$1.tag ? expression(match$1[0]) : variable_declaration(match$1[0]);
            return node("ForInStatement", loc, /* array */[
                        /* tuple */[
                          "left",
                          left
                        ],
                        /* tuple */[
                          "right",
                          expression(forin[/* right */1])
                        ],
                        /* tuple */[
                          "body",
                          statement(forin[/* body */2])
                        ],
                        /* tuple */[
                          "each",
                          Curry._1(Impl[/* bool */1], forin[/* each */3])
                        ]
                      ]);
        case 16 : 
            var forof = match[0];
            var type_ = forof[/* async */3] ? "ForAwaitStatement" : "ForOfStatement";
            var match$2 = forof[/* left */0];
            var left$1;
            left$1 = match$2.tag ? expression(match$2[0]) : variable_declaration(match$2[0]);
            return node(type_, loc, /* array */[
                        /* tuple */[
                          "left",
                          left$1
                        ],
                        /* tuple */[
                          "right",
                          expression(forof[/* right */1])
                        ],
                        /* tuple */[
                          "body",
                          statement(forof[/* body */2])
                        ]
                      ]);
        case 17 : 
            var param$1 = /* tuple */[
              loc,
              match[0]
            ];
            var fn = param$1[1];
            var match$3 = fn[/* body */2];
            var body;
            body = match$3.tag ? expression(match$3[0]) : block(match$3[0]);
            return node("FunctionDeclaration", param$1[0], /* array */[
                        /* tuple */[
                          "id",
                          option(identifier, fn[/* id */0])
                        ],
                        /* tuple */[
                          "params",
                          function_params(fn[/* params */1])
                        ],
                        /* tuple */[
                          "body",
                          body
                        ],
                        /* tuple */[
                          "async",
                          Curry._1(Impl[/* bool */1], fn[/* async */3])
                        ],
                        /* tuple */[
                          "generator",
                          Curry._1(Impl[/* bool */1], fn[/* generator */4])
                        ],
                        /* tuple */[
                          "predicate",
                          option(predicate, fn[/* predicate */5])
                        ],
                        /* tuple */[
                          "expression",
                          Curry._1(Impl[/* bool */1], fn[/* expression */6])
                        ],
                        /* tuple */[
                          "returnType",
                          option(type_annotation, fn[/* returnType */7])
                        ],
                        /* tuple */[
                          "typeParameters",
                          option(type_parameter_declaration, fn[/* typeParameters */8])
                        ]
                      ]);
        case 18 : 
            return variable_declaration(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 19 : 
            var param$2 = /* tuple */[
              loc,
              match[0]
            ];
            var c = param$2[1];
            return node("ClassDeclaration", param$2[0], /* array */[
                        /* tuple */[
                          "id",
                          option(identifier, c[/* id */0])
                        ],
                        /* tuple */[
                          "body",
                          class_body(c[/* body */1])
                        ],
                        /* tuple */[
                          "superClass",
                          option(expression, c[/* superClass */2])
                        ],
                        /* tuple */[
                          "typeParameters",
                          option(type_parameter_declaration, c[/* typeParameters */3])
                        ],
                        /* tuple */[
                          "superTypeParameters",
                          option(type_parameter_instantiation, c[/* superTypeParameters */4])
                        ],
                        /* tuple */[
                          "implements",
                          array_of_list(class_implements, c[/* implements */5])
                        ],
                        /* tuple */[
                          "decorators",
                          array_of_list(expression, c[/* classDecorators */6])
                        ]
                      ]);
        case 20 : 
            return interface_declaration(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 21 : 
            return declare_variable(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 22 : 
            return declare_function(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 23 : 
            return declare_class(/* tuple */[
                        loc,
                        match[0]
                      ]);
        case 24 : 
            var m = match[0];
            var match$4 = m[/* id */0];
            var id;
            id = match$4.tag ? literal(match$4[0]) : identifier(match$4[0]);
            var match$5 = m[/* kind */2];
            var tmp;
            tmp = match$5.tag ? Curry._1(Impl[/* string */0], "ES") : Curry._1(Impl[/* string */0], "CommonJS");
            return node("DeclareModule", loc, /* array */[
                        /* tuple */[
                          "id",
                          id
                        ],
                        /* tuple */[
                          "body",
                          block(m[/* body */1])
                        ],
                        /* tuple */[
                          "kind",
                          tmp
                        ]
                      ]);
        case 25 : 
            return node("DeclareModuleExports", loc, /* array */[/* tuple */[
                          "typeAnnotation",
                          type_annotation(match[0])
                        ]]);
        case 26 : 
            var $$export = match[0];
            var match$6 = $$export[/* specifiers */2];
            var exit = 0;
            if (match$6) {
              var match$7 = match$6[0];
              if (match$7.tag && !match$7[1]) {
                return node("DeclareExportAllDeclaration", loc, /* array */[/* tuple */[
                              "source",
                              option(literal, $$export[/* source */3])
                            ]]);
              } else {
                exit = 1;
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              var match$8 = $$export[/* declaration */1];
              var declaration;
              if (match$8) {
                var match$9 = match$8[0];
                switch (match$9.tag | 0) {
                  case 0 : 
                      declaration = declare_variable(match$9[0]);
                      break;
                  case 1 : 
                      declaration = declare_function(match$9[0]);
                      break;
                  case 2 : 
                      declaration = declare_class(match$9[0]);
                      break;
                  case 3 : 
                      declaration = _type(match$9[0]);
                      break;
                  case 4 : 
                      declaration = type_alias(match$9[0]);
                      break;
                  case 5 : 
                      declaration = interface_declaration(match$9[0]);
                      break;
                  
                }
              } else {
                declaration = Impl[/* null */5];
              }
              return node("DeclareExportDeclaration", loc, /* array */[
                          /* tuple */[
                            "default",
                            Curry._1(Impl[/* bool */1], $$export[/* default */0])
                          ],
                          /* tuple */[
                            "declaration",
                            declaration
                          ],
                          /* tuple */[
                            "specifiers",
                            export_specifiers($$export[/* specifiers */2])
                          ],
                          /* tuple */[
                            "source",
                            option(literal, $$export[/* source */3])
                          ]
                        ]);
            }
            break;
        case 27 : 
            var $$export$1 = match[0];
            var match$10 = $$export$1[/* specifiers */1];
            var exit$1 = 0;
            if (match$10) {
              var match$11 = match$10[0];
              if (match$11.tag && !match$11[1]) {
                return node("ExportAllDeclaration", loc, /* array */[
                            /* tuple */[
                              "source",
                              option(literal, $$export$1[/* source */2])
                            ],
                            /* tuple */[
                              "exportKind",
                              Curry._1(Impl[/* string */0], export_kind($$export$1[/* exportKind */3]))
                            ]
                          ]);
              } else {
                exit$1 = 1;
              }
            } else {
              exit$1 = 1;
            }
            if (exit$1 === 1) {
              return node("ExportNamedDeclaration", loc, /* array */[
                          /* tuple */[
                            "declaration",
                            option(statement, $$export$1[/* declaration */0])
                          ],
                          /* tuple */[
                            "specifiers",
                            export_specifiers($$export$1[/* specifiers */1])
                          ],
                          /* tuple */[
                            "source",
                            option(literal, $$export$1[/* source */2])
                          ],
                          /* tuple */[
                            "exportKind",
                            Curry._1(Impl[/* string */0], export_kind($$export$1[/* exportKind */3]))
                          ]
                        ]);
            }
            break;
        case 28 : 
            var $$export$2 = match[0];
            var match$12 = $$export$2[/* declaration */0];
            var declaration$1;
            declaration$1 = match$12.tag ? expression(match$12[0]) : statement(match$12[0]);
            return node("ExportDefaultDeclaration", loc, /* array */[
                        /* tuple */[
                          "declaration",
                          declaration$1
                        ],
                        /* tuple */[
                          "exportKind",
                          Curry._1(Impl[/* string */0], export_kind($$export$2[/* exportKind */1]))
                        ]
                      ]);
        case 29 : 
            var $$import = match[0];
            var specifiers = List.map((function (param) {
                    switch (param.tag | 0) {
                      case 0 : 
                          var match = param[0];
                          var local_id = match[/* local */0];
                          var remote_id = match[/* remote */1];
                          var span_loc = local_id ? Loc$Jeason.btwn(remote_id[0], local_id[0][0]) : remote_id[0];
                          var local_id$1 = local_id ? local_id[0] : remote_id;
                          return node("ImportSpecifier", span_loc, /* array */[
                                      /* tuple */[
                                        "imported",
                                        identifier(remote_id)
                                      ],
                                      /* tuple */[
                                        "local",
                                        identifier(local_id$1)
                                      ]
                                    ]);
                      case 1 : 
                          var id = param[0];
                          return node("ImportDefaultSpecifier", id[0], /* array */[/* tuple */[
                                        "local",
                                        identifier(id)
                                      ]]);
                      case 2 : 
                          var param$1 = param[0];
                          return node("ImportNamespaceSpecifier", param$1[0], /* array */[/* tuple */[
                                        "local",
                                        identifier(param$1[1])
                                      ]]);
                      
                    }
                  }), $$import[/* specifiers */2]);
            var match$13 = $$import[/* importKind */0];
            var import_kind;
            switch (match$13) {
              case 0 : 
                  import_kind = "type";
                  break;
              case 1 : 
                  import_kind = "typeof";
                  break;
              case 2 : 
                  import_kind = "value";
                  break;
              
            }
            return node("ImportDeclaration", loc, /* array */[
                        /* tuple */[
                          "specifiers",
                          Curry._1(Impl[/* array */3], $$Array.of_list(specifiers))
                        ],
                        /* tuple */[
                          "source",
                          literal($$import[/* source */1])
                        ],
                        /* tuple */[
                          "importKind",
                          Curry._1(Impl[/* string */0], import_kind)
                        ]
                      ]);
        
      }
    }
  };
  var jsx_member_expression = function (param) {
    var member_expression = param[1];
    var match = member_expression[/* _object */0];
    var _object;
    _object = match.tag ? jsx_member_expression(match[0]) : jsx_identifier(match[0]);
    return node("JSXMemberExpression", param[0], /* array */[
                /* tuple */[
                  "object",
                  _object
                ],
                /* tuple */[
                  "property",
                  jsx_identifier(member_expression[/* property */1])
                ]
              ]);
  };
  var jsx_namespaced_name = function (param) {
    var namespaced_name = param[1];
    return node("JSXNamespacedName", param[0], /* array */[
                /* tuple */[
                  "namespace",
                  jsx_identifier(namespaced_name[/* namespace */0])
                ],
                /* tuple */[
                  "name",
                  jsx_identifier(namespaced_name[/* name */1])
                ]
              ]);
  };
  var jsx_identifier = function (param) {
    return node("JSXIdentifier", param[0], /* array */[/* tuple */[
                  "name",
                  Curry._1(Impl[/* string */0], param[1][/* name */0])
                ]]);
  };
  var jsx_name = function (param) {
    switch (param.tag | 0) {
      case 0 : 
          return jsx_identifier(param[0]);
      case 1 : 
          return jsx_namespaced_name(param[0]);
      case 2 : 
          return jsx_member_expression(param[0]);
      
    }
  };
  var jsx_opening_attribute = function (param) {
    if (param.tag) {
      var param$1 = param[0];
      return node("JSXSpreadAttribute", param$1[0], /* array */[/* tuple */[
                    "argument",
                    expression(param$1[1][/* argument */0])
                  ]]);
    } else {
      var param$2 = param[0];
      var attribute = param$2[1];
      var match = attribute[/* name */0];
      var name;
      name = match.tag ? jsx_namespaced_name(match[0]) : jsx_identifier(match[0]);
      return node("JSXAttribute", param$2[0], /* array */[
                  /* tuple */[
                    "name",
                    name
                  ],
                  /* tuple */[
                    "value",
                    option(jsx_attribute_value, attribute[/* value */1])
                  ]
                ]);
    }
  };
  var type_parameter_instantiation = function (param) {
    return node("TypeParameterInstantiation", param[0], /* array */[/* tuple */[
                  "params",
                  array_of_list(_type, param[1][/* params */0])
                ]]);
  };
  var generic_type_qualified_identifier = function (param) {
    var q = param[1];
    var match = q[/* qualification */0];
    var qualification;
    qualification = match.tag ? generic_type_qualified_identifier(match[0]) : identifier(match[0]);
    return node("QualifiedTypeIdentifier", param[0], /* array */[
                /* tuple */[
                  "qualification",
                  qualification
                ],
                /* tuple */[
                  "id",
                  identifier(q[/* id */1])
                ]
              ]);
  };
  var class_body = function (param) {
    return node("ClassBody", param[0], /* array */[/* tuple */[
                  "body",
                  array_of_list(class_element, param[1][/* body */0])
                ]]);
  };
  var class_implements = function (param) {
    var $$implements = param[1];
    return node("ClassImplements", param[0], /* array */[
                /* tuple */[
                  "id",
                  identifier($$implements[/* id */0])
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_instantiation, $$implements[/* typeParameters */1])
                ]
              ]);
  };
  var object_pattern_property = function (param) {
    if (param.tag) {
      var match = param[0];
      return node("RestProperty", match[0], /* array */[/* tuple */[
                    "argument",
                    pattern(match[1][/* argument */0])
                  ]]);
    } else {
      var match$1 = param[0];
      var prop = match$1[1];
      var match$2 = prop[/* key */0];
      var match$3;
      switch (match$2.tag | 0) {
        case 0 : 
            match$3 = /* tuple */[
              literal(match$2[0]),
              /* false */0
            ];
            break;
        case 1 : 
            match$3 = /* tuple */[
              identifier(match$2[0]),
              /* false */0
            ];
            break;
        case 2 : 
            match$3 = /* tuple */[
              expression(match$2[0]),
              /* true */1
            ];
            break;
        
      }
      return node("Property", match$1[0], /* array */[
                  /* tuple */[
                    "key",
                    match$3[0]
                  ],
                  /* tuple */[
                    "value",
                    pattern(prop[/* pattern */1])
                  ],
                  /* tuple */[
                    "kind",
                    Curry._1(Impl[/* string */0], "init")
                  ],
                  /* tuple */[
                    "method",
                    Curry._1(Impl[/* bool */1], /* false */0)
                  ],
                  /* tuple */[
                    "shorthand",
                    Curry._1(Impl[/* bool */1], prop[/* shorthand */2])
                  ],
                  /* tuple */[
                    "computed",
                    Curry._1(Impl[/* bool */1], match$3[1])
                  ]
                ]);
    }
  };
  var array_pattern_element = function (param) {
    if (param.tag) {
      var match = param[0];
      return node("RestElement", match[0], /* array */[/* tuple */[
                    "argument",
                    pattern(match[1][/* argument */0])
                  ]]);
    } else {
      return pattern(param[0]);
    }
  };
  var pattern = function (param) {
    var match = param[1];
    var loc = param[0];
    switch (match.tag | 0) {
      case 0 : 
          var obj = match[0];
          return node("ObjectPattern", loc, /* array */[
                      /* tuple */[
                        "properties",
                        array_of_list(object_pattern_property, obj[/* properties */0])
                      ],
                      /* tuple */[
                        "typeAnnotation",
                        option(type_annotation, obj[/* typeAnnotation */1])
                      ]
                    ]);
      case 1 : 
          var arr = match[0];
          return node("ArrayPattern", loc, /* array */[
                      /* tuple */[
                        "elements",
                        array_of_list((function (param) {
                                return option(array_pattern_element, param);
                              }), arr[/* elements */0])
                      ],
                      /* tuple */[
                        "typeAnnotation",
                        option(type_annotation, arr[/* typeAnnotation */1])
                      ]
                    ]);
      case 2 : 
          var match$1 = match[0];
          return node("AssignmentPattern", loc, /* array */[
                      /* tuple */[
                        "left",
                        pattern(match$1[/* left */0])
                      ],
                      /* tuple */[
                        "right",
                        expression(match$1[/* right */1])
                      ]
                    ]);
      case 3 : 
          return pattern_identifier(loc, match[0]);
      case 4 : 
          return expression(match[0]);
      
    }
  };
  var pattern_identifier = function (loc, param) {
    return node("Identifier", loc, /* array */[
                /* tuple */[
                  "name",
                  Curry._1(Impl[/* string */0], param[/* name */0][1])
                ],
                /* tuple */[
                  "typeAnnotation",
                  option(type_annotation, param[/* typeAnnotation */1])
                ],
                /* tuple */[
                  "optional",
                  Curry._1(Impl[/* bool */1], param[/* optional */2])
                ]
              ]);
  };
  var object_type_property = function (param) {
    var prop = param[1];
    var match = prop[/* key */0];
    var key;
    switch (match.tag | 0) {
      case 0 : 
          key = literal(match[0]);
          break;
      case 1 : 
          key = identifier(match[0]);
          break;
      case 2 : 
          key = Pervasives.failwith("There should not be computed object type property keys");
          break;
      
    }
    return node("ObjectTypeProperty", param[0], /* array */[
                /* tuple */[
                  "key",
                  key
                ],
                /* tuple */[
                  "value",
                  _type(prop[/* value */1])
                ],
                /* tuple */[
                  "optional",
                  Curry._1(Impl[/* bool */1], prop[/* optional */2])
                ],
                /* tuple */[
                  "static",
                  Curry._1(Impl[/* bool */1], prop[/* static */3])
                ],
                /* tuple */[
                  "variance",
                  option(variance, prop[/* variance */5])
                ]
              ]);
  };
  var object_type_call_property = function (param) {
    var callProperty = param[1];
    return node("ObjectTypeCallProperty", param[0], /* array */[
                /* tuple */[
                  "value",
                  function_type(callProperty[/* value */0])
                ],
                /* tuple */[
                  "static",
                  Curry._1(Impl[/* bool */1], callProperty[/* static */1])
                ]
              ]);
  };
  var object_type_indexer = function (param) {
    var indexer = param[1];
    return node("ObjectTypeIndexer", param[0], /* array */[
                /* tuple */[
                  "id",
                  option(identifier, indexer[/* id */0])
                ],
                /* tuple */[
                  "key",
                  _type(indexer[/* key */1])
                ],
                /* tuple */[
                  "value",
                  _type(indexer[/* value */2])
                ],
                /* tuple */[
                  "static",
                  Curry._1(Impl[/* bool */1], indexer[/* static */3])
                ],
                /* tuple */[
                  "variance",
                  option(variance, indexer[/* variance */4])
                ]
              ]);
  };
  var template_element = function (param) {
    var element = param[1];
    var value = Curry._1(Impl[/* obj */2], /* array */[
          /* tuple */[
            "raw",
            Curry._1(Impl[/* string */0], element[/* value */0][/* raw */0])
          ],
          /* tuple */[
            "cooked",
            Curry._1(Impl[/* string */0], element[/* value */0][/* cooked */1])
          ]
        ]);
    return node("TemplateElement", param[0], /* array */[
                /* tuple */[
                  "value",
                  value
                ],
                /* tuple */[
                  "tail",
                  Curry._1(Impl[/* bool */1], element[/* tail */1])
                ]
              ]);
  };
  var function_params = function (param) {
    var match = param[1];
    var params = param[0];
    if (match) {
      var match$1 = match[0];
      var rest = node("RestElement", match$1[0], /* array */[/* tuple */[
              "argument",
              pattern(match$1[1][/* argument */0])
            ]]);
      var rev_params = List.rev(List.map(pattern, params));
      var params$1 = List.rev(/* :: */[
            rest,
            rev_params
          ]);
      return Curry._1(Impl[/* array */3], $$Array.of_list(params$1));
    } else {
      return array_of_list(pattern, params);
    }
  };
  var block = function (param) {
    return node("BlockStatement", param[0], /* array */[/* tuple */[
                  "body",
                  array_of_list(statement, param[1][/* body */0])
                ]]);
  };
  var predicate = function (param) {
    var p = param[1];
    var match = p ? /* tuple */[
        "DeclaredPredicate",
        /* array */[/* tuple */[
            "value",
            expression(p[0])
          ]]
      ] : /* tuple */[
        "InferredPredicate",
        /* array */[]
      ];
    return node(match[0], param[0], match[1]);
  };
  var comment = function (param) {
    var c = param[1];
    var match;
    match = c.tag ? /* tuple */[
        "Line",
        c[0]
      ] : /* tuple */[
        "Block",
        c[0]
      ];
    return node(match[0], param[0], /* array */[/* tuple */[
                  "value",
                  Curry._1(Impl[/* string */0], match[1])
                ]]);
  };
  var object_type = function (param) {
    var o = param[1];
    return node("ObjectTypeAnnotation", param[0], /* array */[
                /* tuple */[
                  "exact",
                  Curry._1(Impl[/* bool */1], o[/* exact */0])
                ],
                /* tuple */[
                  "properties",
                  array_of_list(object_type_property, o[/* properties */1])
                ],
                /* tuple */[
                  "indexers",
                  array_of_list(object_type_indexer, o[/* indexers */2])
                ],
                /* tuple */[
                  "callProperties",
                  array_of_list(object_type_call_property, o[/* callProperties */3])
                ]
              ]);
  };
  var function_type = function (param) {
    var fn = param[1];
    var match = fn[/* params */0];
    return node("FunctionTypeAnnotation", param[0], /* array */[
                /* tuple */[
                  "params",
                  array_of_list(function_type_param, match[0])
                ],
                /* tuple */[
                  "returnType",
                  _type(fn[/* returnType */1])
                ],
                /* tuple */[
                  "rest",
                  option(function_type_rest, match[1])
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_declaration, fn[/* typeParameters */2])
                ]
              ]);
  };
  var type_param = function (param) {
    var tp = param[1];
    return node("TypeParameter", param[0], /* array */[
                /* tuple */[
                  "name",
                  Curry._1(Impl[/* string */0], tp[/* name */0])
                ],
                /* tuple */[
                  "bound",
                  option(type_annotation, tp[/* bound */1])
                ],
                /* tuple */[
                  "variance",
                  option(variance, tp[/* variance */2])
                ],
                /* tuple */[
                  "default",
                  option(_type, tp[/* default */3])
                ]
              ]);
  };
  var jsx_expression_container = function (param) {
    var match = param[1][/* expression */0];
    var expression$1;
    expression$1 = match.tag ? node("JSXEmptyExpression", match[0], /* array */[]) : expression(match[0]);
    return node("JSXExpressionContainer", param[0], /* array */[/* tuple */[
                  "expression",
                  expression$1
                ]]);
  };
  var jsx_child = function (param) {
    var match = param[1];
    var loc = param[0];
    switch (match.tag | 0) {
      case 0 : 
          return jsx_element(/* tuple */[
                      loc,
                      match[0]
                    ]);
      case 1 : 
          return jsx_expression_container(/* tuple */[
                      loc,
                      match[0]
                    ]);
      case 2 : 
          var param$1 = /* tuple */[
            loc,
            match[0]
          ];
          var text = param$1[1];
          return node("JSXText", param$1[0], /* array */[
                      /* tuple */[
                        "value",
                        Curry._1(Impl[/* string */0], text[/* value */0])
                      ],
                      /* tuple */[
                        "raw",
                        Curry._1(Impl[/* string */0], text[/* raw */1])
                      ]
                    ]);
      
    }
  };
  var jsx_opening = function (param) {
    var opening = param[1];
    return node("JSXOpeningElement", param[0], /* array */[
                /* tuple */[
                  "name",
                  jsx_name(opening[/* name */0])
                ],
                /* tuple */[
                  "attributes",
                  array_of_list(jsx_opening_attribute, opening[/* attributes */2])
                ],
                /* tuple */[
                  "selfClosing",
                  Curry._1(Impl[/* bool */1], opening[/* selfClosing */1])
                ]
              ]);
  };
  var jsx_closing = function (param) {
    return node("JSXClosingElement", param[0], /* array */[/* tuple */[
                  "name",
                  jsx_name(param[1][/* name */0])
                ]]);
  };
  var jsx_element = function (param) {
    var element = param[1];
    return node("JSXElement", param[0], /* array */[
                /* tuple */[
                  "openingElement",
                  jsx_opening(element[/* openingElement */0])
                ],
                /* tuple */[
                  "closingElement",
                  option(jsx_closing, element[/* closingElement */1])
                ],
                /* tuple */[
                  "children",
                  array_of_list(jsx_child, element[/* children */2])
                ]
              ]);
  };
  var object_property = function (param) {
    if (param.tag) {
      var match = param[0];
      return node("SpreadProperty", match[0], /* array */[/* tuple */[
                    "argument",
                    expression(match[1][/* argument */0])
                  ]]);
    } else {
      var match$1 = param[0];
      var prop = match$1[1];
      var match$2 = prop[/* key */0];
      var match$3;
      switch (match$2.tag | 0) {
        case 0 : 
            match$3 = /* tuple */[
              literal(match$2[0]),
              /* false */0
            ];
            break;
        case 1 : 
            match$3 = /* tuple */[
              identifier(match$2[0]),
              /* false */0
            ];
            break;
        case 2 : 
            match$3 = /* tuple */[
              expression(match$2[0]),
              /* true */1
            ];
            break;
        
      }
      var match$4 = prop[/* kind */2];
      var kind;
      switch (match$4) {
        case 0 : 
            kind = "init";
            break;
        case 1 : 
            kind = "get";
            break;
        case 2 : 
            kind = "set";
            break;
        
      }
      return node("Property", match$1[0], /* array */[
                  /* tuple */[
                    "key",
                    match$3[0]
                  ],
                  /* tuple */[
                    "value",
                    expression(prop[/* value */1])
                  ],
                  /* tuple */[
                    "kind",
                    Curry._1(Impl[/* string */0], kind)
                  ],
                  /* tuple */[
                    "method",
                    Curry._1(Impl[/* bool */1], prop[/* _method */3])
                  ],
                  /* tuple */[
                    "shorthand",
                    Curry._1(Impl[/* bool */1], prop[/* shorthand */4])
                  ],
                  /* tuple */[
                    "computed",
                    Curry._1(Impl[/* bool */1], match$3[1])
                  ]
                ]);
    }
  };
  var function_expression = function (param) {
    var _function = param[1];
    var match = _function[/* body */2];
    var body;
    body = match.tag ? expression(match[0]) : block(match[0]);
    return node("FunctionExpression", param[0], /* array */[
                /* tuple */[
                  "id",
                  option(identifier, _function[/* id */0])
                ],
                /* tuple */[
                  "params",
                  function_params(_function[/* params */1])
                ],
                /* tuple */[
                  "body",
                  body
                ],
                /* tuple */[
                  "async",
                  Curry._1(Impl[/* bool */1], _function[/* async */3])
                ],
                /* tuple */[
                  "generator",
                  Curry._1(Impl[/* bool */1], _function[/* generator */4])
                ],
                /* tuple */[
                  "predicate",
                  option(predicate, _function[/* predicate */5])
                ],
                /* tuple */[
                  "expression",
                  Curry._1(Impl[/* bool */1], _function[/* expression */6])
                ],
                /* tuple */[
                  "returnType",
                  option(type_annotation, _function[/* returnType */7])
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_declaration, _function[/* typeParameters */8])
                ]
              ]);
  };
  var expression_or_spread = function (param) {
    if (param.tag) {
      var match = param[0];
      return node("SpreadElement", match[0], /* array */[/* tuple */[
                    "argument",
                    expression(match[1][/* argument */0])
                  ]]);
    } else {
      return expression(param[0]);
    }
  };
  var template_literal = function (param) {
    var value = param[1];
    return node("TemplateLiteral", param[0], /* array */[
                /* tuple */[
                  "quasis",
                  array_of_list(template_element, value[/* quasis */0])
                ],
                /* tuple */[
                  "expressions",
                  array_of_list(expression, value[/* expressions */1])
                ]
              ]);
  };
  var comprehension_block = function (param) {
    var b = param[1];
    return node("ComprehensionBlock", param[0], /* array */[
                /* tuple */[
                  "left",
                  pattern(b[/* left */0])
                ],
                /* tuple */[
                  "right",
                  expression(b[/* right */1])
                ],
                /* tuple */[
                  "each",
                  Curry._1(Impl[/* bool */1], b[/* each */2])
                ]
              ]);
  };
  var interface_extends = function (param) {
    var g = param[1];
    var match = g[/* id */0];
    var id;
    id = match.tag ? generic_type_qualified_identifier(match[0]) : identifier(match[0]);
    return node("InterfaceExtends", param[0], /* array */[
                /* tuple */[
                  "id",
                  id
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_instantiation, g[/* typeParameters */1])
                ]
              ]);
  };
  var variable_declaration = function (param) {
    var $$var = param[1];
    var match = $$var[/* kind */1];
    var kind;
    switch (match) {
      case 0 : 
          kind = "var";
          break;
      case 1 : 
          kind = "let";
          break;
      case 2 : 
          kind = "const";
          break;
      
    }
    return node("VariableDeclaration", param[0], /* array */[
                /* tuple */[
                  "declarations",
                  array_of_list(variable_declarator, $$var[/* declarations */0])
                ],
                /* tuple */[
                  "kind",
                  Curry._1(Impl[/* string */0], kind)
                ]
              ]);
  };
  var $$case = function (param) {
    var c = param[1];
    return node("SwitchCase", param[0], /* array */[
                /* tuple */[
                  "test",
                  option(expression, c[/* test */0])
                ],
                /* tuple */[
                  "consequent",
                  array_of_list(statement, c[/* consequent */1])
                ]
              ]);
  };
  var declare_variable = function (param) {
    var d = param[1];
    var match = d[/* typeAnnotation */1];
    var id_loc = Loc$Jeason.btwn(d[/* id */0][0], match ? match[0][0] : d[/* id */0][0]);
    return node("DeclareVariable", param[0], /* array */[/* tuple */[
                  "id",
                  pattern_identifier(id_loc, /* record */[
                        /* name */d[/* id */0],
                        /* typeAnnotation */d[/* typeAnnotation */1],
                        /* optional : false */0
                      ])
                ]]);
  };
  var export_specifiers = function (param) {
    if (param) {
      var match = param[0];
      if (match.tag) {
        var match$1 = match[1];
        if (match$1) {
          return Curry._1(Impl[/* array */3], /* array */[node("ExportNamespaceSpecifier", match[0], /* array */[/* tuple */[
                              "exported",
                              identifier(match$1[0])
                            ]])]);
        } else {
          return Curry._1(Impl[/* array */3], /* array */[]);
        }
      } else {
        return array_of_list(export_specifier, match[0]);
      }
    } else {
      return Curry._1(Impl[/* array */3], /* array */[]);
    }
  };
  var declare_class = function (param) {
    var d = param[1];
    return node("DeclareClass", param[0], /* array */[
                /* tuple */[
                  "id",
                  identifier(d[/* id */0])
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_declaration, d[/* typeParameters */1])
                ],
                /* tuple */[
                  "body",
                  object_type(d[/* body */2])
                ],
                /* tuple */[
                  "extends",
                  array_of_list(interface_extends, d[/* extends */3])
                ]
              ]);
  };
  var $$catch = function (param) {
    var c = param[1];
    return node("CatchClause", param[0], /* array */[
                /* tuple */[
                  "param",
                  pattern(c[/* param */0])
                ],
                /* tuple */[
                  "body",
                  block(c[/* body */1])
                ]
              ]);
  };
  var declare_function = function (param) {
    var d = param[1];
    var id_loc = Loc$Jeason.btwn(d[/* id */0][0], d[/* typeAnnotation */1][0]);
    return node("DeclareFunction", param[0], /* array */[
                /* tuple */[
                  "id",
                  pattern_identifier(id_loc, /* record */[
                        /* name */d[/* id */0],
                        /* typeAnnotation : Some */[d[/* typeAnnotation */1]],
                        /* optional : false */0
                      ])
                ],
                /* tuple */[
                  "predicate",
                  option(predicate, d[/* predicate */2])
                ]
              ]);
  };
  var interface_declaration = function (param) {
    var i = param[1];
    return node("InterfaceDeclaration", param[0], /* array */[
                /* tuple */[
                  "id",
                  identifier(i[/* id */0])
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_declaration, i[/* typeParameters */1])
                ],
                /* tuple */[
                  "body",
                  object_type(i[/* body */2])
                ],
                /* tuple */[
                  "extends",
                  array_of_list(interface_extends, i[/* extends */3])
                ]
              ]);
  };
  var export_kind = function (param) {
    if (param !== 0) {
      return "value";
    } else {
      return "type";
    }
  };
  var type_alias = function (param) {
    var alias = param[1];
    return node("TypeAlias", param[0], /* array */[
                /* tuple */[
                  "id",
                  identifier(alias[/* id */0])
                ],
                /* tuple */[
                  "typeParameters",
                  option(type_parameter_declaration, alias[/* typeParameters */1])
                ],
                /* tuple */[
                  "right",
                  _type(alias[/* right */2])
                ]
              ]);
  };
  var class_element = function (param) {
    if (param.tag) {
      var param$1 = param[0];
      var prop = param$1[1];
      var match = prop[/* key */0];
      var match$1;
      switch (match.tag | 0) {
        case 0 : 
            match$1 = /* tuple */[
              literal(match[0]),
              /* false */0
            ];
            break;
        case 1 : 
            match$1 = /* tuple */[
              identifier(match[0]),
              /* false */0
            ];
            break;
        case 2 : 
            match$1 = /* tuple */[
              expression(match[0]),
              /* true */1
            ];
            break;
        
      }
      return node("ClassProperty", param$1[0], /* array */[
                  /* tuple */[
                    "key",
                    match$1[0]
                  ],
                  /* tuple */[
                    "value",
                    option(expression, prop[/* value */1])
                  ],
                  /* tuple */[
                    "typeAnnotation",
                    option(type_annotation, prop[/* typeAnnotation */2])
                  ],
                  /* tuple */[
                    "computed",
                    Curry._1(Impl[/* bool */1], match$1[1])
                  ],
                  /* tuple */[
                    "static",
                    Curry._1(Impl[/* bool */1], prop[/* static */3])
                  ],
                  /* tuple */[
                    "variance",
                    option(variance, prop[/* variance */4])
                  ]
                ]);
    } else {
      var param$2 = param[0];
      var method_ = param$2[1];
      var key = method_[/* key */1];
      var match$2;
      switch (key.tag | 0) {
        case 0 : 
            match$2 = /* tuple */[
              literal(key[0]),
              /* false */0
            ];
            break;
        case 1 : 
            match$2 = /* tuple */[
              identifier(key[0]),
              /* false */0
            ];
            break;
        case 2 : 
            match$2 = /* tuple */[
              expression(key[0]),
              /* true */1
            ];
            break;
        
      }
      var kind;
      switch (method_[/* kind */0]) {
        case 0 : 
            kind = "constructor";
            break;
        case 1 : 
            kind = "method";
            break;
        case 2 : 
            kind = "get";
            break;
        case 3 : 
            kind = "set";
            break;
        
      }
      return node("MethodDefinition", param$2[0], /* array */[
                  /* tuple */[
                    "key",
                    match$2[0]
                  ],
                  /* tuple */[
                    "value",
                    function_expression(method_[/* value */2])
                  ],
                  /* tuple */[
                    "kind",
                    Curry._1(Impl[/* string */0], kind)
                  ],
                  /* tuple */[
                    "static",
                    Curry._1(Impl[/* bool */1], method_[/* static */3])
                  ],
                  /* tuple */[
                    "computed",
                    Curry._1(Impl[/* bool */1], match$2[1])
                  ],
                  /* tuple */[
                    "decorators",
                    array_of_list(expression, method_[/* decorators */4])
                  ]
                ]);
    }
  };
  var jsx_attribute_value = function (param) {
    if (param.tag) {
      return jsx_expression_container(/* tuple */[
                  param[0],
                  param[1]
                ]);
    } else {
      return literal(/* tuple */[
                  param[0],
                  param[1]
                ]);
    }
  };
  var program = function (param) {
    return node("Program", param[0], /* array */[
                /* tuple */[
                  "body",
                  array_of_list(statement, param[1])
                ],
                /* tuple */[
                  "comments",
                  array_of_list(comment, param[2])
                ]
              ]);
  };
  return /* module */[
          /* program */program,
          /* expression */expression,
          /* errors */errors
        ];
}

var Ast = 0;

exports.Ast = Ast;
exports.Translate = Translate;
/* Loc-Jeason Not a pure module */
