// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Buffer = require("bs-platform/lib/js/buffer.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Parsing = require("bs-platform/lib/js/parsing.js");
var Caml_sys = require("bs-platform/lib/js/caml_sys.js");
var Filename = require("bs-platform/lib/js/filename.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Warnings$Jeason = require("./warnings.bs.js");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var absname = [/* false */0];

function in_file(name) {
  var loc = /* record */[
    /* pos_fname */name,
    /* pos_lnum */1,
    /* pos_bol */0,
    /* pos_cnum */-1
  ];
  return /* record */[
          /* loc_start */loc,
          /* loc_end */loc,
          /* loc_ghost : true */1
        ];
}

var none = in_file("_none_");

function curr(lexbuf) {
  return /* record */[
          /* loc_start */lexbuf[/* lex_start_p */10],
          /* loc_end */lexbuf[/* lex_curr_p */11],
          /* loc_ghost : false */0
        ];
}

function init(lexbuf, fname) {
  lexbuf[/* lex_curr_p */11] = /* record */[
    /* pos_fname */fname,
    /* pos_lnum */1,
    /* pos_bol */0,
    /* pos_cnum */0
  ];
  return /* () */0;
}

function symbol_rloc() {
  return /* record */[
          /* loc_start */Parsing.symbol_start_pos(/* () */0),
          /* loc_end */Parsing.symbol_end_pos(/* () */0),
          /* loc_ghost : false */0
        ];
}

function symbol_gloc() {
  return /* record */[
          /* loc_start */Parsing.symbol_start_pos(/* () */0),
          /* loc_end */Parsing.symbol_end_pos(/* () */0),
          /* loc_ghost : true */1
        ];
}

function rhs_loc(n) {
  return /* record */[
          /* loc_start */Parsing.rhs_start_pos(n),
          /* loc_end */Parsing.rhs_end_pos(n),
          /* loc_ghost : false */0
        ];
}

var input_name = ["_none_"];

var input_lexbuf = [/* None */0];

var status = [/* Uninitialised */0];

var num_loc_lines = [0];

function print_updating_num_loc_lines(ppf, f, arg) {
  var out_functions = Format.pp_get_formatter_out_functions(ppf, /* () */0);
  var out_string = function (str, start, len) {
    var count = function (_i, _c) {
      while(true) {
        var c = _c;
        var i = _i;
        if (i === (start + len | 0)) {
          return c;
        } else if (Caml_string.get(str, i) === /* "\n" */10) {
          _c = c + 1 | 0;
          _i = i + 1 | 0;
          continue ;
          
        } else {
          _i = i + 1 | 0;
          continue ;
          
        }
      };
    };
    num_loc_lines[0] = num_loc_lines[0] + count(start, 0) | 0;
    return Curry._3(out_functions[/* out_string */0], str, start, len);
  };
  Format.pp_set_formatter_out_functions(ppf, /* record */[
        /* out_string */out_string,
        /* out_flush */out_functions[/* out_flush */1],
        /* out_newline */out_functions[/* out_newline */2],
        /* out_spaces */out_functions[/* out_spaces */3]
      ]);
  Curry._2(f, ppf, arg);
  Format.pp_print_flush(ppf, /* () */0);
  return Format.pp_set_formatter_out_functions(ppf, out_functions);
}

function highlight_terminfo(ppf, num_lines, lb, locs) {
  Format.pp_print_flush(ppf, /* () */0);
  var pos0 = -lb[/* lex_abs_pos */3] | 0;
  if (pos0 < 0) {
    throw Pervasives.Exit;
  }
  var lines = num_loc_lines[0];
  for(var i = pos0 ,i_finish = lb[/* lex_buffer_len */2] - 1 | 0; i <= i_finish; ++i){
    if (Caml_bytes.get(lb[/* lex_buffer */1], i) === /* "\n" */10) {
      lines = lines + 1 | 0;
    }
    
  }
  if (lines >= (num_lines - 2 | 0)) {
    throw Pervasives.Exit;
  }
  Pervasives.flush(Pervasives.stdout);
  Caml_missing_polyfill.not_implemented("caml_terminfo_backup not implemented by bucklescript yet\n");
  var bol = /* false */0;
  Pervasives.print_string("# ");
  for(var pos = 0 ,pos_finish = (lb[/* lex_buffer_len */2] - pos0 | 0) - 1 | 0; pos <= pos_finish; ++pos){
    if (bol) {
      Pervasives.print_string("  ");
      bol = /* false */0;
    }
    if (List.exists((function(pos){
          return function (loc) {
            return +(pos === loc[/* loc_start */0][/* pos_cnum */3]);
          }
          }(pos)), locs)) {
      Caml_missing_polyfill.not_implemented("caml_terminfo_standout not implemented by bucklescript yet\n");
    }
    if (List.exists((function(pos){
          return function (loc) {
            return +(pos === loc[/* loc_end */1][/* pos_cnum */3]);
          }
          }(pos)), locs)) {
      Caml_missing_polyfill.not_implemented("caml_terminfo_standout not implemented by bucklescript yet\n");
    }
    var c = Caml_bytes.get(lb[/* lex_buffer */1], pos + pos0 | 0);
    Pervasives.print_char(c);
    bol = +(c === /* "\n" */10);
  }
  Caml_missing_polyfill.not_implemented("caml_terminfo_standout not implemented by bucklescript yet\n");
  Caml_missing_polyfill.not_implemented("caml_terminfo_resume not implemented by bucklescript yet\n");
  return Pervasives.flush(Pervasives.stdout);
}

function highlight_dumb(ppf, lb, loc) {
  var pos0 = -lb[/* lex_abs_pos */3] | 0;
  if (pos0 < 0) {
    throw Pervasives.Exit;
  }
  var end_pos = (lb[/* lex_buffer_len */2] - pos0 | 0) - 1 | 0;
  var line_start = 0;
  var line_end = 0;
  for(var pos = 0; pos <= end_pos; ++pos){
    if (Caml_bytes.get(lb[/* lex_buffer */1], pos + pos0 | 0) === /* "\n" */10) {
      if (loc[/* loc_start */0][/* pos_cnum */3] > pos) {
        line_start = line_start + 1 | 0;
      }
      if (loc[/* loc_end */1][/* pos_cnum */3] > pos) {
        line_end = line_end + 1 | 0;
      }
      
    }
    
  }
  Curry._2(Format.fprintf(ppf, /* Format */[
            /* String_literal */Block.__(11, [
                "Characters ",
                /* Int */Block.__(4, [
                    /* Int_i */3,
                    /* No_padding */0,
                    /* No_precision */0,
                    /* Char_literal */Block.__(12, [
                        /* "-" */45,
                        /* Int */Block.__(4, [
                            /* Int_i */3,
                            /* No_padding */0,
                            /* No_precision */0,
                            /* Char_literal */Block.__(12, [
                                /* ":" */58,
                                /* Formatting_lit */Block.__(17, [
                                    /* Flush_newline */4,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ])
                  ])
              ]),
            "Characters %i-%i:@."
          ]), loc[/* loc_start */0][/* pos_cnum */3], loc[/* loc_end */1][/* pos_cnum */3]);
  Format.pp_print_string(ppf, "  ");
  var line = 0;
  var pos_at_bol = 0;
  for(var pos$1 = 0; pos$1 <= end_pos; ++pos$1){
    var c = Caml_bytes.get(lb[/* lex_buffer */1], pos$1 + pos0 | 0);
    if (c !== 10) {
      if (c !== 13) {
        if (line === line_start && line === line_end) {
          Format.pp_print_char(ppf, c);
        } else if (line === line_start) {
          if (pos$1 < loc[/* loc_start */0][/* pos_cnum */3]) {
            Format.pp_print_char(ppf, /* "." */46);
          } else {
            Format.pp_print_char(ppf, c);
          }
        } else if (line === line_end) {
          if (pos$1 < loc[/* loc_end */1][/* pos_cnum */3]) {
            Format.pp_print_char(ppf, c);
          } else {
            Format.pp_print_char(ppf, /* "." */46);
          }
        } else if (line > line_start && line < line_end) {
          Format.pp_print_char(ppf, c);
        }
        
      }
      
    } else {
      if (line === line_start && line === line_end) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Flush_newline */4,
                  /* String_literal */Block.__(11, [
                      "  ",
                      /* End_of_format */0
                    ])
                ]),
              "@.  "
            ]);
        for(var _i = pos_at_bol ,_i_finish = loc[/* loc_start */0][/* pos_cnum */3] - 1 | 0; _i <= _i_finish; ++_i){
          Format.pp_print_char(ppf, /* " " */32);
        }
        for(var _i$1 = loc[/* loc_start */0][/* pos_cnum */3] ,_i_finish$1 = loc[/* loc_end */1][/* pos_cnum */3] - 1 | 0; _i$1 <= _i_finish$1; ++_i$1){
          Format.pp_print_char(ppf, /* "^" */94);
        }
      }
      if (line >= line_start && line <= line_end) {
        Format.fprintf(ppf, /* Format */[
              /* Formatting_lit */Block.__(17, [
                  /* Flush_newline */4,
                  /* End_of_format */0
                ]),
              "@."
            ]);
        if (pos$1 < loc[/* loc_end */1][/* pos_cnum */3]) {
          Format.pp_print_string(ppf, "  ");
        }
        
      }
      line = line + 1 | 0;
      pos_at_bol = pos$1 + 1 | 0;
    }
  }
  return /* () */0;
}

function highlight_locations(ppf, locs) {
  while(true) {
    var match = status[0];
    if (typeof match === "number") {
      if (match !== 0) {
        var match$1 = input_lexbuf[0];
        if (match$1) {
          var norepeat;
          try {
            norepeat = +(Caml_sys.caml_sys_getenv("TERM") === "norepeat");
          }
          catch (exn){
            if (exn === Caml_builtin_exceptions.not_found) {
              norepeat = /* false */0;
            } else {
              throw exn;
            }
          }
          if (norepeat) {
            return /* false */0;
          } else {
            var loc1 = List.hd(locs);
            try {
              highlight_dumb(ppf, match$1[0], loc1);
              return /* true */1;
            }
            catch (exn$1){
              if (exn$1 === Pervasives.Exit) {
                return /* false */0;
              } else {
                throw exn$1;
              }
            }
          }
        } else {
          return /* false */0;
        }
      } else {
        status[0] = Caml_missing_polyfill.not_implemented("caml_terminfo_setup not implemented by bucklescript yet\n");
        continue ;
        
      }
    } else {
      var match$2 = input_lexbuf[0];
      if (match$2) {
        try {
          highlight_terminfo(ppf, match[0], match$2[0], locs);
          return /* true */1;
        }
        catch (exn$2){
          if (exn$2 === Pervasives.Exit) {
            return /* false */0;
          } else {
            throw exn$2;
          }
        }
      } else {
        return /* false */0;
      }
    }
  };
}

function absolute_path(s) {
  var s$1 = Curry._1(Filename.is_relative, s) ? Filename.concat(Caml_sys.caml_sys_getcwd(/* () */0), s) : s;
  var aux = function (_s) {
    while(true) {
      var s = _s;
      var base = Curry._1(Filename.basename, s);
      var dir = Curry._1(Filename.dirname, s);
      if (dir === s) {
        return dir;
      } else if (base === Filename.current_dir_name) {
        _s = dir;
        continue ;
        
      } else if (base === Filename.parent_dir_name) {
        return Curry._1(Filename.dirname, aux(dir));
      } else {
        return Filename.concat(aux(dir), base);
      }
    };
  };
  return aux(s$1);
}

function show_filename(file) {
  if (absname[0]) {
    return absolute_path(file);
  } else {
    return file;
  }
}

function print_filename(ppf, file) {
  return Curry._1(Format.fprintf(ppf, /* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ]),
                  "%s"
                ]), show_filename(file));
}

function reset() {
  num_loc_lines[0] = 0;
  return /* () */0;
}

function get_pos_info(pos) {
  return /* tuple */[
          pos[/* pos_fname */0],
          pos[/* pos_lnum */1],
          pos[/* pos_cnum */3] - pos[/* pos_bol */2] | 0
        ];
}

function print_loc(ppf, loc) {
  var match = get_pos_info(loc[/* loc_start */0]);
  var startchar = match[2];
  var file = match[0];
  var endchar = (loc[/* loc_end */1][/* pos_cnum */3] - loc[/* loc_start */0][/* pos_cnum */3] | 0) + startchar | 0;
  if (file === "//toplevel//") {
    if (highlight_locations(ppf, /* :: */[
            loc,
            /* [] */0
          ])) {
      return /* () */0;
    } else {
      return Curry._2(Format.fprintf(ppf, /* Format */[
                      /* String_literal */Block.__(11, [
                          "Characters ",
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* Char_literal */Block.__(12, [
                                  /* "-" */45,
                                  /* Int */Block.__(4, [
                                      /* Int_i */3,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "Characters %i-%i"
                    ]), loc[/* loc_start */0][/* pos_cnum */3], loc[/* loc_end */1][/* pos_cnum */3]);
    }
  } else {
    Curry._5(Format.fprintf(ppf, /* Format */[
              /* String */Block.__(2, [
                  /* No_padding */0,
                  /* Alpha */Block.__(15, [/* String */Block.__(2, [
                          /* No_padding */0,
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* End_of_format */0
                            ])
                        ])])
                ]),
              "%s%a%s%i"
            ]), "File \"", print_filename, file, "\", line ", match[1]);
    if (startchar >= 0) {
      return Curry._4(Format.fprintf(ppf, /* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Int */Block.__(4, [
                              /* Int_i */3,
                              /* No_padding */0,
                              /* No_precision */0,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* Int */Block.__(4, [
                                      /* Int_i */3,
                                      /* No_padding */0,
                                      /* No_precision */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "%s%i%s%i"
                    ]), ", characters ", startchar, "-", endchar);
    } else {
      return 0;
    }
  }
}

function print(ppf, loc) {
  if (loc[/* loc_start */0][/* pos_fname */0] === "//toplevel//" && highlight_locations(ppf, /* :: */[
          loc,
          /* [] */0
        ])) {
    return /* () */0;
  } else {
    return Curry._3(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* String */Block.__(2, [
                            /* No_padding */0,
                            /* Formatting_lit */Block.__(17, [
                                /* Flush_newline */4,
                                /* End_of_format */0
                              ])
                          ])]),
                    "%a%s@."
                  ]), print_loc, loc, ":");
  }
}

function print_error(ppf, loc) {
  print(ppf, loc);
  return Format.fprintf(ppf, /* Format */[
              /* String_literal */Block.__(11, [
                  "Error: ",
                  /* End_of_format */0
                ]),
              "Error: "
            ]);
}

function print_error_cur_file(ppf) {
  return print_error(ppf, in_file(input_name[0]));
}

function default_warning_printer(loc, ppf, w) {
  if (Warnings$Jeason.is_active(w)) {
    print(ppf, loc);
    return Curry._2(Format.fprintf(ppf, /* Format */[
                    /* String_literal */Block.__(11, [
                        "Warning ",
                        /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                /* Flush_newline */4,
                                /* End_of_format */0
                              ])])
                      ]),
                    "Warning %a@."
                  ]), Warnings$Jeason.print, w);
  } else {
    return 0;
  }
}

var warning_printer = [default_warning_printer];

function print_warning(loc, ppf, w) {
  return print_updating_num_loc_lines(ppf, Curry._1(warning_printer[0], loc), w);
}

var formatter_for_warnings = [Format.err_formatter];

function prerr_warning(loc, w) {
  return print_warning(loc, formatter_for_warnings[0], w);
}

function echo_eof() {
  Format.print_newline(/* () */0);
  num_loc_lines[0] = num_loc_lines[0] + 1 | 0;
  return /* () */0;
}

function mkloc(txt, loc) {
  return /* record */[
          /* txt */txt,
          /* loc */loc
        ];
}

function mknoloc(txt) {
  return /* record */[
          /* txt */txt,
          /* loc */none
        ];
}

function errorf($staropt$star, $staropt$star$1, $staropt$star$2) {
  var loc = $staropt$star ? $staropt$star[0] : none;
  var sub = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var if_highlight = $staropt$star$2 ? $staropt$star$2[0] : "";
  return (function (param) {
      return Printf.ksprintf((function (msg) {
                    return /* record */[
                            /* loc */loc,
                            /* msg */msg,
                            /* sub */sub,
                            /* if_highlight */if_highlight
                          ];
                  }), param);
    });
}

function error($staropt$star, $staropt$star$1, $staropt$star$2, msg) {
  var loc = $staropt$star ? $staropt$star[0] : none;
  var sub = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var if_highlight = $staropt$star$2 ? $staropt$star$2[0] : "";
  return /* record */[
          /* loc */loc,
          /* msg */msg,
          /* sub */sub,
          /* if_highlight */if_highlight
        ];
}

var error_of_exn = [/* [] */0];

function register_error_of_exn(f) {
  error_of_exn[0] = /* :: */[
    f,
    error_of_exn[0]
  ];
  return /* () */0;
}

function error_of_exn$1(exn) {
  var _param = error_of_exn[0];
  while(true) {
    var param = _param;
    if (param) {
      var r = Curry._1(param[0], exn);
      if (r) {
        return r;
      } else {
        _param = param[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function default_error_reporter(ppf, err) {
  var if_highlight = err[/* if_highlight */3];
  var highlighted;
  if (if_highlight !== "") {
    var collect_locs = function (locs, param) {
      return List.fold_left(collect_locs, /* :: */[
                  param[/* loc */0],
                  locs
                ], param[/* sub */2]);
    };
    var locs = collect_locs(/* [] */0, err);
    highlighted = highlight_locations(ppf, locs);
  } else {
    highlighted = /* false */0;
  }
  if (highlighted) {
    return Format.pp_print_string(ppf, if_highlight);
  } else {
    print(ppf, err[/* loc */0]);
    Format.pp_print_string(ppf, err[/* msg */1]);
    return List.iter((function (err) {
                  return Curry._2(Format.fprintf(ppf, /* Format */[
                                  /* Formatting_lit */Block.__(17, [
                                      /* Force_newline */3,
                                      /* Formatting_gen */Block.__(18, [
                                          /* Open_box */Block.__(1, [/* Format */[
                                                /* String_literal */Block.__(11, [
                                                    "<2>",
                                                    /* End_of_format */0
                                                  ]),
                                                "<2>"
                                              ]]),
                                          /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                                  /* Close_box */0,
                                                  /* End_of_format */0
                                                ])])
                                        ])
                                    ]),
                                  "@\n@[<2>%a@]"
                                ]), default_error_reporter, err);
                }), err[/* sub */2]);
  }
}

var error_reporter = [default_error_reporter];

function report_error(ppf, err) {
  return print_updating_num_loc_lines(ppf, error_reporter[0], err);
}

function error_of_printer(loc, print, x) {
  var buf = Buffer.create(64);
  var ppf = Format.formatter_of_buffer(buf);
  Format.pp_print_string(ppf, "Error: ");
  Curry._2(print, ppf, x);
  Format.pp_print_flush(ppf, /* () */0);
  return Curry._1(errorf(/* Some */[loc], /* None */0, /* None */0)(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* End_of_format */0
                    ]),
                  "%s"
                ]), Buffer.contents(buf));
}

function error_of_printer_file(print, x) {
  return error_of_printer(in_file(input_name[0]), print, x);
}

register_error_of_exn((function (param) {
        if (param[0] === Caml_builtin_exceptions.sys_error) {
          return /* Some */[Curry._1(errorf(/* Some */[in_file(input_name[0])], /* None */0, /* None */0)(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Error: I/O error: ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ]),
                            "Error: I/O error: %s"
                          ]), param[1])];
        } else if (param[0] === Warnings$Jeason.Errors) {
          return /* Some */[Curry._1(errorf(/* Some */[in_file(input_name[0])], /* None */0, /* None */0)(/* Format */[
                            /* String_literal */Block.__(11, [
                                "Error: Some fatal warnings were triggered (",
                                /* Int */Block.__(4, [
                                    /* Int_d */0,
                                    /* No_padding */0,
                                    /* No_precision */0,
                                    /* String_literal */Block.__(11, [
                                        " occurrences)",
                                        /* End_of_format */0
                                      ])
                                  ])
                              ]),
                            "Error: Some fatal warnings were triggered (%d occurrences)"
                          ]), param[1])];
        } else {
          return /* None */0;
        }
      }));

function report_exception(ppf, exn) {
  var _n = 5;
  var ppf$1 = ppf;
  var _exn = exn;
  while(true) {
    var exn$1 = _exn;
    var n = _n;
    try {
      var match = error_of_exn$1(exn$1);
      if (match) {
        return Curry._2(Format.fprintf(ppf$1, /* Format */[
                        /* Formatting_gen */Block.__(18, [
                            /* Open_box */Block.__(1, [/* Format */[
                                  /* End_of_format */0,
                                  ""
                                ]]),
                            /* Alpha */Block.__(15, [/* Formatting_lit */Block.__(17, [
                                    /* Close_box */0,
                                    /* Formatting_lit */Block.__(17, [
                                        /* Flush_newline */4,
                                        /* End_of_format */0
                                      ])
                                  ])])
                          ]),
                        "@[%a@]@."
                      ]), report_error, match[0]);
      } else {
        throw exn$1;
      }
    }
    catch (raw_exn){
      var exn$2 = Js_exn.internalToOCamlException(raw_exn);
      if (n > 0) {
        _exn = exn$2;
        _n = n - 1 | 0;
        continue ;
        
      } else {
        throw exn$2;
      }
    }
  };
}

var $$Error = Caml_exceptions.create("Location-Jeason.Error");

register_error_of_exn((function (param) {
        if (param[0] === $$Error) {
          return /* Some */[param[1]];
        } else {
          return /* None */0;
        }
      }));

function raise_errorf($staropt$star, $staropt$star$1, $staropt$star$2) {
  var loc = $staropt$star ? $staropt$star[0] : none;
  var sub = $staropt$star$1 ? $staropt$star$1[0] : /* [] */0;
  var if_highlight = $staropt$star$2 ? $staropt$star$2[0] : "";
  return (function (param) {
      return Printf.ksprintf((function (msg) {
                    throw [
                          $$Error,
                          /* record */[
                            /* loc */loc,
                            /* msg */msg,
                            /* sub */sub,
                            /* if_highlight */if_highlight
                          ]
                        ];
                  }), param);
    });
}

exports.none = none;
exports.in_file = in_file;
exports.init = init;
exports.curr = curr;
exports.symbol_rloc = symbol_rloc;
exports.symbol_gloc = symbol_gloc;
exports.rhs_loc = rhs_loc;
exports.input_name = input_name;
exports.input_lexbuf = input_lexbuf;
exports.get_pos_info = get_pos_info;
exports.print_loc = print_loc;
exports.print_error = print_error;
exports.print_error_cur_file = print_error_cur_file;
exports.print_warning = print_warning;
exports.formatter_for_warnings = formatter_for_warnings;
exports.prerr_warning = prerr_warning;
exports.echo_eof = echo_eof;
exports.reset = reset;
exports.warning_printer = warning_printer;
exports.default_warning_printer = default_warning_printer;
exports.highlight_locations = highlight_locations;
exports.mknoloc = mknoloc;
exports.mkloc = mkloc;
exports.print = print;
exports.print_filename = print_filename;
exports.absolute_path = absolute_path;
exports.show_filename = show_filename;
exports.absname = absname;
exports.$$Error = $$Error;
exports.error = error;
exports.errorf = errorf;
exports.raise_errorf = raise_errorf;
exports.error_of_printer = error_of_printer;
exports.error_of_printer_file = error_of_printer_file;
exports.error_of_exn = error_of_exn$1;
exports.register_error_of_exn = register_error_of_exn;
exports.report_error = report_error;
exports.error_reporter = error_reporter;
exports.default_error_reporter = default_error_reporter;
exports.report_exception = report_exception;
/* none Not a pure module */
